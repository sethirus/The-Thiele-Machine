#!/usr/bin/env python3
"""
The Forge: Genetic Programming Engine for Strategy Evolution

This tool uses genetic programming to evolve new partitioning strategies
by combining and mutating the DNA of existing proven strategies.

The Arch-Sphere serves as the oracle, judging each new creation.
"""

import random
import re
import json
import hashlib
from pathlib import Path
from typing import List, Dict, Tuple, Optional, Any
import networkx as nx
import sys

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from thielecpu.primitives import PRIMITIVES, get_primitive, list_primitives
from tools.evaluation_functions import evaluate_strategy_with_objective


class StrategyDNA:
    """Represents a strategy as a sequence of primitives (its DNA)."""
    
    def __init__(self, name: str, sequence: List[str], metadata: Dict[str, Any] = None):
        self.name = name
        self.sequence = sequence
        self.metadata = metadata or {}
        
    def __repr__(self):
        return f"StrategyDNA(name='{self.name}', primitives={len(self.sequence)})"
    
    def to_thiele(self) -> str:
        """Convert DNA to .thiele file format."""
        lines = [
            f"# EVOLVED STRATEGY: {self.name}",
            f"# Generated by The Forge",
            "",
            f"STRATEGY {self.name}",
            "VERSION 2.0",
            f"DESCRIPTION \"{self.metadata.get('description', 'Evolved strategy')}\"",
            "",
            "SEQUENCE:"
        ]
        
        for step in self.sequence:
            lines.append(f"  {step}")
        
        lines.extend([
            "",
            "METADATA:",
            f"  primitive_count: {len(self.sequence)}",
            f"  complexity: {self.metadata.get('complexity', 'UNKNOWN')}",
            f"  basis: \"{self.metadata.get('basis', 'Evolved')}\"",
            f"  generation: {self.metadata.get('generation', 0)}",
            f"  fitness: {float(self.metadata.get('fitness', 0.0)):.4f}"
        ])
        
        return "\n".join(lines)


def load_thiele_dna(filepath: Path) -> StrategyDNA:
    """Load strategy DNA from .thiele file."""
    with open(filepath, 'r') as f:
        content = f.read()
    
    # Extract strategy name
    name_match = re.search(r'STRATEGY\s+(\w+)', content)
    name = name_match.group(1) if name_match else filepath.stem
    
    # Extract sequence
    sequence_match = re.search(r'SEQUENCE:(.*?)(?:METADATA:|$)', content, re.DOTALL)
    if not sequence_match:
        return StrategyDNA(name, [], {})
    
    sequence_text = sequence_match.group(1).strip()
    sequence = []
    for line in sequence_text.split('\n'):
        line = line.strip()
        if line and not line.startswith('#'):
            sequence.append(line)
    
    # Extract metadata
    metadata = {}
    metadata_match = re.search(r'METADATA:(.*?)$', content, re.DOTALL)
    if metadata_match:
        metadata_text = metadata_match.group(1).strip()
        for line in metadata_text.split('\n'):
            if ':' in line:
                key, value = line.split(':', 1)
                key = key.strip()
                value = value.strip().strip('"')
                
                # Handle list syntax [item1, item2, ...]
                if value.startswith('[') and value.endswith(']'):
                    # Parse as list
                    list_content = value[1:-1]  # Remove brackets
                    items = [item.strip().strip('"') for item in list_content.split(',')]
                    metadata[key] = items
                else:
                    metadata[key] = value
    
    return StrategyDNA(name, sequence, metadata)


def crossover(parent1: StrategyDNA, parent2: StrategyDNA, generation: int = 0) -> StrategyDNA:
    """
    Perform genetic crossover between two parent strategies.
    
    Randomly select sequences from both parents and combine them.
    """
    # Determine crossover point
    len1, len2 = len(parent1.sequence), len(parent2.sequence)
    
    if len1 == 0 and len2 == 0:
        return StrategyDNA(f"evolved_{generation}_empty", [], {'generation': generation})
    
    if len1 == 0:
        return StrategyDNA(f"evolved_{generation}_{parent2.name}", parent2.sequence.copy(), 
                          {'generation': generation, 'parent': parent2.name})
    if len2 == 0:
        return StrategyDNA(f"evolved_{generation}_{parent1.name}", parent1.sequence.copy(),
                          {'generation': generation, 'parent': parent1.name})
    
    # Random crossover point for each parent
    point1 = random.randint(0, len1)
    point2 = random.randint(0, len2)
    
    # Combine sequences
    new_sequence = parent1.sequence[:point1] + parent2.sequence[point2:]
    
    # Create name
    name = f"evolved_{generation}_{parent1.name}_{parent2.name}"
    hash_suffix = hashlib.md5(str(new_sequence).encode()).hexdigest()[:6]
    name = f"{name}_{hash_suffix}"
    
    metadata = {
        'generation': generation,
        'parents': [parent1.name, parent2.name],
        'crossover_points': [point1, point2],
        'description': f"Crossover of {parent1.name} and {parent2.name}"
    }
    
    return StrategyDNA(name, new_sequence, metadata)


def mutate(strategy: StrategyDNA, mutation_rate: float = 0.2, generation: int = 0) -> StrategyDNA:
    """
    Mutate a strategy by randomly altering primitives.
    
    Mutations can:
    - Replace a primitive with another
    - Add a new primitive
    - Remove a primitive
    """
    if len(strategy.sequence) == 0 or random.random() > mutation_rate:
        return strategy  # No mutation
    
    new_sequence = strategy.sequence.copy()
    mutation_type = random.choice(['replace', 'insert', 'delete'])
    
    if mutation_type == 'replace' and len(new_sequence) > 0:
        # Replace random primitive with another
        idx = random.randint(0, len(new_sequence) - 1)
        # Keep structure but change the primitive name
        original = new_sequence[idx]
        primitive_names = list_primitives()
        new_primitive = random.choice(primitive_names)
        
        # Try to preserve variable assignments
        if '=' in original:
            var_part = original.split('=')[0].strip()
            new_sequence[idx] = f"{var_part} = {new_primitive}(...)"
        else:
            new_sequence[idx] = f"{new_primitive}(...)"
    
    elif mutation_type == 'insert':
        # Insert new primitive at random position
        idx = random.randint(0, len(new_sequence))
        primitive_names = list_primitives()
        new_primitive = random.choice(primitive_names)
        new_sequence.insert(idx, f"{new_primitive}(...)")
    
    elif mutation_type == 'delete' and len(new_sequence) > 1:
        # Remove random primitive
        idx = random.randint(0, len(new_sequence) - 1)
        new_sequence.pop(idx)
    
    name = f"mutant_{generation}_{strategy.name}"
    hash_suffix = hashlib.md5(str(new_sequence).encode()).hexdigest()[:6]
    name = f"{name}_{hash_suffix}"
    
    metadata = {
        'generation': generation,
        'parent': strategy.name,
        'mutation_type': mutation_type,
        'description': f"Mutation of {strategy.name}"
    }
    
    return StrategyDNA(name, new_sequence, metadata)


def compile_to_python(strategy: StrategyDNA, output_dir: Path) -> Optional[Path]:
    """
    Attempt to compile a strategy DNA sequence into runnable Python code.
    
    Many will fail - this is the nature of evolution.
    
    Returns:
        Path to compiled .py file if successful, None if compilation failed
    """
    # Generate Python function
    func_name = f"strategy_{strategy.name}"
    
    code_lines = [
        f"#!/usr/bin/env python3",
        f"\"\"\"",
        f"Evolved Strategy: {strategy.name}",
        f"Generation: {strategy.metadata.get('generation', 'unknown')}",
        f"\"\"\"",
        "",
        "import networkx as nx",
        "from typing import Dict",
        "from thielecpu.primitives import *",
        "",
        f"def {func_name}(G: nx.Graph, n_clusters: int = 4, seed: int = 42) -> Dict[int, int]:",
        f"    \"\"\"Evolved partitioning strategy.\"\"\"",
        "    try:"
    ]
    
    # Add each step in the sequence
    for step in strategy.sequence:
        code_lines.append(f"        {step}")
    
    code_lines.extend([
        "        ",
        "        # Return partition (must be defined in sequence)",
        "        if 'partition' in locals():",
        "            return partition",
        "        else:",
        "            # Fallback: create simple partition",
        "            nodes = sorted(G.nodes())",
        "            return {node: i % n_clusters for i, node in enumerate(nodes)}",
        "    except Exception as e:",
        "        # Compilation/execution failed",
        "        print(f'Strategy {strategy.name} failed: {e}')",
        "        nodes = sorted(G.nodes())",
        "        return {node: 0 for node in nodes}"
    ])
    
    code = "\n".join(code_lines)
    
    # Write to file
    output_file = output_dir / f"{strategy.name}.py"
    try:
        with open(output_file, 'w') as f:
            f.write(code)
        return output_file
    except Exception as e:
        print(f"Failed to write compiled strategy: {e}")
        return None


def forge_evolution_cycle(
    parents: List[StrategyDNA],
    generation: int,
    population_size: int = 10,
    mutation_rate: float = 0.2
) -> List[StrategyDNA]:
    """
    Run one generation of evolutionary process.
    
    Returns:
        List of offspring strategies
    """
    offspring = []
    
    # Crossover: create new strategies by combining parents
    for _ in range(population_size // 2):
        if len(parents) >= 2:
            parent1, parent2 = random.sample(parents, 2)
            child = crossover(parent1, parent2, generation)
            offspring.append(child)
    
    # Mutation: mutate existing strategies
    for _ in range(population_size // 2):
        if len(parents) > 0:
            parent = random.choice(parents)
            mutant = mutate(parent, mutation_rate, generation)
            offspring.append(mutant)
    
    return offspring


def main():
    """Main forge execution loop."""
    print("=" * 70)
    print("THE FORGE OF PERPETUAL ASCENSION")
    print("=" * 70)
    print()
    
    # Load parent strategies
    strategies_dir = Path(__file__).parent.parent / "strategies"
    parent_files = list(strategies_dir.glob("*.thiele"))
    
    print(f"Loading {len(parent_files)} parent strategies...")
    parents = []
    for filepath in parent_files:
        dna = load_thiele_dna(filepath)
        parents.append(dna)
        print(f"  - {dna.name}: {len(dna.sequence)} primitives")
    
    print()
    print("Starting evolutionary synthesis...")
    print()
    
    # Create output directories
    output_dir = Path(__file__).parent.parent / "evolved_strategies"
    output_dir.mkdir(exist_ok=True)
    
    compiled_dir = output_dir / "compiled"
    compiled_dir.mkdir(exist_ok=True)
    
    # Evolution parameters
    num_generations = 3
    population_size = 10
    mutation_rate = 0.2
    
    all_offspring = []
    
    for generation in range(1, num_generations + 1):
        print(f"Generation {generation}:")
        
        # Evolve new strategies
        offspring = forge_evolution_cycle(parents, generation, population_size, mutation_rate)
        
        print(f"  Created {len(offspring)} offspring strategies")
        
        # Save DNA files
        for strategy in offspring:
            dna_file = output_dir / f"{strategy.name}.thiele"
            with open(dna_file, 'w') as f:
                f.write(strategy.to_thiele())
        
        # Attempt compilation
        compiled_count = 0
        for strategy in offspring:
            result = compile_to_python(strategy, compiled_dir)
            if result:
                compiled_count += 1
        
        print(f"  Successfully compiled: {compiled_count}/{len(offspring)}")
        print()
        
        all_offspring.extend(offspring)
        
        # Add best offspring to parent pool for next generation
        parents.extend(random.sample(offspring, min(3, len(offspring))))
    
    print("=" * 70)
    print("EVOLUTION COMPLETE")
    print("=" * 70)
    print()
    print(f"Total evolved strategies: {len(all_offspring)}")
    print(f"DNA sequences saved to: {output_dir}")
    print(f"Compiled strategies in: {compiled_dir}")
    print()
    print("Next steps:")
    print("  1. Test evolved strategies with run_meta_observatory.sh")
    print("  2. Meta-Cartographer will extract performance metrics")
    print("  3. Arch-Analyzer will judge which strategy is superior")
    print()
    print("The Forge has spoken. Let the Arch-Sphere judge.")
    

def evaluate_strategy_fitness(
    strategy: StrategyDNA,
    objective_genome_path: Path
) -> float:
    """
    Evaluate a strategy's fitness using the objective genome.
    
    This is the Oracle of Judgment - it judges strategies against
    the current objective.
    
    Args:
        strategy: StrategyDNA to evaluate
        objective_genome_path: Path to the objective genome file
    
    Returns:
        Fitness score (0.0 to 1.0)
    """
    # Convert strategy to code string for evaluation
    strategy_code = strategy.to_thiele()
    
    try:
        fitness = evaluate_strategy_with_objective(
            strategy_code,
            strategy.name,
            objective_genome_path
        )
        return fitness
    except Exception as e:
        print(f"  Warning: Failed to evaluate {strategy.name}: {e}")
        return 0.0


def record_to_ascension_ledger(
    strategy: StrategyDNA,
    objective: Dict[str, Any],
    ledger_path: Path
):
    """
    Record a strategy evaluation to the ascension ledger.
    
    The ledger is the machine's long-term memory - every evaluation
    is permanently recorded for the Critic to analyze.
    
    Args:
        strategy: The evolved strategy
        objective: The objective genome it was judged against
        ledger_path: Path to the ascension ledger JSON file
    """
    from datetime import datetime
    
    # Load existing ledger
    try:
        with open(ledger_path, 'r') as f:
            ledger = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        ledger = []
    
    # Create new entry
    entry = {
        "timestamp": datetime.now().isoformat(),
        "strategy_name": strategy.name,
        "strategy_dna": strategy.sequence,
        "generation": strategy.metadata.get('generation', 0),
        "parent_strategies": strategy.metadata.get('parents', [strategy.metadata.get('parent', 'unknown')]),
        "objective_genome": {
            "name": objective.get('name', 'Unknown'),
            "function": objective.get('function', 'Unknown'),
            "parameters": objective.get('parameters', {})
        },
        "fitness_score": strategy.metadata.get('fitness', 0.0),
        "primitive_count": len(strategy.sequence),
        "metadata": strategy.metadata
    }
    
    # Append to ledger
    ledger.append(entry)
    
    # Write back
    with open(ledger_path, 'w') as f:
        json.dump(ledger, f, indent=2)


def run_evolution(num_generations: int = 3, population_size: int = 10, 
                  mutation_rate: float = 0.2, seed: Optional[int] = 42,
                  objective_genome_path: Optional[Path] = None):
    """
    Run the complete evolutionary cycle of The Forge.
    
    The Oracle's function is now generalized: it accepts a candidate strategy
    and an objective genome, and returns a fitness score based on the
    evaluation function specified in the genome.
    
    This is the master function that encapsulates the entirety of the process:
    1. Randomly generate new sight strategies
    2. Evaluate them against the current objective genome
    3. Build hardware to emulate new sight strategies
    4. Prove new sight strategies with the power of math
    5. Document and share discoveries with the world
    6. Repeat
    
    Args:
        num_generations: Number of evolutionary generations to run
        population_size: Number of offspring per generation
        mutation_rate: Probability of mutation (0.0 to 1.0)
        seed: Random seed for reproducibility (None for random)
        objective_genome_path: Path to objective genome (defaults to objectives/current_objective.thiele)
    
    Returns:
        List of all evolved StrategyDNA objects
    """
    if seed is not None:
        random.seed(seed)
    
    # Load objective genome
    if objective_genome_path is None:
        objective_genome_path = Path(__file__).parent.parent / "objectives" / "current_objective.thiele"
    
    print("=" * 70)
    print("THE FORGE: INITIATING PERPETUAL EVOLUTIONARY LOOP")
    print("=" * 70)
    print()
    print("Loading objective genome...")
    
    # Read and display the current objective
    try:
        with open(objective_genome_path, 'r') as f:
            objective = json.load(f)
        print(f"  Objective: {objective.get('name', 'Unknown')}")
        print(f"  Function: {objective.get('function', 'Unknown')}")
        print(f"  Parameters: {objective.get('parameters', {})}")
    except Exception as e:
        print(f"  Error loading objective genome: {e}")
        print("  Using default evaluation")
        objective = {"name": "Default", "function": "evaluate_classification_accuracy"}
    
    print()
    print("This is the Genesis Machine.")
    print("It will now ask the universe its fundamental question:")
    print()
    print('  "What is the best possible way to see?"')
    print()
    print("The machine will answer through evolution.")
    print("=" * 70)
    print()
    
    print("=" * 70)
    print("THE FORGE: INITIATING PERPETUAL EVOLUTIONARY LOOP")
    print("=" * 70)
    print()
    print("This is the Genesis Machine.")
    print("It will now ask the universe its fundamental question:")
    print()
    print('  "What is the best possible way to see?"')
    print()
    print("The machine will answer through evolution.")
    print("=" * 70)
    print()
    
    # Load parent strategies
    strategies_dir = Path(__file__).parent.parent / "strategies"
    parent_files = list(strategies_dir.glob("*.thiele"))
    
    if not parent_files:
        print("ERROR: No parent strategies found in strategies/")
        print("Please ensure the .thiele DNA files exist.")
        return []
    
    print(f"Loading {len(parent_files)} parent strategies...")
    parents = []
    for filepath in parent_files:
        dna = load_thiele_dna(filepath)
        parents.append(dna)
        print(f"  - {dna.name}: {len(dna.sequence)} primitives")
    
    print()
    print("Starting evolutionary synthesis...")
    print()
    
    # Create output directories
    output_dir = Path(__file__).parent.parent / "evolved_strategies"
    output_dir.mkdir(exist_ok=True)
    
    compiled_dir = output_dir / "compiled"
    compiled_dir.mkdir(exist_ok=True)
    
    # Initialize ascension ledger
    ledger_path = Path(__file__).parent.parent / "ascension_ledger.json"
    if not ledger_path.exists():
        with open(ledger_path, 'w') as f:
            json.dump([], f)
    
    all_offspring = []
    
    for generation in range(1, num_generations + 1):
        print(f"Generation {generation}:")
        
        # Evolve new strategies
        offspring = forge_evolution_cycle(parents, generation, population_size, mutation_rate)
        
        print(f"  Created {len(offspring)} offspring strategies")
        
        # Evaluate and record each offspring
        for strategy in offspring:
            # Evaluate fitness using objective genome
            fitness = evaluate_strategy_fitness(strategy, objective_genome_path)
            strategy.metadata['fitness'] = fitness
            
            # Save DNA files
            dna_file = output_dir / f"{strategy.name}.thiele"
            with open(dna_file, 'w') as f:
                f.write(strategy.to_thiele())
            
            # Record in ascension ledger
            record_to_ascension_ledger(strategy, objective, ledger_path)
        
        # Report fitness statistics
        fitnesses = [s.metadata.get('fitness', 0.0) for s in offspring]
        if fitnesses:
            avg_fitness = sum(fitnesses) / len(fitnesses)
            max_fitness = max(fitnesses)
            print(f"  Fitness - Avg: {avg_fitness:.4f}, Max: {max_fitness:.4f}")
        
        # Attempt compilation
        compiled_count = 0
        for strategy in offspring:
            result = compile_to_python(strategy, compiled_dir)
            if result:
                compiled_count += 1
        
        print(f"  Compiled {compiled_count}/{len(offspring)} strategies successfully")
        
        all_offspring.extend(offspring)
        
        # Selection: add best offspring to parent pool for next generation
        sorted_offspring = sorted(offspring, key=lambda s: s.metadata.get('fitness', 0.0), reverse=True)
        parents.extend(sorted_offspring[:min(3, len(sorted_offspring))])
    
    print()
    print("=" * 70)
    print("EVOLUTIONARY CYCLE COMPLETE")
    print("=" * 70)
    print()
    print(f"Total evolved strategies: {len(all_offspring)}")
    print(f"DNA sequences saved to: {output_dir}")
    print(f"Compiled strategies in: {compiled_dir}")
    print()
    print("The machine has answered.")
    print()
    print("Next steps:")
    print("  1. Test evolved strategies with run_meta_observatory.sh")
    print("  2. Meta-Cartographer will extract performance metrics")
    print("  3. Arch-Analyzer will judge which strategy is superior")
    print("  4. Superior strategies become new parents")
    print("  5. Return to step 1 (PERPETUAL LOOP)")
    print()
    print("The Forge has spoken. The wheel turns forever.")
    
    return all_offspring


if __name__ == "__main__":
    main()
