# ThieleUniversalBridge Compilation Bottleneck Analysis

## Date: 2025-11-23

## Problem Statement

ThieleUniversalBridge.v (2876 lines) times out during compilation, hanging for 10+ minutes without completing.

## Current Status

- **Admitted lemmas**: 0 ✓
- **Axioms**: 1 (universal_program_bounded_writes - line 908)
- **Compilation**: HANGS - does not complete even after 600+ seconds

## Bottleneck Identified

### Location
**Line 1891-1930**: `Time Lemma transition_FindRule_Next`

### Evidence
Compilation consistently hangs after printing:
```
Finished transaction in 0. secs (0.u,0.s) (successful)
[bridge] "transition_Fetch_to_FindRule_direct"%string
Finished transaction in 0. secs (0.u,0.s) (successful)
[bridge] "transition_Fetch_to_FindRule"%string
```

This indicates the file compiles successfully up to line ~1476 (`transition_Fetch_to_FindRule`), then attempts to compile `transition_FindRule_Next` (line 1891) and hangs.

### Why This Lemma Hangs

**The Problem**: Despite using helper lemmas and checkpoints, the final proof term generated by this lemma is still too large for Coq's kernel to type-check in reasonable time.

**What we tried**:
1. ✗ `bridge_checkpoint` - Still hangs
2. ✗ `abstract` wrappers - Still hangs  
3. ✗ `Defined` instead of `Qed` - Still hangs
4. ✗ Helper lemmas (`transition_FindRule_Next_step2b`, `transition_FindRule_Next_step3b`) - Still hangs

**Root cause**: The lemma involves:
- Complex state transitions through `run_n`
- Multiple nested `CPU.write_reg` operations
- Calls to helper lemmas that themselves have large proof terms
- The composition creates a proof term that exceeds Coq's practical type-checking limits

## The Axiom Issue

Line 908:
```coq
Axiom universal_program_bounded_writes : forall st instr,
  UTM_Program.decode_instr st instr ->
  forall r, (r < 10)%nat \/ CPU.write_reg r 0 st = st.
```

This axiom states that the universal program only writes to registers 0-9. It's used in line 907-919 to prove `length_run_n_eq_bounded`.

**Status**: This axiom doesn't block compilation - the hang occurs elsewhere.

## Attempted Solutions

### Approach 1: Abstract Wrappers (FAILED)
Wrapped proof steps in `abstract` to seal subterms:
```coq
abstract (apply Nat.eqb_neq; rewrite <- run_n_add; exact Htemp)
```
**Result**: Compilation still hangs at the same location.

### Approach 2: Defined Instead of Qed (FAILED)
Changed from `Qed` to `Defined` to avoid opaque type-checking:
```coq
Defined.
```
**Result**: Compilation still hangs - the issue is during proof term construction, not opacity.

### Approach 3: Remove Checkpoints (FAILED)
Removed `bridge_checkpoint` calls that might be expanding terms:
```coq
(* Removed: bridge_checkpoint ("transition_FindRule_Next"%string). *)
```
**Result**: Compilation still hangs.

## What Actually Works

The file compiles successfully up to and including:
- Line 1476: `transition_Fetch_to_FindRule` (with `Time` and checkpoints) ✓
- Line 1687: `transition_FindRule_Next_step2b` (helper lemma) ✓  
- Line 1854: `transition_FindRule_Next_step3b` (helper lemma) ✓
- Line 1889: `transition_FindRule_Found_step` (helper lemma) ✓

These all use similar patterns but are smaller in scope.

## Possible Solutions (Not Yet Tried)

### Solution 1: Further Decompose transition_FindRule_Next
Break the lemma into even smaller pieces:
- `transition_FindRule_Next_exists` - prove the existential
- `transition_FindRule_Next_eq` - prove the equality
- `transition_FindRule_Next_pc` - prove PC property
- `transition_FindRule_Next_addr` - prove ADDR property

Then combine them in a thin wrapper lemma.

### Solution 2: Use Proof by Reflection
Convert symbolic execution to computational proof:
- Define a decision procedure in Gallina
- Use `vm_compute` or `native_compute` to evaluate
- Minimal proof term, just the computation result

### Solution 3: Aggressive Opaque Declarations
Make more definitions opaque earlier in the file:
```coq
Global Opaque run_n.
Global Opaque CPU.step.
Global Opaque CPU.write_reg.
```

This prevents unfolding during proof term construction.

### Solution 4: Split File
Move transition_FindRule_Next and later lemmas to a separate file that imports the earlier definitions as opaque.

### Solution 5: Curry the Lemma
Instead of one lemma with many hypotheses, create a sequence:
```coq
Lemma transition_FindRule_Next_1 : ... -> ....
Lemma transition_FindRule_Next_2 : transition_FindRule_Next_1 -> ... -> ....
Lemma transition_FindRule_Next : transition_FindRule_Next_2 -> ....
```

This distributes the proof term across multiple smaller lemmas.

## Recommendation

**Immediate**: Try Solution 1 (further decomposition) - break transition_FindRule_Next into 4-5 micro-lemmas, each proving a single conjunct.

**If that fails**: Try Solution 3 (aggressive opacity) combined with Solution 1.

**Last resort**: Solution 4 (file splitting) or Solution 2 (proof by reflection), both require significant refactoring.

## Time Estimate

- Solution 1: 2-3 hours
- Solution 3: 1-2 hours
- Solution 1 + 3: 3-4 hours
- Solution 2: 6-8 hours (requires reflection infrastructure)
- Solution 4: 4-6 hours (requires proper module system)

## Conclusion

The file has 0 admits but DOES NOT COMPILE due to proof term explosion in `transition_FindRule_Next`. The hang occurs during type-checking, not tactic execution. Further decomposition or opacity is required to make this compile.

**Status**: Work in progress - file is incomplete until this compilation issue is resolved.
