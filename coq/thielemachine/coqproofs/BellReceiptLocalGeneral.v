From Coq Require Import List Bool ZArith QArith Qring Lia.
Import ListNotations.
Open Scope Q_scope.

From ThieleMachine Require Import BellInequality.
From ThieleMachine Require Import QHelpers.
From ThieleMachine Require Import BellReceiptSemantics.

(** General local-fragment CHSH bound over decoded Trial lists.

    This upgrades the earlier “fixed 4-trial program” theorem to an arbitrary
    multiset of trials, assuming:

    - determinism + locality: outcomes are generated by a fixed pair of response
      tables (Alice depends only on x; Bob depends only on y)
    - coverage: each (x,y) setting occurs at least once, so the empirical
      conditional distributions are defined (no 0/0).

    Under these assumptions, the receipt-computed [chsh_of_trials] agrees with
    the deterministic strategy’s CHSH value, hence |S| ≤ 2.
*)

Definition local_trial (rA rB : Response) (t : Trial) : Prop :=
  t.(t_a) = resp_eval rA t.(t_x) /\
  t.(t_b) = resp_eval rB t.(t_y).

Definition local_trials (rA rB : Response) (ts : list Trial) : Prop :=
  Forall (local_trial rA rB) ts.

Definition covers_settings (ts : list Trial) : Prop :=
  forall x y, (0 < total_for_setting x y ts)%nat.

Lemma bit_eqb_refl : forall b, bit_eqb b b = true.
Proof. destruct b; reflexivity. Qed.

Lemma bit_eqb_eq : forall x y, bit_eqb x y = true -> x = y.
Proof. destruct x, y; simpl; auto; discriminate. Qed.

Lemma B0_neq_B1 : B0 <> B1.
Proof. intro H; inversion H. Qed.

Lemma B1_neq_B0 : B1 <> B0.
Proof. intro H; inversion H. Qed.

Lemma trial_eqb_refl : forall t, trial_eqb t t = true.
Proof.
  intros [x y a b]. unfold trial_eqb.
  rewrite bit_eqb_refl, bit_eqb_refl, bit_eqb_refl, bit_eqb_refl.
  reflexivity.
Qed.

Lemma trial_eqb_eq : forall t u, trial_eqb t u = true -> t = u.
Proof.
  intros [x y a b] [x' y' a' b'] H.
  destruct x, y, a, b, x', y', a', b'; simpl in H; try discriminate; reflexivity.
Qed.

Lemma count_trial_zero_if_no_equal :
  forall t ts,
    (forall u, In u ts -> u <> t) ->
    count_trial t ts = 0%nat.
Proof.
  intros t ts Hno.
  induction ts as [|u tl IH]; simpl; auto.
  destruct (trial_eqb t u) eqn:Heq.
  - exfalso.
    specialize (Hno u (or_introl eq_refl)).
    apply trial_eqb_eq in Heq.
    subst. contradiction.
  - apply IH.
    intros u' Hin.
    apply Hno.
    right. exact Hin.
Qed.

Lemma count_trial_wrong_outcome_zero :
  forall ts rA rB x y a b,
    local_trials rA rB ts ->
    (a <> resp_eval rA x \/ b <> resp_eval rB y) ->
    count_trial {| t_x := x; t_y := y; t_a := a; t_b := b |} ts = 0%nat.
Proof.
  intros ts rA rB x y a b Hlocal Hneq.
  unfold local_trials in Hlocal.
  apply count_trial_zero_if_no_equal.
  intros u Hin Hu.
  pose proof (proj1 (@Forall_forall Trial (local_trial rA rB) ts) Hlocal)
    as Hlocal'.
  specialize (Hlocal' u Hin) as [HuA HuB].
  rewrite Hu in HuA, HuB.
  simpl in HuA, HuB.
  destruct Hneq as [Hna|Hnb].
  - apply Hna. exact HuA.
  - apply Hnb. exact HuB.
Qed.

Lemma total_for_setting_deterministic :
  forall ts rA rB x y,
    local_trials rA rB ts ->
    total_for_setting x y ts =
      count_trial {| t_x := x; t_y := y;
                     t_a := resp_eval rA x; t_b := resp_eval rB y |} ts.
Proof.
  intros ts rA rB x y Hlocal.
  unfold total_for_setting.
  destruct (resp_eval rA x) as [|] eqn:Ha;
  destruct (resp_eval rB y) as [|] eqn:Hb;
  (* four cases: which of the four outcomes is the “right” one *)
  simpl.
  - (* a=B0, b=B0 *)
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B0 B1 Hlocal)
      by (right; rewrite Hb; exact B1_neq_B0).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B1 B0 Hlocal)
      by (left; rewrite Ha; exact B1_neq_B0).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B1 B1 Hlocal)
      by (left; rewrite Ha; exact B1_neq_B0).
    simpl.
    repeat rewrite Nat.add_0_r.
    repeat rewrite Nat.add_0_l.
    reflexivity.
  - (* a=B0, b=B1 *)
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B0 B0 Hlocal)
      by (right; rewrite Hb; exact B0_neq_B1).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B1 B0 Hlocal)
      by (left; rewrite Ha; exact B1_neq_B0).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B1 B1 Hlocal)
      by (left; rewrite Ha; exact B1_neq_B0).
    simpl.
    repeat rewrite Nat.add_0_r.
    repeat rewrite Nat.add_0_l.
    reflexivity.
  - (* a=B1, b=B0 *)
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B0 B0 Hlocal)
      by (left; rewrite Ha; exact B0_neq_B1).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B0 B1 Hlocal)
      by (left; rewrite Ha; exact B0_neq_B1).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B1 B1 Hlocal)
      by (right; rewrite Hb; exact B1_neq_B0).
    simpl.
    repeat rewrite Nat.add_0_r.
    repeat rewrite Nat.add_0_l.
    reflexivity.
  - (* a=B1, b=B1 *)
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B0 B0 Hlocal)
      by (left; rewrite Ha; exact B0_neq_B1).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B0 B1 Hlocal)
      by (left; rewrite Ha; exact B0_neq_B1).
    rewrite (count_trial_wrong_outcome_zero ts rA rB x y B1 B0 Hlocal)
      by (right; rewrite Hb; exact B0_neq_B1).
    simpl.
    repeat rewrite Nat.add_0_r.
    repeat rewrite Nat.add_0_l.
    reflexivity.
Qed.

Lemma Q_of_succ_over_pos_of_succ :
  forall n,
    (Z.of_nat (Datatypes.S n) # Pos.of_succ_nat n) == 1#1.
Proof.
  intro n.
  unfold Qeq. simpl.
  rewrite Pos.mul_1_r.
  reflexivity.
Qed.

Lemma p_from_trials_deterministic_one :
  forall ts rA rB x y,
    local_trials rA rB ts ->
    (0 < total_for_setting x y ts)%nat ->
    p_from_trials ts (resp_eval rA x) (resp_eval rB y) x y == 1#1.
Proof.
  intros ts rA rB x y Hlocal Hcov.
  unfold p_from_trials.
  rewrite <- (total_for_setting_deterministic ts rA rB x y Hlocal).
  destruct (total_for_setting x y ts) as [|den'] eqn:Hden; [lia|].
  (* in the succ case, numerator equals denominator *)
  cbn.
  apply Q_of_succ_over_pos_of_succ.
Qed.

Lemma p_from_trials_deterministic_zero :
  forall ts rA rB x y a b,
    local_trials rA rB ts ->
    (0 < total_for_setting x y ts)%nat ->
    (a <> resp_eval rA x \/ b <> resp_eval rB y) ->
    p_from_trials ts a b x y == 0#1.
Proof.
  intros ts rA rB x y a b Hlocal Hcov Hneq.
  unfold p_from_trials.
  assert (Hcount : count_trial {| t_x := x; t_y := y; t_a := a; t_b := b |} ts = 0%nat)
    by (apply count_trial_wrong_outcome_zero with (rA := rA) (rB := rB); assumption).
  rewrite Hcount.
  destruct (total_for_setting x y ts) as [|den'] eqn:Hden; [lia|].
  cbn.
  reflexivity.
Qed.

Lemma correlator_deterministic :
  forall ts rA rB x y,
    local_trials rA rB ts ->
    (0 < total_for_setting x y ts)%nat ->
    (sum_bit2 (fun a b => (inject_Z ((sgn a * sgn b)%Z))
                        * (raw_box_of_trials ts a b x y)))
      == inject_Z ((sgn (resp_eval rA x) * sgn (resp_eval rB y))%Z).
Proof.
  intros ts rA rB x y Hlocal Hcov.
  unfold raw_box_of_trials.
  rewrite sum_bit2_unfold.
  (* case split on the deterministic outcome bits *)
  destruct (resp_eval rA x) as [|] eqn:Ha;
  destruct (resp_eval rB y) as [|] eqn:Hb;
  simpl.
  - (* a=B0, b=B0 *)
    (* only (B0,B0) has probability 1; the others are 0 *)
    pose proof (p_from_trials_deterministic_one ts rA rB x y Hlocal Hcov) as Hone.
    rewrite Ha, Hb in Hone.
    setoid_rewrite Hone.
    assert (Hneq01 : B1 <> resp_eval rB y) by (rewrite Hb; exact B1_neq_B0).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B0 B1 Hlocal Hcov (or_intror Hneq01))
      as Hz01.
    setoid_rewrite Hz01.
    assert (HneqA : B1 <> resp_eval rA x) by (rewrite Ha; exact B1_neq_B0).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B1 B0 Hlocal Hcov (or_introl HneqA))
      as Hz10.
    setoid_rewrite Hz10.
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B1 B1 Hlocal Hcov (or_introl HneqA))
      as Hz11.
    setoid_rewrite Hz11.
    ring.
  - (* a=B0, b=B1 *)
    assert (Hneq00 : B0 <> resp_eval rB y) by (rewrite Hb; exact B0_neq_B1).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B0 B0 Hlocal Hcov (or_intror Hneq00))
      as Hz00.
    setoid_rewrite Hz00.
    pose proof (p_from_trials_deterministic_one ts rA rB x y Hlocal Hcov) as Hone.
    rewrite Ha, Hb in Hone.
    setoid_rewrite Hone.
    assert (HneqA : B1 <> resp_eval rA x) by (rewrite Ha; exact B1_neq_B0).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B1 B0 Hlocal Hcov (or_introl HneqA))
      as Hz10.
    setoid_rewrite Hz10.
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B1 B1 Hlocal Hcov (or_introl HneqA))
      as Hz11.
    setoid_rewrite Hz11.
    ring.
  - (* a=B1, b=B0 *)
    assert (Hneq00 : B0 <> resp_eval rA x) by (rewrite Ha; exact B0_neq_B1).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B0 B0 Hlocal Hcov (or_introl Hneq00))
      as Hz00.
    setoid_rewrite Hz00.
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B0 B1 Hlocal Hcov (or_introl Hneq00))
      as Hz01.
    setoid_rewrite Hz01.
    pose proof (p_from_trials_deterministic_one ts rA rB x y Hlocal Hcov) as Hone.
    rewrite Ha, Hb in Hone.
    setoid_rewrite Hone.
    assert (Hneq11 : B1 <> resp_eval rB y) by (rewrite Hb; exact B1_neq_B0).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B1 B1 Hlocal Hcov (or_intror Hneq11))
      as Hz11.
    setoid_rewrite Hz11.
    ring.
  - (* a=B1, b=B1 *)
    assert (Hneq00 : B0 <> resp_eval rA x) by (rewrite Ha; exact B0_neq_B1).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B0 B0 Hlocal Hcov (or_introl Hneq00))
      as Hz00.
    setoid_rewrite Hz00.
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B0 B1 Hlocal Hcov (or_introl Hneq00))
      as Hz01.
    setoid_rewrite Hz01.
    assert (Hneq10 : B0 <> resp_eval rB y) by (rewrite Hb; exact B0_neq_B1).
    pose proof
      (p_from_trials_deterministic_zero ts rA rB x y B1 B0 Hlocal Hcov (or_intror Hneq10))
      as Hz10.
    setoid_rewrite Hz10.
    pose proof (p_from_trials_deterministic_one ts rA rB x y Hlocal Hcov) as Hone.
    rewrite Ha, Hb in Hone.
    setoid_rewrite Hone.
    ring.
Qed.

Theorem local_trials_CHSH_bound :
  forall ts rA rB,
    local_trials rA rB ts ->
    covers_settings ts ->
    Qabs (chsh_of_trials ts) <= 2#1.
Proof.
  intros ts rA rB Hlocal Hcov.
  (* Deterministic correlators for each setting. *)
  pose proof (correlator_deterministic ts rA rB B1 B1 Hlocal (Hcov B1 B1)) as H11.
  pose proof (correlator_deterministic ts rA rB B1 B0 Hlocal (Hcov B1 B0)) as H10.
  pose proof (correlator_deterministic ts rA rB B0 B1 Hlocal (Hcov B0 B1)) as H01.
  pose proof (correlator_deterministic ts rA rB B0 B0 Hlocal (Hcov B0 B0)) as H00.

  set (Sdet :=
         (inject_Z (sgn (resp_eval rA B1) * sgn (resp_eval rB B1))%Z) +
          inject_Z (sgn (resp_eval rA B1) * sgn (resp_eval rB B0))%Z +
          inject_Z (sgn (resp_eval rA B0) * sgn (resp_eval rB B1))%Z -
          inject_Z (sgn (resp_eval rA B0) * sgn (resp_eval rB B0))%Z).

  assert (Hchsh : chsh_of_trials ts == Sdet).
  {
    unfold chsh_of_trials.
    cbn.
    setoid_replace
      (sum_bit2
         (fun a b : Bit =>
          inject_Z (sgn a * sgn b) * raw_box_of_trials ts a b B1 B1))
      with (inject_Z (sgn (resp_eval rA B1) * sgn (resp_eval rB B1))%Z)
      by exact H11.
    setoid_replace
      (sum_bit2
         (fun a b : Bit =>
          inject_Z (sgn a * sgn b) * raw_box_of_trials ts a b B1 B0))
      with (inject_Z (sgn (resp_eval rA B1) * sgn (resp_eval rB B0))%Z)
      by exact H10.
    setoid_replace
      (sum_bit2
         (fun a b : Bit =>
          inject_Z (sgn a * sgn b) * raw_box_of_trials ts a b B0 B1))
      with (inject_Z (sgn (resp_eval rA B0) * sgn (resp_eval rB B1))%Z)
      by exact H01.
    setoid_replace
      (sum_bit2
         (fun a b : Bit =>
          inject_Z (sgn a * sgn b) * raw_box_of_trials ts a b B0 B0))
      with (inject_Z (sgn (resp_eval rA B0) * sgn (resp_eval rB B0))%Z)
      by exact H00.
    unfold Sdet.
    ring.
  }

  (* Transport the Qabs target to the deterministic expression. *)
  pose proof (Qabs_proper_local (chsh_of_trials ts) Sdet Hchsh) as Habs.

  assert (Hdet_le : Qabs Sdet <= 2#1).
  {
    destruct rA as [a0 a1]; destruct a0, a1;
    destruct rB as [b0 b1]; destruct b0, b1;
    vm_compute.
    all: intro H; discriminate.
  }

  (* Transfer the bound back to the receipt-computed CHSH. *)
  pose proof (Qeq_sym (Qabs (chsh_of_trials ts)) (Qabs Sdet) Habs) as Habs'.
  exact (Qeq_le_compat (Qabs Sdet) (Qabs (chsh_of_trials ts)) (2#1) Habs' Hdet_le).
Qed.
