# DARPA/CISA-Style Forensic Assessment of The Thiele Machine Repository

## Executive Summary
- **Artifact status.** The automated deterministic key health check in `ensure_kernel_keys` now refreshes the bundled Ed25519 keypair whenever it is missing or corrupt, so the orchestrators (`attempt.py`, `demonstrate_isomorphism.py`) and the geometric demos run to completion on the bundled datasets, emitting signed receipts and summaries. The historical subsumption proof has been archived; `coq/verify_subsumption.sh` now points reviewers to `archive/research/incomplete_subsumption_proof/` instead of attempting to rebuild `ThieleUniversal.v`.【F:thielecpu/receipts.py†L72-L144】【dcbc1a†L1-L200】【fabd20†L1-L34】【e1622f†L1-L120】【F:archive/research/incomplete_subsumption_proof/README.md†L1-L10】
- **What the Thiele Machine is.** At its core, the Thiele CPU maintains a partition graph, μ-accounting registers, and certificate metadata; the VM enforces a strict AST whitelist around `PYEXEC` payloads, assembles receipts for every instruction, and seals transcripts with the deterministic Ed25519 key.【F:thielecpu/state.py†L31-L121】【F:thielecpu/vm.py†L31-L200】【F:thielecpu/receipts.py†L72-L126】
- **Graph-colouring laboratory.** `scripts/graph_coloring_demo.py` now stages a three-act experiment across multiple cascade graphs. Each run produces per-act receipts (for example `graph_demo_output/triadic_cascade/act_*`), per-graph analyses such as `graph_demo_output/triadic_cascade/analysis_report.json`, and a suite-level scaling study (`graph_demo_output/scaling_summary.json`, `scaling_plot.png`) that tracks log₁₀(candidate checks) as the node count grows. Act III spends μ-bits on anchor claims plus congruence feasibility queries, so the transcripts document constant-factor collapses rather than asymptotic breakthroughs.【F:scripts/graph_coloring_demo.py†L1-L330】【F:graph_demo_output/triadic_cascade/analysis_report.json†L1-L74】【F:graph_demo_output/scaling_summary.json†L1-L33】
- **Toy Thiele microcosm.** `coq/sandboxes/ToyThieleMachine.v` instantiates an eight-cell universe where a classical write-only interpreter and a Thiele interpreter execute the same two-instruction program. Coq mechanises that the Turing model cannot create the target `[0,0,0,0,1,1,1,1]` tape, whereas the Thiele interpreter spends one μ-bit to enforce `ClaimLeftZero` and succeeds, supplying a minimal existence proof of non-Turing behaviour.【F:coq/sandboxes/ToyThieleMachine.v†L1-L118】
- **Verified graph solver.** `coq/sandboxes/VerifiedGraphSolver.v` formalises the nine-node `triadic_cascade` instance alongside two solvers: a classical backtracker that needs 18 branch attempts and a Thiele solver that pays 23 μ-bits for anchor claims plus feasibility queries to colour the graph without brute force. Theorems `classical_is_slow` and `thiele_is_fast` mirror the empirical experiment inside Coq.【F:coq/sandboxes/VerifiedGraphSolver.v†L1-L204】
- **Synthesis trap verdict.** Yosys successfully maps the brute-force Verilog (`classical_solver.v`) to a 228-cell netlist with 267 wire bits, while the Thiele residue-mask solver collapses to five cells across 106 wire bits. Both logs are now published under `hardware/synthesis_trap/`, and the driver script prints the archived verdicts whenever Yosys is unavailable, keeping the oracle’s evidence accessible in tool-limited environments.【F:hardware/synthesis_trap/classical_solver.log†L1-L40】【F:hardware/synthesis_trap/thiele_solver.log†L1-L32】【F:scripts/run_the_synthesis.sh†L1-L40】
- **Receipts-to-Coq bridge.** `scripts/prove_it_all.sh` regenerates the graph-colouring receipts, translates the Act III reasoning log into `coq/sandboxes/GeneratedProof.v`, and compiles it alongside `Sandbox.VerifiedGraphSolver`. The resulting theorem `python_receipt_sound` ties the live Python experiment to the Coq microcosm, delivering an auditable end-to-end bridge.【F:scripts/prove_it_all.sh†L1-L24】【F:coq/sandboxes/GeneratedProof.v†L1-L66】
- **Residual risk.** The repository still ships the deterministic signing key and high-fidelity transcripts of hypothetical cryptanalytic workflows. Although the current focus is the graph-colouring laboratory, the archived RSA scripts remain in-tree and could be repurposed without supervision. Controlled distribution, key rotation, and export review remain essential before broad release.【F:README.md†L1-L120】【F:SECURITY.md†L1-L3】

## Methodology
1. **Environment preparation.** Following repository guidance, we installed the Coq toolchain via `apt-get install -y coq` and performed `pip install -e .`. We then deleted `kernel_secret.key`/`kernel_public.key` and confirmed that the orchestrators regenerated the deterministic Ed25519 signing keypair automatically via `ensure_kernel_keys` on first run.【734b7c†L1-L21】【F:README.md†L37-L74】【F:thielecpu/receipts.py†L72-L144】
2. **Canonical runs.** We executed `python attempt.py`, `python demonstrate_isomorphism.py --act-vi offline --data-source planck`, `python scripts/graph_coloring_demo.py`, `python scripts/challenge.py verify receipts`, `bash scripts/prove_it_all.sh`, `bash scripts/run_the_synthesis.sh`, and `./scripts/verify_truth.sh examples/tsirelson_step_receipts.json`. Invoking `./coq/verify_subsumption.sh` now emits the archival notice for the old universal proof instead of attempting a rebuild.【0959ec†L1-L17】【fabd20†L1-L34】【09cd12†L1-L12】【e1622f†L1-L120】【dd068b†L1-L200】【31e61a†L1-L1】【F:coq/verify_subsumption.sh†L1-L20】
3. **Artifact inspection.** Generated logs, receipts, and summaries were reviewed alongside source modules for the VM, CPU state, assembler, key management, and data pipeline to corroborate the claims.【F:thielecpu/vm.py†L31-L523】【F:thielecpu/state.py†L31-L121】【F:thielecpu/assemble.py†L16-L49】【F:thielecpu/receipts.py†L72-L211】

## System Component Inventory
### Orchestrators and Ledgers
- **`attempt.py`.** The universal thesis driver records every print statement to `terminal_output.md`, seeds NumPy/Z3 deterministically, and invokes Thiele CPU helpers to regenerate proofs of TM/VN subsumption, paradox derivations, MDL ledgers, Tseitin expanders, and the Ouroboros seal.【F:attempt.py†L26-L199】【0959ec†L1-L17】 Its seed discipline and transcript hashing produce a JSON summary that captures source hashes, runtime platform, and the 123456789 global seed, allowing auditors to diff runs.【0959ec†L5-L17】
- **`demonstrate_isomorphism.py`.** Structured as a six-act dissertation, the script re-derives mathematical constants, enumerates all classical CHSH strategies with SMT proofs, constructs the Tsirelson witness, regenerates the canonical receipts, and orchestrates Act VI using the committed Planck FITS sample. It raises fatal errors if Planck data are missing or corrupt, ensuring auditors see explicit failure modes instead of silent fallbacks.【F:demonstrate_isomorphism.py†L460-L545】【F:demonstrate_isomorphism.py†L1620-L1674】

### Thiele CPU and VM Stack
- **Partition state (`thielecpu/state.py`).** The CPU state tracks μ-operational and μ-information counters, a dynamically growing partition graph, CSR registers (status, certificate address), and axioms per module. Operations such as `pnew`, `psplit`, and `pmerge` maintain invariants that bound module size by a polynomial in the global region size, reflecting the theoretical partition constraints described in the thesis.【F:thielecpu/state.py†L31-L121】
- **Assembler (`thielecpu/assemble.py`).** The assembler parses textual programs, resolves relative paths for `PYEXEC` payloads, and normalises instructions before execution, matching the pipeline used by the RSA demo and orchestrators.【F:thielecpu/assemble.py†L16-L49】
- **Sandboxed VM (`thielecpu/vm.py`).** The VM whitelists AST node types, builtins, module attributes, and method calls, replacing `__import__` to prevent arbitrary module loading. During execution it records each instruction, pre/post witness state, μ deltas, and event payloads, emitting signed receipts via the Ed25519 pipeline. The sandbox ensures `PYEXEC` scripts cannot escape the curated environment without hitting a `SecurityError` exception.【F:thielecpu/vm.py†L31-L200】【F:thielecpu/vm.py†L513-L556】

### Receipt and Verification Pipeline
- **Signing and verification (`thielecpu/receipts.py`).** The pipeline resolves signing/verification key paths (defaulting to `kernel_secret.key` and `kernel_public.key`), canonicalises payloads, and uses PyNaCl to sign each step. `StepReceipt.assemble` computes SHA-256 hashes for pre/post states, attaches μ deltas, and produces JSON-compatible structures consumed by both the verification harness and Coq bridge.【F:thielecpu/receipts.py†L72-L211】
- **Harness (`scripts/verify_truth.sh`).** The shell wrapper compiles the Coq libraries, rejects any signature mismatch, and synthesises `tmp_verify_truth.v` containing the recorded program, states, and receipts for replay inside the ThieleMachine Coq development. Successful runs report “Coq proof obligations discharged,” confirming the bridge from receipts to formal proofs is intact.【F:scripts/verify_truth.sh†L1-L200】【31e61a†L1-L1】
- **Deterministic key management.** `scripts/generate_kernel_keys.py` exposes `--deterministic-test-key`, deriving a fixed Ed25519 seed so auditors can reproduce the expected keypair. The private key must be regenerated if it is missing or truncated—receipt signing fails unless the binary file is exactly 32 bytes.【F:scripts/generate_kernel_keys.py†L16-L86】【89b8e7†L1-L6】

### Data Pipeline and Operation Cosmic Witness
- **Planck dataset.** `data/generate_planck_sample.py` deterministically converts the committed `cmb_sample.csv` into `planck_sample.fits`, ensuring Act VI operates on a non-empty FITS file in every checkout.【F:data/generate_planck_sample.py†L6-L25】
- **Runtime guards.** Act VI raises fatal errors if neither CSV nor FITS samples exist, if FITS dependencies (healpy/astropy) are missing when required, or if the FITS payload is unreadable. Successful runs record the data origin (`healpix:planck_sample.fits`) and the extracted feature vector before invoking Z3 robustness proofs.【F:demonstrate_isomorphism.py†L1620-L1694】

### Graph Colouring Demonstration
- **Program synthesis.** The demo prepares three pipelines per graph: Act I performs blind enumeration when the node count allows, Act II applies degree-ordered backtracking, and Act III replays a reasoning log where the VM spends μ-bits on anchor claims plus congruence feasibility queries for each remaining vertex. The host oracle records admissible colour sets so auditors can see which partitions collapse.【F:scripts/graph_coloring_demo.py†L64-L330】
- **Receipts and summaries.** Outputs land under `graph_demo_output/<graph>/act_*`, capturing summary JSON and per-act logs. Act III adds `reasoning_summary.json`, documenting oracle queries, forced assignments, and the final targeted search count (zero in the reference runs). The generated bridge `coq/sandboxes/GeneratedProof.v` is produced by `scripts/prove_it_all.sh` from the triadic receipts.【F:graph_demo_output/triadic_cascade/act_iii/reasoning_summary.json†L1-L40】【F:coq/sandboxes/GeneratedProof.v†L1-L66】
- **Aggregate analysis.** `graph_demo_output/triadic_cascade/analysis_report.json` captures the canonical nine-node collapse (3,786 blind assignments vs. zero residual search after spending 23 μ-bits), while `graph_demo_output/scaling_summary.json` and `scaling_plot.png` summarise the Act II and Act III workloads across larger cascades.【F:graph_demo_output/triadic_cascade/analysis_report.json†L1-L48】【F:graph_demo_output/scaling_summary.json†L1-L24】

## Empirical Replay Findings
1. **`python attempt.py`.** The run completes all thesis acts, regenerates UNSAT witnesses, and emits a JSON summary containing source/transcript hashes and runtime metadata, demonstrating that the universal orchestrator is reproducible under the deterministic seed.【0959ec†L1-L17】
2. **`python demonstrate_isomorphism.py --act-vi offline --data-source planck`.** With the committed FITS file present, the script completes Acts I–VI without invoking legacy fallbacks, producing refreshed receipts and the Act VI artifact manifest in `artifacts/`. (The script is intentionally quiet on stdout; auditors inspect `BELL_INEQUALITY_VERIFIED_RESULTS.md` and `artifacts/` for results.)【F:demonstrate_isomorphism.py†L1330-L1398】【F:artifacts/MANIFEST.sha256†L1-L1】
3. **`python scripts/graph_coloring_demo.py`.** The run produced receipts for all three acts across the cascade suite: the triadic instance records 3,786 blind assignments in Act I, 18 heuristic branches in Act II, and an oracle-guided Act III that spent 23 μ-bits on anchor claims plus congruence feasibility queries. Larger cascades skip the infeasible blind search but still document Act II workloads and Act III μ-spend, populating `graph_demo_output/<graph>/act_*`, `graph_demo_output/triadic_cascade/analysis_report.json`, and `graph_demo_output/scaling_summary.json`.【09cd12†L1-L12】【F:graph_demo_output/triadic_cascade/act_iii/reasoning_summary.json†L1-L40】【F:graph_demo_output/scaling_summary.json†L1-L33】
4. **`bash scripts/prove_it_all.sh`.** The integrated pipeline regenerated the receipts, translated the Act III reasoning log into `coq/sandboxes/GeneratedProof.v`, compiled it alongside `Sandbox.VerifiedGraphSolver`, and reported success, demonstrating the empirical ↔ formal bridge.【F:scripts/prove_it_all.sh†L1-L24】【F:coq/sandboxes/GeneratedProof.v†L1-L66】
5. **`bash scripts/run_the_synthesis.sh`.** Yosys completed both builds, emitting `classical_solver.log/json` (228 cells, 267 wire bits) and `thiele_solver.log/json` (5 cells, 106 wire bits). The logs include the tool’s own optimisation trace and final statistics, demonstrating the oracle’s accounting for each architecture; the script also falls back to the archived logs if Yosys is unavailable.【dd068b†L1-L200】【F:hardware/synthesis_trap/classical_solver.log†L1-L40】【F:hardware/synthesis_trap/thiele_solver.log†L1-L32】【F:scripts/run_the_synthesis.sh†L1-L40】
6. **`python scripts/challenge.py verify receipts`.** The verification harness recognises all canonical receipts (Bell/Tsirelson, benchmark ledger) and reports total μ = 0, confirming the signed receipts match the deterministic keypair.【6b2952†L1-L6】
7. **`./scripts/verify_truth.sh examples/tsirelson_step_receipts.json`.** After compiling the Coq libraries, the bridge script discharges the proof obligations, demonstrating the Coq layer remains synchronised with the VM receipts.【31e61a†L1-L1】
8. **`./coq/verify_subsumption.sh`.** The script now prints an archival notice directing auditors to `archive/research/incomplete_subsumption_proof/` for the historical subsumption attempt.【F:coq/verify_subsumption.sh†L1-L20】

## Claims vs. Evidence
- **Bell thesis reproduction.** SMT-backed enumeration of classical strategies and the Coq replay of `examples/tsirelson_step_receipts.json` substantiate the Act V/Vl claims when the deterministic keypair is present.【F:demonstrate_isomorphism.py†L460-L545】【31e61a†L1-L1】
- **Partition computation model.** The CPU state invariants, VM sandbox, and receipt assembly provide concrete evidence that the Thiele Machine enforces partition-aware computation with auditable μ-accounting.【F:thielecpu/state.py†L31-L121】【F:thielecpu/vm.py†L31-L200】【F:thielecpu/receipts.py†L129-L211】
- **Graph-colouring narrative.** The refreshed suite’s receipts, per-graph analyses, and `scaling_summary.json` expose each act’s workload alongside the μ-bit ledger: the triadic cascade records 3,786 blind assignments versus zero residual search after spending 23 μ-bits, and larger cascades show Act II growth while Act III remains search-free at higher μ costs. The Coq bridge (`GeneratedProof.v`) mirrors the triadic run, reinforcing that the evidence supports constant-factor collapses of the search frontier rather than asymptotic shortcuts through NP-complete terrain.【F:README.md†L1-L120】【F:scripts/graph_coloring_demo.py†L64-L330】【F:graph_demo_output/triadic_cascade/analysis_report.json†L1-L74】【F:graph_demo_output/scaling_summary.json†L1-L33】【F:coq/sandboxes/GeneratedProof.v†L1-L66】
- **Synthesis trap evidence.** The paired Yosys logs quantify the structural distinction: the classical solver consumes 228 cells with sequential storage, whereas the Thiele solver’s five-cell netlist reflects a pre-propagated reasoning lattice. The oracle’s own accounting demonstrates that the geometric logic manifests as a radically smaller hardware footprint rather than a failed build.【F:hardware/synthesis_trap/classical_solver.log†L1-L40】【F:hardware/synthesis_trap/thiele_solver.log†L1-L32】

## Risk and Threat Analysis
- **Key exposure.** Shipping `kernel_secret.key` is essential for reproducibility but creates an information hazard: adversaries can forge receipts indistinguishable from the canonical transcripts. Release bundles must either rotate keys post-audit or gate access to the secret key when distribution moves beyond controlled audiences.【F:scripts/generate_kernel_keys.py†L16-L63】【F:README.md†L9-L37】
- **Supply-chain integrity.** Although `requirements.txt` pins dependency versions, auditors should mirror and checksum wheels before release to mitigate poisoned package attacks targeting PyNaCl, Z3, or PySAT, which underpin receipts, SMT proofs, and VM sandboxing.【F:requirements.txt†L1-L164】【F:thielecpu/vm.py†L24-L200】
- **Sandbox escape surface.** The VM allows `open` and JSON access inside `PYEXEC`. While AST filters and safe builtins mitigate risk, red-team review should attempt filesystem and network exfiltration to confirm `SecurityError` triggers appropriately.【F:thielecpu/vm.py†L31-L200】
- **Information hazard (simulated cryptanalysis).** Even though the flagship experiment now centres on graph colouring, the repository still documents hypothetical cryptanalytic workflows with signed transcripts. Coordinated disclosure with export-control authorities is advised before publishing beyond trusted partners.【F:README.md†L1-L120】【F:SECURITY.md†L1-L3】

## Governance and Recommendations
1. **Controlled distribution.** Maintain the deterministic keypair for audit reproducibility but prepare a post-audit rotation plan and secure channel for delivering production keys to authorised stakeholders.【F:scripts/generate_kernel_keys.py†L16-L86】【F:README.md†L9-L37】
2. **Receipt monitoring.** Treat the new graph-colouring receipts (`graph_demo_output/`) and archived RSA transcripts as sensitive artifacts; monitor derivative forks that redistribute or modify them without oversight.【e1622f†L1-L120】【F:graph_demo_output/triadic_cascade/analysis_report.json†L1-L48】
3. **Extended Coq review.** Although `verify_truth.sh` and `scripts/prove_it_all.sh` succeed, commission an external team to audit the broader Coq tree (`coq/thielemachine/`, sandbox modules, and the archived `archive/research/incomplete_subsumption_proof/`) for hidden admits or axioms that could undermine claimed separations.【F:scripts/verify_truth.sh†L1-L200】【F:coq/sandboxes/GeneratedProof.v†L1-L66】
4. **Security contact posture.** The new SECURITY.md provides a public reporting channel; ensure the team actively triages confidential advisories and coordinates with relevant agencies before acknowledging high-impact findings.【F:SECURITY.md†L1-L3】
5. **Ongoing data stewardship.** Keep `data/planck_sample.fits` and `cmb_sample.csv` under version control with documented provenance so auditors can trace the offline dataset lineage without ambiguity.【F:data/generate_planck_sample.py†L6-L25】

## Conclusion
The hardened repository now operates as a deterministic artifact for the Python orchestrators: auditors can clone, install, regenerate the deterministic key, run the thesis walkthrough, replay the multi-graph colouring laboratory, and inspect every signed receipt. The empirical ↔ formal bridge (`scripts/prove_it_all.sh` and `verify_truth.sh`) succeeds, while the historical subsumption attempt is preserved transparently in `archive/research/incomplete_subsumption_proof/`. Even with the focus shifted from RSA to graph colouring, the repository still distributes high-fidelity cryptanalytic transcripts, so stewardship must prioritise controlled disclosure, rigorous supply-chain hygiene, and continuous monitoring of derivative work.
