# Thiele geometric unification roadmap

_This roadmap translates the high-level "logic = computation = physics" narrative into precise Coq goals. Each section pinpoints
objects, morphisms, functors, and theorems that can be formalised inside the existing repository._

## 0. Guiding principle

The aim is to exhibit a single symmetric monoidal category **ThieleProc** built from the audited Thiele machine semantics such
that:

1. A proof-category for a linear logic fragment embeds fully faithfully into **ThieleProc** (logic lives inside).
2. The category of Turing machines and their executions embeds faithfully into **ThieleProc** (classical computation lives inside).
3. A Bell-style non-classical process theory embeds into **ThieleProc** but not into the Turing subcategory (physics-style
   correlations live inside).

These embeddings deliver the precise slogan: _logic, computation, and a physics-like fragment inhabit the same geometric process
space realised by Thiele programs_.

## 1. Build the process category `ThieleProc`

### 1.1 Objects
- Start from partition interfaces already tracked by `thielemachine` receipts: a finite multiset of Π-labelled components with
  designated I/O views.
- Provide constructors for the unit interface `I`, tensor product `⊗` (disjoint union of partitions), and duals if needed for
  linear logic.

### 1.2 Morphisms
- Represent a morphism `A → B` as an equivalence class of well-typed Thiele programs whose receipts transform any `A`-shaped
  state into a `B`-shaped state without leaking resources.
- Define observational equivalence via the closed-run semantics (`run_closed`, `trace_of_prog`) so two programs are equal when their closed receipts and μ-bit traces match.

### 1.3 Composition and identities
- Sequential composition is existing program composition (`seq_prog`). Prove it respects the observational equivalence.
- The identity on `A` is the pass-through program that copies the interface without altering μ-costs.
- Prove the category laws (`id ∘ f = f`, `(h ∘ g) ∘ f = h ∘ (g ∘ f)`).

### 1.4 Symmetric monoidal structure
- Tensor on objects is the disjoint-union interface; tensor on morphisms runs two programs on disjoint partitions (already
  supported by resource-separation lemmas).
- Provide associator, left/right unitors, and braiding defined by partition permutations.
- Prove the Mac Lane pentagon/triangle and symmetry axioms so **ThieleProc** is a symmetric monoidal category.

### 1.5 Deliverables
- [x] New Coq module `coq/thielemachine/coqproofs/ThieleProc.v` with objects, identities, closed-run semantics (`run_closed`/`trace_of_prog`), observational equivalence lemmas, and a packaged category structure.
- [ ] Companion docstring capturing categorical structure for reviewers.

## 2. Embed a logic fragment

### 2.1 Choose the logic
- Use a minimal multiplicative linear logic fragment: formulas generated by atoms, `⊗`, and linear implication `⊸`.
- Derivations via sequent calculus with cut.

### 2.2 Build the syntactic category `LLProc`
- Objects: formulas.
- Morphisms: proofs modulo cut-elimination (quotient by proof equivalence already studied in linear logic libraries, implement a
  simple inductive relation for now).
- Composition: cut; identity: axiom `A ⊢ A`.

### 2.3 Interpretation into `ThieleProc`
- Map atomic propositions to primitive interfaces (single partition, specific receipt expectations).
- Interpret `⊗` as tensor, `⊸` as internal hom built via existing call/return combinators in `ThieleMachine`.
- Translate each proof rule into a Thiele morphism using program combinators (tensor introduction = run programs in parallel,
  implication introduction = curry via resource separation, etc.).

### 2.4 Theorems to prove
- Soundness: every proof translates to a morphism; functor preserves identities and composition.
- Fullness + faithfulness on a chosen subcategory (e.g., proofs without contraction) so the embedding is fully faithful.
- Resulting statement: `LLProc` ≃ `ThieleProc_sub` for the image subcategory.

### 2.5 Implementation sketch
- Coq files: `coq/logic/LinearLogicSyntax.v`, `coq/logic/LinearLogicToThiele.v`.
- Use existing algebraic machinery (resource separation lemmas) to discharge linear logic cut elimination cases.

## 3. Embed Turing computation categorically

### 3.1 Define `TuringProc`
- Objects: tape interface descriptors (finite sets of tracks + head positions).
- Morphisms: deterministic Turing machines modulo trace equivalence (defined via the already-proven simulation relation).
- Composition: standard machine sequencing, with proofs that the equivalence is respected.

### 3.2 Functor `EmbedTuring : TuringProc → ThieleProc`
- On objects: use the compilation pipeline from Turing interfaces to Thiele partitions (already described in `SimulationProof`).
- On morphisms: compile Turing machine into Thiele program (`compile_machine`).
- Use existing theorems (`thiele_simulates_turing`, `turing_is_strictly_contained`) to show functor preserves identities and
  composition and is faithful.

### 3.3 Deliverables
- Coq module `coq/thielemachine/coqproofs/TuringProc.v` packaging the category and functor.
- Proof of faithfulness referencing the current simulation lemmas.

## 4. Embed a Bell-style process fragment

### 4.1 Define the target fragment `BellProc`
- Objects: measurement contexts (parties, settings, outcome types) as already encoded in `PartitionLogic.v`.
- Morphisms: correlation boxes satisfying no-signalling constraints (formalised via probability distributions or receipt traces).

### 4.2 Show realisability inside `ThieleProc`
- Construct Thiele programs whose receipts implement the Bell/CHSH experiment logic (existing proofs already witness
  non-classical correlations).
- Package these constructions as morphisms `BellProc → ThieleProc`.

### 4.3 Separate from the Turing subcategory
- Formalise a Bell inequality bound for any morphism lying in the image of `EmbedTuring`.
- Exhibit a Thiele morphism violating the bound, proving it cannot come from classical Turing computation.

### 4.4 Deliverables
- Coq modules `coq/physics/BellProc.v` and `coq/physics/BellToThiele.v`.
- Theorem: `BellProc` embeds in `ThieleProc` and its image is disjoint from `EmbedTuring`.

## 5. Glue the story

### 5.1 Master theorems
- `ThieleProc` is a symmetric monoidal category.
- `EmbedLogic : LLProc → ThieleProc` is fully faithful onto a subcategory.
- `EmbedTuring : TuringProc → ThieleProc` is faithful.
- `EmbedBell : BellProc → ThieleProc` is faithful and not factorable through the image of `EmbedTuring`.

### 5.2 Consequence
- Combine the above to state: _There exists a symmetric monoidal category **ThieleProc** in which the images of logic, classical
  computation, and a Bell-style physics fragment coexist, with the Bell fragment witnessing non-classical behaviour absent from
  the classical computation image._

### 5.3 Workflow integration
- Extend `docs/COQ_PROOF_COMPLETION_PLAN.md` with milestones for each deliverable.
- Create `make` targets (`make logic`, `make turingproc`, `make bellproc`) once the modules land to keep regression budgets tight.

## 6. Suggested iteration order

1. Formalise `ThieleProc` (Section 1) – prerequisite for all embeddings.
2. Package the existing Turing simulation as `EmbedTuring` – lowest risk, exercises the new category infrastructure.
3. Build the linear-logic embedding – uses same tensor/curry primitives, keeps scope tight.
4. Finish with the Bell fragment – requires probability/log trace reasoning but reuses PartitionLogic machinery.

## 7. Documentation & communication

- Mirror progress in `docs/COQ_PROOF_AUDIT.md` and `docs/COQ_PROOF_COMPLETION_PLAN.md` each time a milestone lands.
- Use the existing `tools/verify_end_to_end.py` workflow to link categorical statements back to executable artefacts: once
  `ThieleProc` exists, extend the tool to certify that the receipts used in the embeddings match the verified μ-bit accounting.

