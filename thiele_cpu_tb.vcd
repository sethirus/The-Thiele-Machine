$date
	Sat Dec 13 09:08:40 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module thiele_cpu_tb $end
$var wire 1 ! mem_en $end
$var wire 32 " mem_wdata [31:0] $end
$var wire 1 # mem_we $end
$var wire 32 $ status [31:0] $end
$var wire 1 % py_req $end
$var wire 32 & py_code_addr [31:0] $end
$var wire 32 ' pc [31:0] $end
$var wire 32 ( partition_ops [31:0] $end
$var wire 32 ) mu [31:0] $end
$var wire 32 * mem_addr [31:0] $end
$var wire 32 + mdl_ops [31:0] $end
$var wire 1 , logic_req $end
$var wire 32 - logic_addr [31:0] $end
$var wire 32 . info_gain [31:0] $end
$var wire 32 / error_code [31:0] $end
$var wire 32 0 cert_addr [31:0] $end
$var reg 1 1 clk $end
$var reg 1024 2 data_hex_path [1023:0] $end
$var reg 1 3 logic_ack $end
$var reg 32 4 logic_data [31:0] $end
$var reg 32 5 mem_rdata [31:0] $end
$var reg 1024 6 program_hex_path [1023:0] $end
$var reg 1 7 py_ack $end
$var reg 32 8 py_result [31:0] $end
$var reg 1 9 rst_n $end
$var integer 32 : have_data_hex [31:0] $end
$var integer 32 ; have_program_hex [31:0] $end
$var integer 32 < i [31:0] $end
$scope module dut $end
$var wire 32 = cert_addr [31:0] $end
$var wire 1 1 clk $end
$var wire 32 > current_instr [31:0] $end
$var wire 32 ? error_code [31:0] $end
$var wire 32 @ info_gain [31:0] $end
$var wire 32 A instr_data [31:0] $end
$var wire 1 3 logic_ack $end
$var wire 32 B logic_data [31:0] $end
$var wire 32 C mdl_ops [31:0] $end
$var wire 32 D mem_addr [31:0] $end
$var wire 1 ! mem_en $end
$var wire 32 E mem_rdata [31:0] $end
$var wire 32 F mem_wdata [31:0] $end
$var wire 1 # mem_we $end
$var wire 32 G mu [31:0] $end
$var wire 32 H partition_ops [31:0] $end
$var wire 32 I pc [31:0] $end
$var wire 1 7 py_ack $end
$var wire 32 J py_result [31:0] $end
$var wire 1 9 rst_n $end
$var wire 32 K status [31:0] $end
$var wire 1 L receipt_required $end
$var wire 1 M receipt_accepted $end
$var wire 1 % py_req $end
$var wire 32 N py_code_addr [31:0] $end
$var wire 1 O partition_gate_open $end
$var wire 8 P operand_cost [7:0] $end
$var wire 8 Q operand_b [7:0] $end
$var wire 8 R operand_a [7:0] $end
$var wire 8 S opcode [7:0] $end
$var wire 32 T mu_alu_result [31:0] $end
$var wire 1 U mu_alu_ready $end
$var wire 1 V mu_alu_overflow $end
$var wire 1 , logic_req $end
$var wire 32 W logic_addr [31:0] $end
$var wire 1 X instr_allowed $end
$var wire 1 Y enforcement_active $end
$var wire 1 Z cost_gate_open $end
$var wire 32 [ core_status [31:0] $end
$var wire 4 \ clz8_out [3:0] $end
$var parameter 8 ] ALU_CTX_MDLACC $end
$var parameter 8 ^ ALU_CTX_ORACLE $end
$var parameter 8 _ ALU_CTX_PDISCOVER1 $end
$var parameter 8 ` ALU_CTX_PDISCOVER2 $end
$var parameter 8 a CSR_CERT_ADDR $end
$var parameter 8 b CSR_ERROR $end
$var parameter 8 c CSR_INFO_GAIN $end
$var parameter 8 d CSR_MDL_OPS $end
$var parameter 8 e CSR_PARTITION_OPS $end
$var parameter 8 f CSR_STATUS $end
$var parameter 32 g MAX_MU $end
$var parameter 32 h NUM_MODULES $end
$var parameter 8 i OPCODE_EMIT $end
$var parameter 8 j OPCODE_HALT $end
$var parameter 8 k OPCODE_LASSERT $end
$var parameter 8 l OPCODE_LJOIN $end
$var parameter 8 m OPCODE_MDLACC $end
$var parameter 8 n OPCODE_ORACLE_HALTS $end
$var parameter 8 o OPCODE_PDISCOVER $end
$var parameter 8 p OPCODE_PMERGE $end
$var parameter 8 q OPCODE_PNEW $end
$var parameter 8 r OPCODE_PSPLIT $end
$var parameter 8 s OPCODE_PYEXEC $end
$var parameter 8 t OPCODE_XFER $end
$var parameter 8 u OPCODE_XOR_ADD $end
$var parameter 8 v OPCODE_XOR_LOAD $end
$var parameter 8 w OPCODE_XOR_RANK $end
$var parameter 8 x OPCODE_XOR_SWAP $end
$var parameter 32 y REGION_SIZE $end
$var parameter 4 z STATE_ALU_WAIT $end
$var parameter 4 { STATE_ALU_WAIT2 $end
$var parameter 4 | STATE_COMPLETE $end
$var parameter 4 } STATE_DECODE $end
$var parameter 4 ~ STATE_EXECUTE $end
$var parameter 4 !" STATE_FETCH $end
$var parameter 4 "" STATE_LOGIC $end
$var parameter 4 #" STATE_MEMORY $end
$var parameter 4 $" STATE_PYTHON $end
$var parameter 4 %" STATE_RECEIPT_HOLD $end
$var reg 8 &" alu_context [7:0] $end
$var reg 4 '" alu_return_state [3:0] $end
$var reg 8 (" clz8_in [7:0] $end
$var reg 32 )" csr_cert_addr [31:0] $end
$var reg 32 *" csr_error [31:0] $end
$var reg 32 +" csr_status [31:0] $end
$var reg 6 ," current_module [5:0] $end
$var reg 32 -" even_count [31:0] $end
$var reg 32 ." i [31:0] $end
$var reg 32 /" info_gain_counter [31:0] $end
$var reg 32 0" info_gain_value [31:0] $end
$var reg 32 1" j [31:0] $end
$var reg 32 2" mdl_cost [31:0] $end
$var reg 32 3" mdl_ops_counter [31:0] $end
$var reg 32 4" module_size [31:0] $end
$var reg 32 5" mu_accumulator [31:0] $end
$var reg 3 6" mu_alu_op [2:0] $end
$var reg 32 7" mu_alu_operand_a [31:0] $end
$var reg 32 8" mu_alu_operand_b [31:0] $end
$var reg 1 9" mu_alu_valid $end
$var reg 6 :" next_module_id [5:0] $end
$var reg 32 ;" odd_count [31:0] $end
$var reg 32 <" partition_ops_counter [31:0] $end
$var reg 32 =" pc_reg [31:0] $end
$var reg 32 >" proposed_cost [31:0] $end
$var reg 1 ?" receipt_valid $end
$var reg 32 @" receipt_value [31:0] $end
$var reg 32 A" region_size [31:0] $end
$var reg 32 B" size_a [31:0] $end
$var reg 32 C" size_b [31:0] $end
$var reg 4 D" state [3:0] $end
$var reg 32 E" swap_temp [31:0] $end
$var reg 32 F" total_size [31:0] $end
$scope module clz8_inst $end
$var wire 8 G" x [7:0] $end
$var reg 4 H" out [3:0] $end
$upscope $end
$scope module mu_alu_inst $end
$var wire 1 1 clk $end
$var wire 3 I" op [2:0] $end
$var wire 32 J" operand_a [31:0] $end
$var wire 32 K" operand_b [31:0] $end
$var wire 1 9 rst_n $end
$var wire 1 9" valid $end
$var parameter 3 L" OP_ADD $end
$var parameter 3 M" OP_DIV $end
$var parameter 3 N" OP_INFO_GAIN $end
$var parameter 3 O" OP_LOG2 $end
$var parameter 3 P" OP_MUL $end
$var parameter 3 Q" OP_SUB $end
$var parameter 32 R" Q16_MAX $end
$var parameter 32 S" Q16_MIN $end
$var parameter 32 T" Q16_ONE $end
$var parameter 32 U" Q16_SHIFT $end
$var reg 64 V" div_temp [63:0] $end
$var reg 32 W" frac_log [31:0] $end
$var reg 32 X" frac_part [31:0] $end
$var reg 6 Y" highest_bit [5:0] $end
$var reg 32 Z" integer_log2 [31:0] $end
$var reg 6 [" leading_zeros [5:0] $end
$var reg 32 \" log2_input [31:0] $end
$var reg 8 ]" lut_index [7:0] $end
$var reg 64 ^" mul_temp [63:0] $end
$var reg 32 _" normalized [31:0] $end
$var reg 1 V overflow $end
$var reg 1 U ready $end
$var reg 32 `" result [31:0] $end
$var reg 32 a" result_temp [31:0] $end
$var reg 32 b" shift_amount [31:0] $end
$var reg 6 c" state [5:0] $end
$var reg 32 d" temp_result [31:0] $end
$upscope $end
$scope module mu_core_inst $end
$var wire 1 1 clk $end
$var wire 32 e" current_mu_cost [31:0] $end
$var wire 1 f" instr_valid $end
$var wire 32 g" instruction [31:0] $end
$var wire 32 h" memory_isolation [31:0] $end
$var wire 6 i" partition_count [5:0] $end
$var wire 32 j" proposed_cost [31:0] $end
$var wire 1 ?" receipt_valid $end
$var wire 32 k" receipt_value [31:0] $end
$var wire 1 9 rst_n $end
$var parameter 8 l" OPCODE_MDLACC $end
$var parameter 8 m" OPCODE_PDISCOVER $end
$var parameter 8 n" OPCODE_PMERGE $end
$var parameter 8 o" OPCODE_PNEW $end
$var parameter 8 p" OPCODE_PSPLIT $end
$var parameter 32 q" STATUS_ALLOWED $end
$var parameter 32 r" STATUS_CHECKING $end
$var parameter 32 s" STATUS_DENIED_COST $end
$var parameter 32 t" STATUS_DENIED_ISO $end
$var parameter 32 u" STATUS_IDLE $end
$var parameter 32 v" STATUS_RECEIPT_OK $end
$var reg 32 w" core_status [31:0] $end
$var reg 1 x" cost_decreasing $end
$var reg 1 Z cost_gate_open $end
$var reg 1 Y enforcement_active $end
$var reg 32 y" expected_cost [31:0] $end
$var reg 1 X instr_allowed $end
$var reg 32 z" last_instruction [31:0] $end
$var reg 1 O partition_gate_open $end
$var reg 1 {" partition_independent $end
$var reg 1 M receipt_accepted $end
$var reg 1 L receipt_required $end
$scope function check_partition_independence $end
$var reg 32 |" instr [31:0] $end
$var reg 32 }" mem_iso [31:0] $end
$var reg 6 ~" part_count [5:0] $end
$upscope $end
$upscope $end
$scope task execute_emit $end
$var reg 8 !# value_a [7:0] $end
$var reg 8 "# value_b [7:0] $end
$upscope $end
$scope task execute_ljoin $end
$var reg 8 ## cert_a [7:0] $end
$var reg 8 $# cert_b [7:0] $end
$upscope $end
$scope task execute_mdlacc $end
$var reg 8 %# module_id [7:0] $end
$scope begin $unm_blk_80 $end
$var integer 32 &# bit_length [31:0] $end
$var integer 32 '# k [31:0] $end
$var integer 32 (# max_element [31:0] $end
$upscope $end
$upscope $end
$scope task execute_oracle_halts $end
$var reg 8 )# desc_ptr_a [7:0] $end
$var reg 8 *# desc_ptr_b [7:0] $end
$upscope $end
$scope task execute_pdiscover $end
$var reg 8 +# after_count [7:0] $end
$var reg 8 ,# before_count [7:0] $end
$upscope $end
$scope task execute_pmerge $end
$var reg 8 -# module_a [7:0] $end
$var reg 8 .# module_b [7:0] $end
$upscope $end
$scope task execute_pnew $end
$var reg 8 /# region_spec_a [7:0] $end
$var reg 8 0# region_spec_b [7:0] $end
$scope begin $unm_blk_54 $end
$var integer 32 1# found [31:0] $end
$var integer 32 2# found_id [31:0] $end
$upscope $end
$upscope $end
$scope task execute_psplit $end
$var reg 32 3# element_value [31:0] $end
$var reg 1 4# matches_predicate $end
$var reg 8 5# module_id [7:0] $end
$var reg 2 6# pred_mode [1:0] $end
$var reg 6 7# pred_param [5:0] $end
$var reg 8 8# predicate [7:0] $end
$upscope $end
$scope task execute_xfer $end
$var reg 8 9# dest [7:0] $end
$var reg 8 :# src [7:0] $end
$upscope $end
$scope task execute_xor_add $end
$var reg 8 ;# dest [7:0] $end
$var reg 8 <# src [7:0] $end
$upscope $end
$scope task execute_xor_load $end
$var reg 8 =# addr [7:0] $end
$var reg 8 ># dest [7:0] $end
$upscope $end
$scope task execute_xor_rank $end
$var reg 32 ?# cnt [31:0] $end
$var reg 8 @# dest [7:0] $end
$var reg 8 A# src [7:0] $end
$var reg 32 B# v [31:0] $end
$var integer 32 C# k [31:0] $end
$upscope $end
$scope task execute_xor_swap $end
$var reg 8 D# a [7:0] $end
$var reg 8 E# b [7:0] $end
$upscope $end
$upscope $end
$scope begin $unm_blk_125 $end
$var integer 32 F# k [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b101 v"
b0 u"
b100 t"
b11 s"
b1 r"
b10 q"
b1 p"
b0 o"
b10 n"
b110 m"
b101 l"
b10000 U"
b10000000000000000 T"
b10000000000000000000000000000000 S"
b1111111111111111111111111111111 R"
b1 Q"
b10 P"
b100 O"
b101 N"
b11 M"
b0 L"
b1001 %"
b101 $"
b11 #"
b100 ""
b0 !"
b10 ~
b1 }
b110 |
b1000 {
b111 z
b10000000000 y
b1100 x
b1101 w
b1010 v
b1011 u
b111 t
b1000 s
b1 r
b0 q
b10 p
b110 o
b1111 n
b101 m
b100 l
b11 k
b11111111 j
b1110 i
b1000000 h
b11111111111111111111111111111111 g
b1 f
b11 e
b100 d
b101 c
b10 b
b0 a
b11 `
b10 _
b100 ^
b1 ]
$end
#0
$dumpvars
bx F#
bx E#
bx D#
bx C#
bx B#
bx A#
bx @#
bx ?#
bx >#
bx =#
bx <#
bx ;#
bx :#
bx 9#
bx 8#
bx 7#
bx 6#
bx 5#
x4#
bx 3#
bx 2#
bx 1#
bx 0#
bx /#
bx .#
bx -#
bx ,#
bx +#
bx *#
bx )#
bx (#
bx '#
bx &#
bx %#
bx $#
bx ##
bx "#
bx !#
bx ~"
bx }"
bx |"
1{"
b0 z"
b0 y"
0x"
b0 w"
bx k"
bx j"
b1 i"
b11001010111111101011101010111110 h"
b1010000000000000000000000000 g"
0f"
b0 e"
bx d"
b0 c"
bx b"
bx a"
b0 `"
bx _"
bx ^"
bx ]"
bx \"
bx ["
bx Z"
bx Y"
bx X"
bx W"
bx V"
bx K"
bx J"
bx I"
bx H"
bx G"
bx F"
bx E"
b0 D"
bx C"
bx B"
bx A"
bx @"
x?"
bx >"
b0 ="
b0 <"
bx ;"
b1 :"
x9"
bx 8"
bx 7"
bx 6"
b0 5"
bx 4"
b0 3"
bx 2"
b10000000000 1"
bx 0"
b0 /"
b100000000 ."
bx -"
b0 ,"
b0 +"
b0 *"
b0 )"
bx ("
bx '"
bx &"
bx \
b0 [
0Z
1Y
0X
b0 W
0V
0U
b0 T
b1010 S
b0 R
b0 Q
b0 P
0O
b0 N
0M
0L
b0 K
bx J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
bx B
b1010000000000000000000000000 A
b0 @
b0 ?
b1010000000000000000000000000 >
b0 =
b100000000 <
b0 ;
b0 :
09
bx 8
07
bx 6
b0 5
bx 4
03
bx 2
01
b0 0
b0 /
b0 .
b0 -
0,
b0 +
b0 *
b0 )
b0 (
b0 '
b0 &
0%
b0 $
0#
b0 "
1!
$end
#5000
b101001 5
b101001 E
b10000000000 1"
b100000000 ."
11
#10000
01
#15000
b10000000000 1"
b100000000 ."
11
#20000
01
19
#21000
b100000000 <
#25000
1f"
b1 D"
11
#30000
01
#35000
1Z
1O
1X
b0 [
b0 w"
b1010000000000000000000000000 z"
0f"
b10 D"
b0 >"
b0 j"
11
#40000
01
#45000
b100000001 -
b100000001 W
b100000001 &
b100000001 N
b1 R
b1 Q
b1010000000010000000100000000 >
b1010000000010000000100000000 g"
b1010000000010000000100000000 A
b0 D"
b100 *
b100 D
b100 '
b100 I
b100 ="
b111 $
b111 K
b111 +"
0O
0Z
0X
b0 =#
b0 >#
11
#50000
01
#55000
1f"
b1 D"
b10010 5
b10010 E
11
#60000
01
#65000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1010000000010000000100000000 z"
11
#70000
01
#75000
b1000000010 -
b1000000010 W
b1000000010 &
b1000000010 N
b10 R
b10 Q
b1010000000100000001000000000 >
b1010000000100000001000000000 g"
b1010000000100000001000000000 A
b0 D"
b1000 *
b1000 D
b1000 '
b1000 I
b1000 ="
0O
0Z
0X
b1 =#
b1 >#
11
#80000
01
#85000
1f"
b1 D"
b100010 5
b100010 E
11
#90000
01
#95000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1010000000100000001000000000 z"
11
#100000
01
#105000
b1100000011 -
b1100000011 W
b1100000011 &
b1100000011 N
b11 R
b11 Q
b1010000000110000001100000000 >
b1010000000110000001100000000 g"
b1010000000110000001100000000 A
b0 D"
b1100 *
b1100 D
b1100 '
b1100 I
b1100 ="
0O
0Z
0X
b10 =#
b10 >#
11
#110000
01
#115000
1f"
b1 D"
b11 5
b11 E
11
#120000
01
#125000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1010000000110000001100000000 z"
11
#130000
01
#135000
b1100000000 -
b1100000000 W
b1100000000 &
b1100000000 N
b1011 S
b0 Q
b1011000000110000000000000000 >
b1011000000110000000000000000 g"
b1011000000110000000000000000 A
b0 D"
b10000 *
b10000 D
b10000 '
b10000 I
b10000 ="
0O
0Z
0X
b11 =#
b11 >#
11
#140000
01
#145000
1f"
b1 D"
b0 5
b0 E
11
#150000
01
#155000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1011000000110000000000000000 z"
11
#160000
01
#165000
b1100000001 -
b1100000001 W
b1100000001 &
b1100000001 N
b1 Q
b1011000000110000000100000000 >
b1011000000110000000100000000 g"
b1011000000110000000100000000 A
b0 D"
b10100 *
b10100 D
b10100 '
b10100 I
b10100 ="
b1000 $
b1000 K
b1000 +"
0O
0Z
0X
b0 <#
b11 ;#
11
#170000
01
#175000
1f"
b1 D"
11
#180000
01
#185000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1011000000110000000100000000 z"
11
#190000
01
#195000
b11 -
b11 W
b11 &
b11 N
b1100 S
b0 R
b11 Q
b1100000000000000001100000000 >
b1100000000000000001100000000 g"
b1100000000000000001100000000 A
b0 D"
b11000 *
b11000 D
b11000 '
b11000 I
b11000 ="
0O
0Z
0X
b1 <#
11
#200000
01
#205000
1f"
b1 D"
11
#210000
01
#215000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1100000000000000001100000000 z"
11
#220000
01
#225000
b1000000100 -
b1000000100 W
b1000000100 &
b1000000100 N
b111 S
b10 R
b100 Q
b111000000100000010000000000 >
b111000000100000010000000000 g"
b111000000100000010000000000 A
b0 D"
b11100 *
b11100 D
b11100 '
b11100 I
b11100 ="
b1001 $
b1001 K
b1001 +"
0O
0Z
0X
b101001 E"
b11 E#
b0 D#
11
#230000
01
#235000
1f"
b1 D"
11
#240000
01
#245000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b111000000100000010000000000 z"
11
#250000
01
#255000
b10100000100 -
b10100000100 W
b10100000100 &
b10100000100 N
b1101 S
b101 R
b1101000001010000010000000000 >
b1101000001010000010000000000 g"
b1101000001010000010000000000 A
b0 D"
b100000 *
b100000 D
b100000 '
b100000 I
b100000 ="
b110 $
b110 K
b110 +"
0O
0Z
0X
b100 9#
b10 :#
11
#260000
01
#265000
1f"
b1 D"
11
#270000
01
#275000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1101000001010000010000000000 z"
11
#280000
01
#285000
b11000000100 -
b11000000100 W
b11000000100 &
b11000000100 N
b1110 S
b110 R
b1110000001100000010000000000 >
b1110000001100000010000000000 g"
b1110000001100000010000000000 A
b0 D"
b100100 *
b100100 D
b100100 '
b100100 I
b100100 ="
b10 $
b10 K
b10 +"
0O
0Z
0X
b100000 C#
b10 ?#
b100010 B#
b100 A#
b101 @#
11
#290000
01
#295000
1f"
b1 D"
11
#300000
01
#305000
0f"
b10 D"
1Z
1O
1X
b0 [
b0 w"
b1110000001100000010000000000 z"
11
#310000
01
#315000
b11100000101 -
b11100000101 W
b11100000101 &
b11100000101 N
b1111 S
b111 R
b101 Q
b1111000001110000010100000000 >
b1111000001110000010100000000 g"
b1111000001110000010100000000 A
b0 D"
b101000 *
b101000 D
b101000 '
b101000 I
b101000 ="
b110000001000000000000000000 $
b110000001000000000000000000 K
b110000001000000000000000000 +"
b1 .
b1 @
b1 /"
0O
0Z
0X
b100 "#
b110 !#
11
#320000
01
#325000
1f"
b1 D"
11
b1000000 <
