"""Compositional work decomposition multi-module runner."""

from __future__ import annotations

import argparse
import csv
import json
import math
from dataclasses import dataclass
from pathlib import Path
import random
from typing import Dict, Iterable, List, MutableMapping, Sequence, Tuple

from . import ledger_io

K_BOLTZMANN = 1.0
LN2 = math.log(2.0)


@dataclass(frozen=True)
class CWDConfig:
    """Configuration parameters for Phase B1 multi-module simulations."""

    output_dir: Path
    seeds: Sequence[int]
    temps: Sequence[float]
    trials_per_condition: int
    modules: int = 3
    steps_per_module: int = 8
    mu_base: float = 0.18
    mu_jitter: float = 0.045
    penalty_scale: float = 1.45
    protocol: str = "sighted"


@dataclass(frozen=True)
class CWDTrialSummary:
    """Aggregated metrics for a single compositional work trial."""

    seed: int
    temperature: float
    trial_id: int
    protocol: str
    module_count: int
    steps_per_module: int
    mu_total_bits: float
    work: float
    penalty_bits_total: float
    mutual_information_bits: float
    success_rate: float

    @property
    def total_steps(self) -> int:
        return self.module_count * self.steps_per_module

    @property
    def work_over_kTln2(self) -> float:
        return self.work / (K_BOLTZMANN * self.temperature * LN2)

    def as_row(self) -> Dict[str, str]:
        return {
            "seed": str(self.seed),
            "T": f"{self.temperature:.6f}",
            "trial_id": str(self.trial_id),
            "protocol": self.protocol,
            "modules": str(self.module_count),
            "steps_per_module": str(self.steps_per_module),
            "mu_total_bits": f"{self.mu_total_bits:.10f}",
            "work": f"{self.work:.10f}",
            "work_over_kTln2": f"{self.work_over_kTln2:.10f}",
            "penalty_bits_total": f"{self.penalty_bits_total:.10f}",
            "mutual_information_bits": f"{self.mutual_information_bits:.10f}",
            "success_rate": f"{self.success_rate:.10f}",
        }


@dataclass(frozen=True)
class RunResult:
    """Container for artefacts generated by :func:`execute`."""

    ledger_rows: List[MutableMapping[str, float | int | str]]
    summaries: List[CWDTrialSummary]
    metadata: Dict[str, float | int | str]


def _trial_seed(base_seed: int, temp_index: int, trial_id: int) -> int:
    return base_seed * 10_000 + temp_index * 1_000 + trial_id


def _module_mu_sequence(
    modules: int,
    steps_per_module: int,
    seed: int,
    module_index: int,
    mu_base: float,
    mu_jitter: float,
) -> List[float]:
    module_rng = random.Random(seed + 97 * (module_index + 1))
    sequence: List[float] = []
    base = mu_base + 0.0125 * (module_index + 1)
    for step in range(steps_per_module):
        phase = (module_index + 1) * (step + 1)
        jitter = (module_rng.random() - 0.5) * mu_jitter
        mu = base + 0.02 * math.sin(phase / (modules + 0.75)) + jitter
        sequence.append(max(mu, 1e-3))
    return sequence


def _mutual_information_bits(
    joint_counts: Dict[int, Dict[int, int]], total_steps: int
) -> float:
    if total_steps == 0:
        return 0.0
    action_totals: Dict[int, int] = {}
    module_totals: Dict[int, int] = {}
    for module, counts in joint_counts.items():
        module_totals[module] = sum(counts.values())
        for action, count in counts.items():
            action_totals[action] = action_totals.get(action, 0) + count
    mi = 0.0
    total = float(total_steps)
    for module, counts in joint_counts.items():
        module_total = module_totals[module]
        if module_total == 0:
            continue
        p_module = module_total / total
        for action, count in counts.items():
            if count == 0:
                continue
            action_total = action_totals.get(action, 0)
            if action_total == 0:
                continue
            p_action = action_total / total
            p_joint = count / total
            ratio = p_joint / (p_module * p_action)
            if ratio <= 0.0:
                continue
            mi += p_joint * math.log2(ratio)
    return mi


def _simulate_single_trial(
    config: CWDConfig,
    seed: int,
    temp_index: int,
    temperature: float,
    trial_id: int,
) -> Tuple[List[MutableMapping[str, float | int | str]], CWDTrialSummary]:
    trial_seed = _trial_seed(seed, temp_index, trial_id)
    policy_rng = random.Random(trial_seed)
    ledger_rows: List[MutableMapping[str, float | int | str]] = []
    cumulative_work = 0.0
    cumulative_mu = 0.0
    penalty_bits_total = 0.0
    success_count = 0
    joint_counts: Dict[int, Dict[int, int]] = {}
    total_steps = config.modules * config.steps_per_module
    penalty_per_miss = config.penalty_scale * math.log2(max(config.modules, 2))
    destroyed_scale = 0.9 if config.protocol == "destroyed" else 1.0

    global_step = 0
    for module_index in range(config.modules):
        mu_sequence = _module_mu_sequence(
            config.modules,
            config.steps_per_module,
            trial_seed,
            module_index,
            config.mu_base,
            config.mu_jitter,
        )
        module_counts = joint_counts.setdefault(module_index, {})
        for step_index, mu_bits in enumerate(mu_sequence):
            base_work = mu_bits * K_BOLTZMANN * temperature * LN2
            if config.protocol == "sighted":
                policy_action = module_index
                penalty_bits = 0.0
            elif config.protocol == "blind":
                policy_action = policy_rng.randrange(config.modules)
                penalty_bits = 0.0 if policy_action == module_index else penalty_per_miss
            elif config.protocol == "destroyed":
                policy_action = policy_rng.randrange(config.modules)
                penalty_bits = 0.0
            else:
                raise ValueError(f"Unsupported protocol: {config.protocol}")

            success = 1 if policy_action == module_index else 0
            success_count += success
            module_counts[policy_action] = module_counts.get(policy_action, 0) + 1
            penalty_bits_total += penalty_bits

            work = destroyed_scale * (base_work + penalty_bits * K_BOLTZMANN * temperature * LN2)
            cumulative_work += work
            cumulative_mu += mu_bits

            ledger_rows.append(
                {
                    "seed": seed,
                    "T": temperature,
                    "trial_id": trial_id,
                    "protocol": config.protocol,
                    "module": module_index,
                    "observed_module": module_index if config.protocol != "destroyed" else -1,
                    "step": global_step,
                    "module_step": step_index,
                    "mu_answer": mu_bits,
                    "policy_action": policy_action,
                    "policy_success": success,
                    "base_work": base_work,
                    "penalty_bits": penalty_bits,
                    "work": work,
                    "cumulative_work": cumulative_work,
                    "mu_cumulative": cumulative_mu,
                }
            )
            global_step += 1

    mi_bits = _mutual_information_bits(joint_counts, total_steps)
    summary = CWDTrialSummary(
        seed=seed,
        temperature=temperature,
        trial_id=trial_id,
        protocol=config.protocol,
        module_count=config.modules,
        steps_per_module=config.steps_per_module,
        mu_total_bits=cumulative_mu,
        work=cumulative_work,
        penalty_bits_total=penalty_bits_total,
        mutual_information_bits=mi_bits,
        success_rate=success_count / total_steps if total_steps else 0.0,
    )
    return ledger_rows, summary


def execute(config: CWDConfig) -> RunResult:
    ledger_rows: List[MutableMapping[str, float | int | str]] = []
    summaries: List[CWDTrialSummary] = []
    for seed in config.seeds:
        for temp_index, temperature in enumerate(config.temps):
            for trial_id in range(config.trials_per_condition):
                trial_rows, summary = _simulate_single_trial(
                    config, seed, temp_index, temperature, trial_id
                )
                ledger_rows.extend(trial_rows)
                summaries.append(summary)

    metadata = {
        "k_B": K_BOLTZMANN,
        "protocol": config.protocol,
        "modules": config.modules,
        "steps_per_module": config.steps_per_module,
        "mu_base": config.mu_base,
        "mu_jitter": config.mu_jitter,
        "penalty_scale": config.penalty_scale,
        "num_trials": len(summaries),
    }
    return RunResult(ledger_rows=ledger_rows, summaries=summaries, metadata=metadata)


def _summaries_from_ledger(
    entries: Iterable[ledger_io.LedgerEntry],
) -> List[CWDTrialSummary]:
    grouped: Dict[Tuple[int, float, int, str], Dict[str, object]] = {}
    for entry in entries:
        payload = entry.payload
        key = (
            int(payload["seed"]),
            float(payload["T"]),
            int(payload["trial_id"]),
            str(payload["protocol"]),
        )
        state = grouped.setdefault(
            key,
            {
                "modules": set(),
                "steps_per_module": {},
                "mu_total": 0.0,
                "work_total": 0.0,
                "penalty_bits": 0.0,
                "success_count": 0,
                "joint": {},
                "row_count": 0,
            },
        )
        module = int(payload["module"])
        policy_action = int(payload["policy_action"])
        state["modules"].add(module)
        steps_map = state["steps_per_module"]
        steps_map[module] = steps_map.get(module, 0) + 1
        state["mu_total"] += float(payload.get("mu_answer", 0.0))
        state["work_total"] += float(payload.get("work", 0.0))
        state["penalty_bits"] += float(payload.get("penalty_bits", 0.0))
        state["success_count"] += int(payload.get("policy_success", 0))
        joint = state["joint"].setdefault(module, {})
        joint[policy_action] = joint.get(policy_action, 0) + 1
        state["row_count"] += 1
    summaries: List[CWDTrialSummary] = []
    for (seed, temperature, trial_id, protocol), state in grouped.items():
        modules = sorted(state["modules"])
        if modules:
            steps_list = [state["steps_per_module"][m] for m in modules]
            steps_per_module = steps_list[0]
        else:
            steps_per_module = 0
        total_steps = state["row_count"]
        mi_bits = _mutual_information_bits(state["joint"], total_steps)
        summary = CWDTrialSummary(
            seed=seed,
            temperature=temperature,
            trial_id=trial_id,
            protocol=protocol,
            module_count=len(modules) if modules else 0,
            steps_per_module=steps_per_module,
            mu_total_bits=float(state["mu_total"]),
            work=float(state["work_total"]),
            penalty_bits_total=float(state["penalty_bits"]),
            mutual_information_bits=mi_bits,
            success_rate=(state["success_count"] / total_steps) if total_steps else 0.0,
        )
        summaries.append(summary)
    summaries.sort(key=lambda item: (item.seed, item.temperature, item.trial_id))
    return summaries


def _replay_synthetic_ledger(path: Path) -> RunResult:
    entries = ledger_io.load_ledger(path)
    summaries = _summaries_from_ledger(entries)
    metadata = {
        "k_B": K_BOLTZMANN,
        "protocol": "synthetic",
        "modules": summaries[0].module_count if summaries else 0,
        "steps_per_module": summaries[0].steps_per_module if summaries else 0,
        "num_trials": len(summaries),
    }
    ledger_rows = [dict(entry.payload) for entry in entries]
    return RunResult(ledger_rows=ledger_rows, summaries=summaries, metadata=metadata)


def run_cwd(config: CWDConfig, synthetic_ledger: Path | None = None) -> RunResult:
    if synthetic_ledger is not None:
        return _replay_synthetic_ledger(synthetic_ledger)
    return execute(config)


def _write_ledger(path: Path, rows: Sequence[MutableMapping[str, float | int | str]]) -> None:
    ledger_io.dump_ledger(rows, path)


def _write_summary(path: Path, summaries: Sequence[CWDTrialSummary]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8", newline="") as handle:
        writer = csv.DictWriter(
            handle,
            fieldnames=[
                "seed",
                "T",
                "trial_id",
                "protocol",
                "modules",
                "steps_per_module",
                "mu_total_bits",
                "work",
                "work_over_kTln2",
                "penalty_bits_total",
                "mutual_information_bits",
                "success_rate",
            ],
        )
        writer.writeheader()
        for summary in summaries:
            writer.writerow(summary.as_row())


def _write_metadata(path: Path, metadata: Dict[str, float | int | str], digest: str) -> None:
    enriched = dict(metadata)
    enriched["ledger_digest_sha256"] = digest
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as handle:
        json.dump(enriched, handle, indent=2, sort_keys=True)
        handle.write("\n")


def _parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Phase B1 compositional work decomposition runner"
    )
    parser.add_argument("--output-dir", type=Path, required=True, help="Directory for artefacts")
    parser.add_argument(
        "--seeds", type=int, nargs="*", default=[0, 1, 2], help="Deterministic RNG seeds"
    )
    parser.add_argument(
        "--temps",
        type=float,
        nargs="*",
        default=[0.75, 1.0],
        help="Temperature schedule for the modules",
    )
    parser.add_argument(
        "--trials-per-condition",
        type=int,
        default=2,
        help="Trials per seed/temperature pair",
    )
    parser.add_argument("--modules", type=int, default=3, help="Number of independent modules")
    parser.add_argument(
        "--steps-per-module", type=int, default=8, help="Number of steps per module"
    )
    parser.add_argument(
        "--mu-base",
        type=float,
        default=0.18,
        help="Base μ-answer increment per step",
    )
    parser.add_argument(
        "--mu-jitter",
        type=float,
        default=0.045,
        help="Random jitter added to μ increments",
    )
    parser.add_argument(
        "--penalty-scale",
        type=float,
        default=1.45,
        help="Penalty multiplier applied when policy actions mismatch",
    )
    parser.add_argument(
        "--protocol",
        choices=["sighted", "blind", "destroyed"],
        default="sighted",
        help="Routing visibility for the agent policy",
    )
    parser.add_argument(
        "--synthetic-ledger",
        type=Path,
        help="Replay a precomputed ledger instead of simulating",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> None:
    args = _parse_args(argv)
    config = CWDConfig(
        output_dir=args.output_dir,
        seeds=args.seeds,
        temps=args.temps,
        trials_per_condition=args.trials_per_condition,
        modules=args.modules,
        steps_per_module=args.steps_per_module,
        mu_base=args.mu_base,
        mu_jitter=args.mu_jitter,
        penalty_scale=args.penalty_scale,
        protocol=args.protocol,
    )
    result = run_cwd(config, synthetic_ledger=args.synthetic_ledger)
    output_dir = args.output_dir
    ledger_path = output_dir / "cwd_steps.jsonl"
    summary_path = output_dir / "cwd_summary.csv"
    metadata_path = output_dir / "cwd_metadata.json"

    _write_ledger(ledger_path, result.ledger_rows)
    entries = ledger_io.load_ledger(ledger_path)
    digest = ledger_io.ledger_digest(entries)
    _write_summary(summary_path, result.summaries)
    _write_metadata(metadata_path, result.metadata, digest)


if __name__ == "__main__":  # pragma: no cover
    main()
