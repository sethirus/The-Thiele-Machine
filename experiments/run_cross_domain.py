"""Cross-domain echo microbenchmarks with deterministic logging.

This module implements the Builder deliverables for Phase C of the
zero-trust Thiele experiment plan.  It synthesises lightweight
compression- and LDPC-inspired workloads with sighted, blind, and
destroyed protocols so that Auditors can verify:

* sighted runs exhibit flat runtime-vs-μ slopes whose confidence
  intervals include zero;
* blind runs favour an exponential runtime fit over a polynomial model
  with ΔAIC ≥ 10; and
* destroyed controls break the structure advantage recorded by the
  sighted protocol.

Each invocation logs stepwise μ-ledger rows, emits per-trial summary
metrics, and supports a ``--synthetic-ledger`` replay flag that enables
unit tests without rerunning the simulation.  The implementation keeps
numerics deterministic by deriving reproducible seeds and avoiding any
hidden state beyond the emitted ledger files.
"""

from __future__ import annotations

from dataclasses import dataclass
import argparse
import csv
import json
import math
from pathlib import Path
import random
from typing import Dict, List, Mapping, MutableMapping, Sequence, Tuple

from . import ledger_io


@dataclass(frozen=True)
class CrossDomainConfig:
    """Configuration parameters for the cross-domain echoes builder."""

    output_dir: Path
    seeds: Sequence[int]
    trials_per_condition: int
    modules: int = 6
    protocol: str = "sighted"
    domains: Sequence[str] = ("compression", "ldpc")
    mu_base: float = 0.22
    mu_jitter: float = 0.04
    runtime_base: float = 1.0
    runtime_scale: float = 0.6


@dataclass(frozen=True)
class DomainStats:
    """Aggregated regression diagnostics for a domain/protocol pair."""

    slope: float
    slope_ci_low: float
    slope_ci_high: float
    aic_exponential: float
    aic_polynomial: float
    delta_aic: float


@dataclass(frozen=True)
class CrossDomainTrialSummary:
    """Per-trial aggregates enriched with domain-level diagnostics."""

    seed: int
    domain: str
    trial_id: int
    protocol: str
    mu_total_bits: float
    runtime_total: float
    domain_slope: float
    domain_slope_ci_low: float
    domain_slope_ci_high: float
    domain_aic_exponential: float
    domain_aic_polynomial: float
    domain_delta_aic: float
    structure_integrity: float

    def as_row(self) -> Dict[str, str]:
        return {
            "seed": str(self.seed),
            "domain": self.domain,
            "trial_id": str(self.trial_id),
            "protocol": self.protocol,
            "mu_total_bits": f"{self.mu_total_bits:.10f}",
            "runtime_total": f"{self.runtime_total:.10f}",
            "domain_slope": f"{self.domain_slope:.10f}",
            "domain_slope_ci_low": f"{self.domain_slope_ci_low:.10f}",
            "domain_slope_ci_high": f"{self.domain_slope_ci_high:.10f}",
            "domain_aic_exponential": f"{self.domain_aic_exponential:.10f}",
            "domain_aic_polynomial": f"{self.domain_aic_polynomial:.10f}",
            "domain_delta_aic": f"{self.domain_delta_aic:.10f}",
            "structure_integrity": f"{self.structure_integrity:.6f}",
        }


@dataclass(frozen=True)
class RunResult:
    """Container for artefacts generated by :func:`execute`."""

    ledger_rows: List[MutableMapping[str, float | int | str]]
    summaries: List[CrossDomainTrialSummary]
    metadata: Dict[str, float | int | str]


_STRUCTURE_MAP = {
    "sighted": 1.0,
    "blind": 0.5,
    "destroyed": 0.0,
}


def _trial_seed(base_seed: int, domain_index: int, trial_id: int) -> int:
    """Derive a deterministic seed per trial."""

    return base_seed * 10_000 + domain_index * 1_000 + trial_id


def _domain_factor(domain: str, index: int) -> float:
    """Return a deterministic scaling factor for the domain."""

    # Compression is treated as baseline 1.0, LDPC receives a modest boost.
    return 1.0 + 0.12 * index + (0.05 if domain.startswith("ldpc") else 0.0)


def _mu_increment(config: CrossDomainConfig, rng: random.Random, domain: str, index: int) -> float:
    base = config.mu_base * _domain_factor(domain, index)
    jitter = config.mu_jitter * (2.0 * rng.random() - 1.0)
    return max(base + jitter, 1e-6)


def _sighted_runtime_increment(
    config: CrossDomainConfig,
    rng: random.Random,
    domain: str,
    module_index: int,
) -> float:
    domain_bias = 1.0 + (0.04 if domain.startswith("ldpc") else -0.02)
    progressive = 1.0 + 0.03 * (module_index + 1) / max(config.modules, 1)
    jitter = 0.01 * (rng.random() - 0.5)
    return config.runtime_base * domain_bias * progressive + jitter


def _blind_runtime_increment(
    config: CrossDomainConfig,
    domain: str,
    module_index: int,
    mu_cumulative: float,
    runtime_cumulative: float,
) -> float:
    baseline = config.runtime_base * _domain_factor(domain, module_index)
    target_total = baseline * math.exp(config.runtime_scale * mu_cumulative)
    increment = target_total - runtime_cumulative
    return max(increment, baseline * 0.1)


def _destroyed_runtime_increment(
    config: CrossDomainConfig,
    rng: random.Random,
    domain: str,
    module_index: int,
    mu_cumulative: float,
    runtime_cumulative: float,
) -> float:
    baseline = config.runtime_base * _domain_factor(domain, module_index)
    target = baseline * (1.0 + 0.35 * mu_cumulative) + baseline * 0.15 * (
        (module_index + 1) / max(config.modules, 1)
    )
    jitter = 0.08 * (rng.random() - 0.5)
    increment = target - runtime_cumulative
    return max(increment, baseline * 0.08)


def _runtime_increment(
    config: CrossDomainConfig,
    rng: random.Random,
    domain: str,
    module_index: int,
    mu_cumulative: float,
    runtime_cumulative: float,
) -> float:
    protocol = config.protocol
    if protocol == "sighted":
        return _sighted_runtime_increment(config, rng, domain, module_index)
    if protocol == "blind":
        return _blind_runtime_increment(config, domain, module_index, mu_cumulative, runtime_cumulative)
    if protocol == "destroyed":
        return _destroyed_runtime_increment(
            config, rng, domain, module_index, mu_cumulative, runtime_cumulative
        )
    raise ValueError(f"Unsupported protocol: {protocol}")


def _structure_integrity(protocol: str) -> float:
    try:
        return _STRUCTURE_MAP[protocol]
    except KeyError as exc:  # pragma: no cover - defensive branch
        raise ValueError(f"Unsupported protocol: {protocol}") from exc


def _simulate_trial(
    config: CrossDomainConfig,
    seed: int,
    domain_index: int,
    domain: str,
    trial_id: int,
) -> Tuple[List[MutableMapping[str, float | int | str]], float, float]:
    rng = random.Random(_trial_seed(seed, domain_index, trial_id))
    mu_cumulative = 0.0
    runtime_cumulative = 0.0
    structure = _structure_integrity(config.protocol)

    ledger_rows: List[MutableMapping[str, float | int | str]] = []
    for module_index in range(config.modules):
        mu_increment = _mu_increment(config, rng, domain, domain_index)
        mu_cumulative += mu_increment
        runtime_increment = _runtime_increment(
            config, rng, domain, module_index, mu_cumulative, runtime_cumulative
        )
        runtime_cumulative += runtime_increment
        ledger_rows.append(
            {
                "seed": seed,
                "domain": domain,
                "trial_id": trial_id,
                "protocol": config.protocol,
                "module_index": module_index,
                "mu_answer": mu_increment,
                "mu_cumulative": mu_cumulative,
                "runtime_increment": runtime_increment,
                "runtime_cumulative": runtime_cumulative,
                "structure_integrity": structure,
            }
        )

    return ledger_rows, mu_cumulative, runtime_cumulative


def _linear_regression(xs: Sequence[float], ys: Sequence[float]) -> Tuple[float, float, float]:
    if len(xs) < 2:
        return 0.0, 0.0, 0.0
    mean_x = sum(xs) / len(xs)
    mean_y = sum(ys) / len(ys)
    var_x = sum((x - mean_x) ** 2 for x in xs)
    if var_x == 0.0:
        return 0.0, mean_y, 0.0
    cov = sum((x - mean_x) * (y - mean_y) for x, y in zip(xs, ys))
    slope = cov / var_x
    intercept = mean_y - slope * mean_x
    rss = sum((y - (intercept + slope * x)) ** 2 for x, y in zip(xs, ys))
    if len(xs) > 2:
        variance = rss / (len(xs) - 2)
        se_slope = math.sqrt(variance / var_x)
    else:
        se_slope = 0.0
    return slope, intercept, se_slope


def _aic_from_rss(rss: float, n: int, k: int) -> float:
    if rss <= 1e-12:
        rss = 1e-12
    return n * math.log(rss / n) + 2 * k


def _domain_stats(mu_totals: Sequence[float], runtime_totals: Sequence[float]) -> DomainStats:
    slope, intercept, se_slope = _linear_regression(mu_totals, runtime_totals)
    n = len(mu_totals)
    slope_ci_low = slope - 1.96 * se_slope
    slope_ci_high = slope + 1.96 * se_slope

    if n >= 2:
        preds_poly = [intercept + slope * x for x in mu_totals]
        rss_poly = sum((y - p) ** 2 for y, p in zip(runtime_totals, preds_poly))
    else:
        rss_poly = 1e-12

    # Exponential fit via log-linear regression.
    positive_runtime = [max(y, 1e-9) for y in runtime_totals]
    log_y = [math.log(y) for y in positive_runtime]
    exp_slope, log_alpha, _ = _linear_regression(mu_totals, log_y)
    preds_exp = [math.exp(log_alpha + exp_slope * x) for x in mu_totals]
    rss_exp = sum((y - p) ** 2 for y, p in zip(runtime_totals, preds_exp))

    aic_poly = _aic_from_rss(rss_poly, max(n, 1), 2)
    aic_exp = _aic_from_rss(rss_exp, max(n, 1), 2)
    delta_aic = aic_poly - aic_exp

    return DomainStats(
        slope=slope,
        slope_ci_low=slope_ci_low,
        slope_ci_high=slope_ci_high,
        aic_exponential=aic_exp,
        aic_polynomial=aic_poly,
        delta_aic=delta_aic,
    )


def _summaries_from_rows(
    rows: Sequence[Mapping[str, float | int | str]]
) -> List[CrossDomainTrialSummary]:
    grouped: Dict[Tuple[int, str, int], List[Mapping[str, float | int | str]]] = {}
    for row in rows:
        key = (int(row["seed"]), str(row["domain"]), int(row["trial_id"]))
        grouped.setdefault(key, []).append(row)

    mu_totals_by_domain: Dict[str, List[float]] = {}
    runtime_totals_by_domain: Dict[str, List[float]] = {}
    integrity_by_domain: Dict[str, float] = {}

    trial_totals: Dict[Tuple[int, str, int], Tuple[float, float]] = {}
    for key, ledger_rows in grouped.items():
        sorted_rows = sorted(ledger_rows, key=lambda item: int(item["module_index"]))
        final_row = sorted_rows[-1]
        mu_total = float(final_row["mu_cumulative"])
        runtime_total = float(final_row["runtime_cumulative"])
        domain = str(final_row["domain"])
        mu_totals_by_domain.setdefault(domain, []).append(mu_total)
        runtime_totals_by_domain.setdefault(domain, []).append(runtime_total)
        integrity_by_domain[domain] = float(final_row.get("structure_integrity", 0.0))
        trial_totals[key] = (mu_total, runtime_total)

    domain_stats: Dict[str, DomainStats] = {}
    for domain, mu_values in mu_totals_by_domain.items():
        domain_stats[domain] = _domain_stats(mu_values, runtime_totals_by_domain[domain])

    summaries: List[CrossDomainTrialSummary] = []
    for key in sorted(trial_totals):
        seed, domain, trial_id = key
        mu_total, runtime_total = trial_totals[key]
        stats = domain_stats[domain]
        summaries.append(
            CrossDomainTrialSummary(
                seed=seed,
                domain=domain,
                trial_id=trial_id,
                protocol=str(rows[0]["protocol"]) if rows else "unknown",
                mu_total_bits=mu_total,
                runtime_total=runtime_total,
                domain_slope=stats.slope,
                domain_slope_ci_low=stats.slope_ci_low,
                domain_slope_ci_high=stats.slope_ci_high,
                domain_aic_exponential=stats.aic_exponential,
                domain_aic_polynomial=stats.aic_polynomial,
                domain_delta_aic=stats.delta_aic,
                structure_integrity=integrity_by_domain.get(domain, 0.0),
            )
        )
    return summaries


def execute(config: CrossDomainConfig) -> RunResult:
    ledger_rows: List[MutableMapping[str, float | int | str]] = []
    for domain_index, domain in enumerate(config.domains):
        for seed in config.seeds:
            for trial_id in range(config.trials_per_condition):
                trial_rows, mu_total, runtime_total = _simulate_trial(
                    config, seed, domain_index, domain, trial_id
                )
                ledger_rows.extend(trial_rows)

    summaries = _summaries_from_rows(ledger_rows)
    metadata: Dict[str, float | int | str] = {
        "protocol": config.protocol,
        "domains": list(config.domains),
        "modules": config.modules,
        "trials_per_condition": config.trials_per_condition,
        "seeds": list(config.seeds),
    }
    return RunResult(ledger_rows=ledger_rows, summaries=summaries, metadata=metadata)


def _replay_synthetic_ledger(path: Path) -> RunResult:
    entries = ledger_io.load_ledger(path)
    ledger_rows = [dict(entry.payload) for entry in entries]
    summaries = _summaries_from_rows(ledger_rows)
    metadata = {
        "protocol": "synthetic",
        "domains": sorted({row["domain"] for row in ledger_rows}),
        "modules": max((int(row["module_index"]) for row in ledger_rows), default=-1) + 1,
        "num_trials": len(summaries),
    }
    return RunResult(ledger_rows=ledger_rows, summaries=summaries, metadata=metadata)


def run_cross_domain(
    config: CrossDomainConfig, synthetic_ledger: Path | None = None
) -> RunResult:
    if synthetic_ledger is not None:
        return _replay_synthetic_ledger(synthetic_ledger)
    return execute(config)


def _write_summary(path: Path, summaries: Sequence[CrossDomainTrialSummary]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8", newline="") as handle:
        writer = csv.DictWriter(
            handle,
            fieldnames=[
                "seed",
                "domain",
                "trial_id",
                "protocol",
                "mu_total_bits",
                "runtime_total",
                "domain_slope",
                "domain_slope_ci_low",
                "domain_slope_ci_high",
                "domain_aic_exponential",
                "domain_aic_polynomial",
                "domain_delta_aic",
                "structure_integrity",
            ],
        )
        writer.writeheader()
        for summary in summaries:
            writer.writerow(summary.as_row())


def _write_metadata(path: Path, metadata: Dict[str, float | int | str], digest: str) -> None:
    payload = dict(metadata)
    payload["ledger_digest_sha256"] = digest
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as handle:
        json.dump(payload, handle, indent=2, sort_keys=True)
        handle.write("\n")


def _parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Phase C cross-domain echoes builder"
    )
    parser.add_argument("--output-dir", type=Path, required=True, help="Directory for artefacts")
    parser.add_argument(
        "--seeds", type=int, nargs="*", default=[0, 1, 2], help="Deterministic RNG seeds"
    )
    parser.add_argument(
        "--trials-per-condition",
        type=int,
        default=3,
        help="Trials per seed/domain pair",
    )
    parser.add_argument("--modules", type=int, default=6, help="Modules per trial")
    parser.add_argument(
        "--protocol",
        choices=["sighted", "blind", "destroyed"],
        default="sighted",
        help="Control protocol to simulate",
    )
    parser.add_argument(
        "--domains",
        nargs="*",
        default=["compression", "ldpc"],
        help="Domains to include in the run",
    )
    parser.add_argument("--mu-base", type=float, default=0.22, help="Base μ increment per module")
    parser.add_argument("--mu-jitter", type=float, default=0.04, help="μ jitter per module")
    parser.add_argument(
        "--runtime-base", type=float, default=1.0, help="Baseline runtime unit for sighted runs"
    )
    parser.add_argument(
        "--runtime-scale", type=float, default=0.6, help="Runtime scale factor for blind runs"
    )
    parser.add_argument(
        "--synthetic-ledger",
        type=Path,
        help="Replay an existing ledger instead of running the simulation",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> None:
    args = _parse_args(argv)
    output_dir: Path = args.output_dir
    config = CrossDomainConfig(
        output_dir=output_dir,
        seeds=args.seeds,
        trials_per_condition=args.trials_per_condition,
        modules=args.modules,
        protocol=args.protocol,
        domains=args.domains,
        mu_base=args.mu_base,
        mu_jitter=args.mu_jitter,
        runtime_base=args.runtime_base,
        runtime_scale=args.runtime_scale,
    )

    result = run_cross_domain(config, synthetic_ledger=args.synthetic_ledger)

    ledger_path = output_dir / "cross_domain_steps.jsonl"
    summary_path = output_dir / "cross_domain_summary.csv"
    metadata_path = output_dir / "cross_domain_metadata.json"

    ledger_io.dump_ledger(result.ledger_rows, ledger_path)
    digest = ledger_io.ledger_digest(ledger_io.load_ledger(ledger_path))
    _write_summary(summary_path, result.summaries)
    _write_metadata(metadata_path, result.metadata, digest)


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    main()
