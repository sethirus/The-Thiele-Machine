"""Landauer bit-erasure surrogate with deterministic logging.

This module provides the Builder implementation for Phase A1 of the
zero-trust experiment plan.  It simulates a four-state Ising surrogate
using a Metropolis kernel while a control parameter (``bias``) drives the
logical bit toward the ``0`` state.  Each trial emits stepwise μ-ledger
rows and a summary CSV so that Auditors can recompute all metrics and
validate the Landauer equality

    |⟨W⟩/(k_B·T·ln 2) − Σ μ_answer| ≤ ε.

The simulation is intentionally lightweight so that tests can run quickly,
but it preserves the structural requirements:

* deterministic seeds for every trial,
* explicit μ-ledger taps with per-step work contributions,
* CLI entry point that stores artefacts inside a run directory, and
* support for a ``--synthetic-ledger`` mode that replays precomputed
  traces without introducing hidden state.
"""

from __future__ import annotations

from dataclasses import dataclass
import argparse
import csv
import json
import math
from pathlib import Path
import random
from typing import Dict, Iterable, Iterator, List, MutableMapping, Sequence, Tuple

from . import ledger_io

K_BOLTZMANN = 1.0
LN2 = math.log(2.0)
TARGET_SPIN = -1  # logical "0" in the surrogate encoding


@dataclass(frozen=True)
class LandauerConfig:
    """Configuration parameters for a deterministic Landauer run."""

    output_dir: Path
    seeds: Sequence[int]
    temps: Sequence[float]
    trials_per_condition: int
    protocol: str = "sighted"
    steps: int = 48
    coupling: float = 0.7
    bias_final: float = LN2


@dataclass(frozen=True)
class TrialSummary:
    """Aggregated metrics for a single trial."""

    seed: int
    temperature: float
    trial_id: int
    protocol: str
    sum_mu_bits: float
    work: float

    @property
    def work_over_kTln2(self) -> float:
        return self.work / (K_BOLTZMANN * self.temperature * LN2)

    def as_row(self) -> Dict[str, str]:
        return {
            "seed": str(self.seed),
            "T": f"{self.temperature:.6f}",
            "trial_id": str(self.trial_id),
            "protocol": self.protocol,
            "sum_mu_bits": f"{self.sum_mu_bits:.10f}",
            "work": f"{self.work:.10f}",
            "work_over_kTln2": f"{self.work_over_kTln2:.10f}",
        }


@dataclass(frozen=True)
class RunResult:
    """Container for artefacts generated by :func:`execute`."""

    ledger_rows: List[MutableMapping[str, float | int | str]]
    summaries: List[TrialSummary]
    metadata: Dict[str, float | int | str]


def _energy(bit_spin: int, env_spin: int, bias: float, coupling: float) -> float:
    """Return the instantaneous energy of the surrogate system."""

    return (-bias * bit_spin) - (coupling * bit_spin * env_spin)


def _metropolis_flip(
    rng: random.Random,
    bit_spin: int,
    env_spin: int,
    bias: float,
    coupling: float,
    temperature: float,
    flip_env: bool,
) -> Tuple[int, int, float]:
    """Attempt to flip one of the spins and return the updated state and heat."""

    if flip_env:
        proposed_env = -env_spin
        delta_e = _energy(bit_spin, proposed_env, bias, coupling) - _energy(
            bit_spin, env_spin, bias, coupling
        )
        if delta_e <= 0.0 or rng.random() < math.exp(-delta_e / (K_BOLTZMANN * temperature)):
            return bit_spin, proposed_env, delta_e
        return bit_spin, env_spin, 0.0

    proposed_bit = -bit_spin
    delta_e = _energy(proposed_bit, env_spin, bias, coupling) - _energy(
        bit_spin, env_spin, bias, coupling
    )
    if delta_e <= 0.0 or rng.random() < math.exp(-delta_e / (K_BOLTZMANN * temperature)):
        return proposed_bit, env_spin, delta_e
    return bit_spin, env_spin, 0.0


def _bias_schedule(
    config: LandauerConfig,
    rng: random.Random,
    temperature: float,
) -> Iterator[float]:
    """Yield a deterministic control schedule for the selected protocol."""

    target = -config.bias_final * temperature
    if config.protocol == "sighted":
        for step in range(config.steps):
            yield target * (step + 1) / config.steps
    elif config.protocol == "blind":
        for _ in range(config.steps):
            yield 0.0
    elif config.protocol == "destroyed":
        # deterministic pseudo-random bias oscillations
        for _ in range(config.steps):
            yield rng.uniform(-abs(target), abs(target)) * 0.2
    else:
        raise ValueError(f"Unsupported protocol: {config.protocol}")


def _trial_seed(base_seed: int, temp_index: int, trial_id: int) -> int:
    """Derive a reproducible seed for each trial."""

    return base_seed * 10_000 + temp_index * 1_000 + trial_id


def _simulate_single_trial(
    config: LandauerConfig,
    seed: int,
    temp_index: int,
    temperature: float,
    trial_id: int,
) -> Tuple[List[MutableMapping[str, float | int | str]], TrialSummary]:
    trial_rng = random.Random(_trial_seed(seed, temp_index, trial_id))
    bit_spin = 1 if trial_rng.random() < 0.5 else -1
    env_spin = 1 if trial_rng.random() < 0.5 else -1
    bias_prev = 0.0
    cumulative_work = 0.0
    mu_cumulative = 0.0
    ledger_rows: List[MutableMapping[str, float | int | str]] = []

    schedule = list(_bias_schedule(config, trial_rng, temperature))

    for step_index, bias_target in enumerate(schedule):
        if mu_cumulative >= 1.0:
            bias = bias_prev
            control_work = 0.0
            heat = 0.0
        else:
            bias = bias_target
            control_work = -(bias - bias_prev) * bit_spin
            bias_prev = bias

            bit_spin, env_spin, heat_bit = _metropolis_flip(
                trial_rng,
                bit_spin,
                env_spin,
                bias,
                config.coupling,
                temperature,
                flip_env=False,
            )
            bit_spin, env_spin, heat_env = _metropolis_flip(
                trial_rng,
                bit_spin,
                env_spin,
                bias,
                config.coupling,
                temperature,
                flip_env=True,
            )

            heat = heat_bit + heat_env

        if control_work < 0.0:
            control_work = 0.0

        work_increment = control_work
        cumulative_work += work_increment

        mu_target = min(1.0, cumulative_work / (K_BOLTZMANN * temperature * LN2))
        if mu_target < 0.0:
            mu_target = 0.0
        mu_increment = max(0.0, mu_target - mu_cumulative)
        mu_cumulative += mu_increment

        ledger_rows.append(
            {
                "module": "landauer",
                "protocol": config.protocol,
                "seed": seed,
                "T": temperature,
                "trial_id": trial_id,
                "step": step_index,
                "bias": bias_prev,
                "bit_spin": bit_spin,
                "env_spin": env_spin,
                "mu_answer": mu_increment,
                "mu_cumulative": mu_cumulative,
                "delta_work": work_increment,
                "cumulative_work": cumulative_work,
                "heat": heat,
                "control_work": control_work,
            }
        )

    summary = TrialSummary(
        seed=seed,
        temperature=temperature,
        trial_id=trial_id,
        protocol=config.protocol,
        sum_mu_bits=mu_cumulative,
        work=cumulative_work,
    )
    return ledger_rows, summary


def execute(config: LandauerConfig) -> RunResult:
    """Run the Landauer surrogate and return deterministic artefacts."""

    ledger_rows: List[MutableMapping[str, float | int | str]] = []
    summaries: List[TrialSummary] = []

    for seed in config.seeds:
        for temp_index, temperature in enumerate(config.temps):
            for trial_id in range(config.trials_per_condition):
                trial_rows, summary = _simulate_single_trial(
                    config, seed, temp_index, temperature, trial_id
                )
                ledger_rows.extend(trial_rows)
                summaries.append(summary)

    metadata = {
        "k_B": K_BOLTZMANN,
        "ln2": LN2,
        "protocol": config.protocol,
        "steps": config.steps,
        "coupling": config.coupling,
        "bias_final": config.bias_final,
        "num_trials": len(summaries),
    }
    return RunResult(ledger_rows=ledger_rows, summaries=summaries, metadata=metadata)


def _write_summary_csv(path: Path, summaries: Sequence[TrialSummary]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8", newline="") as handle:
        writer = csv.DictWriter(
            handle,
            fieldnames=[
                "seed",
                "T",
                "trial_id",
                "protocol",
                "sum_mu_bits",
                "work",
                "work_over_kTln2",
            ],
        )
        writer.writeheader()
        for summary in summaries:
            writer.writerow(summary.as_row())


def _write_metadata(path: Path, metadata: Dict[str, float | int | str], digest: str) -> None:
    enriched = dict(metadata)
    enriched["ledger_digest_sha256"] = digest
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as handle:
        json.dump(enriched, handle, indent=2, sort_keys=True)
        handle.write("\n")


def _summaries_from_ledger(
    entries: Iterable[ledger_io.LedgerEntry],
) -> List[TrialSummary]:
    grouped: Dict[Tuple[int, float, int, str], Dict[str, float]] = {}
    for entry in entries:
        payload = entry.payload
        key = (
            int(payload["seed"]),
            float(payload["T"]),
            int(payload["trial_id"]),
            str(payload["protocol"]),
        )
        state = grouped.setdefault(
            key,
            {
                "mu_sum": 0.0,
                "work": 0.0,
            },
        )
        state["mu_sum"] += float(payload.get("mu_answer", 0.0))
        state["work"] = float(payload.get("cumulative_work", state["work"]))

    summaries: List[TrialSummary] = []
    for (seed, temperature, trial_id, protocol), state in grouped.items():
        summaries.append(
            TrialSummary(
                seed=seed,
                temperature=temperature,
                trial_id=trial_id,
                protocol=protocol,
                sum_mu_bits=state["mu_sum"],
                work=state["work"],
            )
        )
    summaries.sort(key=lambda item: (item.seed, item.temperature, item.trial_id))
    return summaries


def _replay_synthetic_ledger(path: Path) -> RunResult:
    entries = ledger_io.load_ledger(path)
    summaries = [
        TrialSummary(
            seed=item.seed,
            temperature=item.temperature,
            trial_id=item.trial_id,
            protocol="synthetic",
            sum_mu_bits=item.sum_mu_bits,
            work=item.work,
        )
        for item in _summaries_from_ledger(entries)
    ]
    metadata = {
        "k_B": K_BOLTZMANN,
        "ln2": LN2,
        "protocol": "synthetic",
        "steps": max(int(entry.payload.get("step", 0)) for entry in entries) + 1
        if entries
        else 0,
        "num_trials": len(summaries),
    }
    ledger_rows = [dict(entry.payload) for entry in entries]
    return RunResult(ledger_rows=ledger_rows, summaries=summaries, metadata=metadata)


def run_landauer(config: LandauerConfig, synthetic_ledger: Path | None = None) -> RunResult:
    if synthetic_ledger is not None:
        return _replay_synthetic_ledger(synthetic_ledger)
    return execute(config)


def _parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Landauer bit erasure runner")
    parser.add_argument("--output-dir", type=Path, required=True, help="Directory for artefacts")
    parser.add_argument(
        "--seeds", type=int, nargs="*", default=[0, 1, 2, 3, 4], help="Deterministic RNG seeds"
    )
    parser.add_argument(
        "--temps",
        type=float,
        nargs="*",
        default=[0.5, 1.0, 2.0],
        help="Temperature grid for the surrogate (dimensionless)",
    )
    parser.add_argument(
        "--trials-per-condition",
        type=int,
        default=50,
        help="Number of trials for each (seed, T) pair",
    )
    parser.add_argument(
        "--protocol",
        choices=["sighted", "blind", "destroyed"],
        default="sighted",
        help="Control protocol variant",
    )
    parser.add_argument(
        "--steps",
        type=int,
        default=48,
        help="Number of bias schedule steps per trial",
    )
    parser.add_argument(
        "--coupling", type=float, default=0.7, help="Spin coupling strength"
    )
    parser.add_argument(
        "--bias-final",
        type=float,
        default=float(LN2),
        help="Final magnitude of the control bias (positive value)",
    )
    parser.add_argument(
        "--synthetic-ledger",
        type=Path,
        default=None,
        help="Replay an existing ledger instead of simulating",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> None:
    args = _parse_args(argv)
    output_dir: Path = args.output_dir

    config = LandauerConfig(
        output_dir=output_dir,
        seeds=args.seeds,
        temps=args.temps,
        trials_per_condition=args.trials_per_condition,
        protocol=args.protocol,
        steps=args.steps,
        coupling=args.coupling,
        bias_final=args.bias_final,
    )

    result = run_landauer(config, synthetic_ledger=args.synthetic_ledger)

    ledger_path = output_dir / "landauer_steps.jsonl"
    summary_path = output_dir / "landauer_summary.csv"
    metadata_path = output_dir / "landauer_metadata.json"

    ledger_io.dump_ledger(result.ledger_rows, ledger_path)
    digest = ledger_io.ledger_digest(ledger_io.load_ledger(ledger_path))
    summaries = result.summaries
    _write_summary_csv(summary_path, summaries)
    _write_metadata(metadata_path, result.metadata, digest)


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    main()

