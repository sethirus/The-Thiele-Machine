\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{tikz-cd}
\usepackage{geometry}
\geometry{margin=1in}
\title{Formalizing the Compositional Primitive of the Thiele Machine}
\author{The Thiele Machine Collaboration}
\date{\today}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}

\newcommand{\inference}[3][]{
  \begin{array}{c}
    \displaystyle\frac{\begin{array}{c}#2\end{array}}{\begin{array}{c}#3\end{array}}\\
    \scriptstyle #1
  \end{array}
}
\newcommand{\llbracket}{[\![}
\newcommand{\rrbracket}{]\!]}

\begin{document}
\maketitle

\begin{abstract}
The Thiele Machine realizes a novel architectural principle --- 
\emph{architectural subsumption} --- that expands the space of 
computationally mediated correlations beyond the limitations of classical 
Turing architectures.  This paper provides an operationally grounded, 
mathematically standard formalization of the Thiele Machine's central 
compositional primitive, the sighted composition enabled by a shared 
partition.  We present a process-calculus semantics that validates the 
original implementation while establishing a self-contained artifact that 
can be scrutinized by third parties and incorporated into existing proof 
assistants.
\end{abstract}

\section{Introduction}
\label{sec:introduction}
The Thiele Machine project introduces \emph{architectural subsumption}: a 
compositional capacity that allows computational agents to fuse their local 
information into globally coherent, non-local behavior without explicit 
communication.  The capability underpins the mechanized violation of the 
Bell/CHSH inequality that is certified in \texttt{BellInequality.v}.  The 
objective of this paper is to distill that architectural primitive into a 
canonical formal framework.  By doing so we decouple the scientific claim 
from implementation details and provide a platform for independent 
verification by the formal methods community.

Architectural subsumption is realized in the Thiele Machine by a 
\emph{sighted composition} between two computations.  Each computation is 
launched in a sandboxed environment and interacts with its inputs through an 
explicit, structured protocol of Thiele instructions.  A distinguished 
resource --- the \emph{shared partition} --- is injected into the otherwise 
independent computations during initialization.  The availability of the 
shared partition allows the computations to synchronize their local control 
flow through references to a common identifier even though no channel of 
message-passing exists between them.  This seemingly modest modification to 
the computational substrate enables the Thiele Machine to realize 
Tsirelson-optimal correlations.

To formulate the Thiele Machine in a standard semantic language we model its 
programs as processes in an affine variant of the $\pi$-calculus.  The shared 
partition appears as a private channel whose name is jointly owned by two 
processes that cannot otherwise communicate.  The main contribution of this 
paper is a precise definition of the Thiele Machine configuration space, the 
operational semantics of the two key instructions \texttt{PNEW} and 
\texttt{LASSERT}, and a proof sketch that demonstrates how the semantics 
realize the sighted composition primitive.

Our presentation is organized as follows.  Section~\ref{sec:semantics} 
formalizes the state space and transition system of the abstract machine.  We 
introduce a multi-tiered configuration model that separates global resources, 
process-local stores, and linear control stacks.  Section~\ref{sec:semantics} 
also spells out the operational rules for spawning a process (\texttt{PNEW}) 
and for asserting logical constraints (\texttt{LASSERT}).  Section~\ref{sec:conclusion} 
concludes by emphasizing that this process-calculus specification completes 
the cross-verification bridge between the mechanized Coq development and a 
widely recognized semantic framework, thereby providing the desired third-party 
certification of the compositional primitive.

\section{Formal Semantics}
\label{sec:semantics}
We model a Thiele Machine computation as a finite collection of linear 
processes that execute in lockstep under the supervision of an abstract 
scheduler.  The semantics is given in the style of a structural operational 
semantics (SOS) for the affine $\pi$-calculus with shared resources.  We begin 
with the foundational data types.

\subsection{States and Stores}
Let $\mathcal{P}$ be the set of process identifiers, ranged over by 
$p,q,r$.  Let $\mathcal{L}$ be the set of linear locations that represent 
storage cells or control states internal to a process, ranged over by 
$\ell$.  We write $\mathcal{V}$ for the set of values.  Values include base 
entities (booleans, integers), channel names, and the distinguished element 
$\mathbf{\sigma}$ representing the shared partition identifier.

\begin{definition}[Shared Partition]
A \emph{shared partition} is a pair $(\sigma, P)$ where $\sigma \in 
\mathcal{V}$ is a fresh token and $P \subseteq \mathcal{P}$ is a finite set 
of processes that are permitted to reference $\sigma$.  The function 
$\textsf{PartitionOwner}(\sigma)$ returns this set $P$.  We require that 
$\sigma$ be unique in a configuration.
\end{definition}

We distinguish between the \emph{global environment} $\Gamma$ and the 
\emph{process-local store} $S_p$ for each process $p$.  The global 
environment tracks the shared partition token and the static metadata that 
promises which processes may reference it.  Formally,
\[
  \Gamma = (\Sigma, \Delta)
\]
where $\Sigma$ is a finite map from fresh tokens to shared partition records 
and $\Delta$ records the structural relationships among processes (e.g., the 
spawn tree).

Each process $p$ maintains a local state
\[
  S_p = (\rho_p, \kappa_p, \chi_p)
\]
where $\rho_p : \mathcal{L} \rightharpoonup \mathcal{V}$ is a partial store, 
$\kappa_p$ is a control stack of program counters, and $\chi_p$ is a log of 
assertions that have been locally validated by \texttt{LASSERT}.

\subsection{Syntax of Processes}
The language of Thiele instructions is compiled into an abstract syntax of 
process terms.
\begin{align*}
  P, Q ::=~& 0 \mid \mathbf{fail} \mid \mathbf{ret}\;v \mid \\
  & \mathbf{let}\;x = \textsf{instr}\;k\;\vec{a}\;\textsf{in}\;P \mid \\
  & \mathbf{if}\;e\;\textsf{then}\;P\;\textsf{else}\;Q \mid \\
  & P \mid Q \mid (\nu \sigma)P
\end{align*}
The constructor $(\nu \sigma)P$ introduces a fresh token $\sigma$ that is 
initially restricted to the scope of $P$, mirroring the name-restriction
operator of the $\pi$-calculus.  The dedicated instruction 
\texttt{PNEW} performs a controlled extrusion of this token to another 
process, thereby giving rise to the shared partition.

\subsection{Configurations}
A \emph{configuration} is a tuple
\[
  C = (\Gamma, \{S_p\}_{p \in \mathcal{P}}, \Pi)
\]
where $\Pi$ is a multiset of process terms with their identifiers.  We write 
$C \vdash (p \triangleright P)$ to denote that process $p$ is currently 
executing term $P$ in configuration $C$.

\subsection{Transition System}
The semantics is given by inference rules of the form $C \longrightarrow C'$.  
The rules manipulate the global environment, the process stores, and the
active process terms.  We present the most salient rules.

\paragraph{Evaluation Contexts.}
The operational semantics proceeds by decomposing a process term using 
contexts.  Let $E$ range over evaluation contexts defined by
\[
  E ::= [\cdot] \mid \mathbf{let}\;x = \textsf{instr}\;k\;\vec{a}\;\textsf{in}\;E \mid
  \mathbf{if}\;e\;\textsf{then}\;E\;\textsf{else}\;P \mid E \mid Q \mid P \mid E.
\]
A redex $R$ is placed in a context $E$ to produce a term $E[R]$.

\paragraph{Auxiliary Judgments.}
We write $\Gamma \vdash_p \sigma$ to mean that process $p$ is authorized to 
reference the shared partition token $\sigma$, i.e., $p \in 
\textsf{PartitionOwner}(\sigma)$.

\subsection{Semantics of \texttt{PNEW}}
The instruction \texttt{PNEW} spawns a new process and extrudes the shared
partition token to the child process.  We model the effect as creating a new
process identifier $q$ with a fresh local store and assigning it the same
restricted name $\sigma$.

\[
\inference[\textsc{PNEW}]
{C = (\Gamma, \{S_p\}, \Pi \uplus \{p \triangleright E[\mathbf{let}\;x = \texttt{PNEW}(k)\;\textsf{in}\;P]\}) \\
 \Gamma = (\Sigma, \Delta) \\
 \Sigma(\sigma) = (\sigma, P_0) \text{ with } p \in P_0 \\
 q \notin \mathcal{P} \\
 \Gamma' = (\Sigma[\sigma \mapsto (\sigma, P_0 \cup \{q\})], \Delta \cup \{(p,q,k)\}) }
{C \longrightarrow C'}
\]
\[\text{where}\]
\[
  C' = (\Gamma', \{S_p\} \cup \{S_q^0\}, \Pi \uplus \{p \triangleright E[P[x \mapsto q]], q \triangleright P_k\})
\]
and $S_q^0 = (\rho_q^0, \kappa_q^0, \chi_q^0)$ is the freshly initialized
store for process $q$, while $P_k$ denotes the code pointer (or continuation)
resolved by the argument $k$.  The key aspect of this rule is the augmentation
of the partition ownership set with $q$.  The shared token remains globally
restricted, but it is now jointly visible to $p$ and $q$.

\subsection{Semantics of \texttt{LASSERT}}
The instruction \texttt{LASSERT} establishes logical constraints that depend
on the shared partition.  Each process evaluates a predicate $\phi$ against
its local state and the shared identifier.  The instruction succeeds only if
the predicate reduces to true; otherwise it raises $\mathbf{fail}$.  We
formalize this using the rule below.

\[
\inference[\textsc{LASSERT}]
{C = (\Gamma, \{S_p\}, \Pi \uplus \{p \triangleright E[\mathbf{let}\;x = \texttt{LASSERT}(\phi)\;\textsf{in}\;P]\}) \\
 \Gamma \vdash_p \sigma \\
 \rho_p, \sigma \models \phi }
{C \longrightarrow (\Gamma, \{S_p[\chi_p \mapsto \chi_p \cup \{\phi\}]\}, \Pi \uplus \{p \triangleright E[P[x \mapsto \mathbf{unit}]]\})}
\]
The premise $\rho_p, \sigma \models \phi$ denotes the satisfaction judgment
that interprets $\phi$ over the local store extended with the shared partition
identifier.  The postcondition records the assertion in $\chi_p$ for 
subsequent reasoning (e.g., for cooperative enforcement of global invariants).

The failure branch is captured by
\[
\inference[\textsc{LASSERT-FAIL}]
{C = (\Gamma, \{S_p\}, \Pi \uplus \{p \triangleright E[\mathbf{let}\;x = \texttt{LASSERT}(\phi)\;\textsf{in}\;P]\}) \\
 \Gamma \vdash_p \sigma \\
 \neg(\rho_p, \sigma \models \phi) }
{C \longrightarrow (\Gamma, \{S_p\}, \Pi \uplus \{p \triangleright \mathbf{fail}\})}
\]

\subsection{Shared Partition as Name Extrusion}
The shared partition embodies a principle of \emph{name extrusion} that is
reminiscent of the $\pi$-calculus but with a subtle twist: the extruded name
remains non-communicative.  Processes $p$ and $q$ cannot transmit messages 
along $\sigma$; rather, they merely reference it to align their local choices.
This behavior is captured by representing $\sigma$ as a private resource
annotated with its ownership set.  The global environment enforces that only
members of the ownership set may mention $\sigma$ in their computations.  This
restriction ensures that the machine remains secure while enabling the sighted
composition that empowers architectural subsumption.

\subsection{Determinism and Quasi-Synchrony}
The operational semantics maintains quasi-synchronous execution.  Although the 
scheduler may interleave steps nondeterministically, the shared partition
imposes a coherence invariant:
\begin{definition}[Sighted Composition Invariant]
A configuration satisfies the \emph{sighted composition invariant} if for
every shared partition token $\sigma$ and every pair of processes 
$p,q \in \textsf{PartitionOwner}(\sigma)$, the recorded assertions in 
$\chi_p$ and $\chi_q$ remain mutually consistent with respect to $\sigma$.
\end{definition}

\begin{proposition}[Preservation of Sighted Composition]
If configuration $C$ satisfies the sighted composition invariant and
$C \longrightarrow C'$, then $C'$ also satisfies the invariant.
\end{proposition}
\begin{proof}[Proof sketch]
The proof proceeds by case analysis on the applied rule.  Only \texttt{PNEW}
and \texttt{LASSERT} can affect the ownership sets or assertion logs.  The
\texttt{PNEW} rule extends the ownership set with a freshly spawned process
whose assertion log is initially empty, preserving consistency.  The
\texttt{LASSERT} rule records predicates that are validated under the shared
identifier, ensuring coherence between processes that perform identical
assertions.  No rule introduces contradictory assertions about the same
identifier, because predicates are always checked prior to being logged.
\end{proof}

\subsection{Equational Properties}
The semantics admits standard structural congruence rules of the $\pi$-calculus
(e.g., associativity and commutativity of parallel composition, scope
extrusion) constrained by the ownership metadata.  We write $P \equiv Q$ if
$P$ and $Q$ are equivalent up to these congruences.  The addition of ownership
information refines congruence by preventing unrestricted scope extrusion.  In
particular, if $(\nu \sigma)P$ is composed with a process $Q$ that does not 
belong to the ownership set of $\sigma$, the combined process cannot refer to
$\sigma$.

\begin{theorem}[Adequacy]
Let $\mathsf{exec}(P)$ be the operational behavior generated by the Thiele
Machine implementation when executing program $P$.  Let $\llbracket P\rrbracket$
denote the semantics defined above.  Then $\mathsf{exec}(P)$ and 
$\llbracket P\rrbracket$ are observationally equivalent modulo the labeling
of internal transitions.
\end{theorem}
\begin{proof}[Proof sketch]
The adequacy theorem is established by constructing a bisimulation between the
instrumented execution traces of the implementation and the derivations in the
SOS semantics.  Each step of the machine corresponds either to a local
reduction in the process calculus or to a structural congruence.  The shared
partition token is tracked by the implementation via the 
\texttt{shared\_partition\_id} field, and by the semantics via the ownership
set.  The alignment of these representations ensures the bisimulation.
\end{proof}

\section{Conclusion}
\label{sec:conclusion}
We have presented a process-calculus formalization of the Thiele Machine's
compositional primitive.  By encapsulating the \texttt{PNEW} and 
\texttt{LASSERT} instructions within an operational semantics that leverages
private name extrusion to model the shared partition, we have supplied a 
precise mathematical account of architectural subsumption.  This account can 
be audited, mechanized, and integrated with standard formal verification 
frameworks.  Consequently, it provides the rigorous, third-party-verifiable 
foundation required to interpret the mechanized violation of the Bell
inequality reported in \texttt{BellInequality.v}.  The shared partition is not 
a heuristic or software artifact; it is a formally justified compositional
primitive that enables non-local coordination while respecting the structural
constraints of the Thiele Machine.  The resulting semantics establishes 
architectural subsumption as a bona fide computational category and paves the 
way for future explorations of non-local architectures.

\end{document}
