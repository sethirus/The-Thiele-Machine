[
  {
    "step": 2,
    "instruction": {
      "op": "PNEW",
      "payload": [
        1,
        2
      ]
    },
    "pre_state": {
      "pc": 0,
      "status": 0,
      "mu_acc": 0,
      "cert_addr": ""
    },
    "post_state": {
      "pc": 1,
      "status": 0,
      "mu_acc": 0,
      "cert_addr": ""
    },
    "observation": {
      "event": {
        "tag": "InferenceComplete"
      },
      "mu_delta": 0,
      "cert": {
        "smt_query": "",
        "solver_reply": "",
        "metadata": "",
        "timestamp": 0,
        "sequence": 0
      }
    },
    "pre_state_hash": "3be4ab3e30347c3b36b3c176e39c564d8b2e1e6c6f816f53070d67ed3cd381f4",
    "post_state_hash": "2e59cea3b3cf0e0427b5d1025581d2f165a69235777b0cabab6bdd7773234376",
    "signature": "5975d6d5ced2dcd583ddbd10049ac4885905eada34b85bbafdb6e760fa6c602a87d8c9d9bb2cfeffdb655f8acb59183173cab7ef5de200c9373477c4f8249709"
  },
  {
    "step": 4,
    "instruction": {
      "op": "PYEXEC",
      "payload": "\nimport json\nfrom fractions import Fraction\n\nstrategy = 'tsirelson'\nseed = int(1337)\nn_per_setting = int(2000)\n\n# Supra-quantum 16/5 distribution used in demos/demo_chsh_game.py\nSUPRA_PROBS = {\n    # (x, y, a, b): (numerator, denominator)\n    (0, 0, 0, 0): (1, 5),\n    (0, 0, 1, 1): (1, 5),\n    (0, 0, 0, 1): (3, 10),\n    (0, 0, 1, 0): (3, 10),\n\n    (0, 1, 0, 0): (1, 2),\n    (0, 1, 1, 1): (1, 2),\n    (0, 1, 0, 1): (0, 1),\n    (0, 1, 1, 0): (0, 1),\n\n    (1, 0, 0, 0): (1, 2),\n    (1, 0, 1, 1): (1, 2),\n    (1, 0, 0, 1): (0, 1),\n    (1, 0, 1, 0): (0, 1),\n\n    (1, 1, 0, 0): (1, 2),\n    (1, 1, 1, 1): (1, 2),\n    (1, 1, 0, 1): (0, 1),\n    (1, 1, 1, 0): (0, 1),\n}\n\n\ndef _allocate_counts(outcome_weights, n):\n    \"\"\"Allocate integer counts summing to n from Fraction weights.\"\"\"\n    floors = {}\n    remainders = []\n    allocated = 0\n    for outcome, w in outcome_weights.items():\n        target = w * n\n        base = int(target)  # floor\n        floors[outcome] = base\n        allocated += base\n        remainders.append((target - base, outcome))\n    left = n - allocated\n    remainders.sort(key=lambda t: (t[0], t[1]), reverse=True)\n    for i in range(left):\n        floors[remainders[i][1]] += 1\n    return floors\n\n\ndef _weights_for_setting(x, y):\n    if strategy == \"lhv\":\n        return {(0, 0): Fraction(1, 1), (0, 1): Fraction(0, 1), (1, 0): Fraction(0, 1), (1, 1): Fraction(0, 1)}\n\n    if strategy == \"supra_16_5\":\n        weights = {}\n        for a in (0, 1):\n            for b in (0, 1):\n                num, denom = SUPRA_PROBS.get((x, y, a, b), (0, 1))\n                weights[(a, b)] = Fraction(int(num), int(denom))\n        return weights\n\n    if strategy == \"tsirelson\":\n        # Repo CHSH convention witness:\n        #   S = E(1,1)+E(1,0)+E(0,1)-E(0,0)\n        # Use E(0,0)=-e and others +e.\n        e = Fraction(707, 1000)\n        expectation = -e if (x == 0 and y == 0) else e\n\n        # Choose integer counts of \"same\" vs \"different\" outcomes to enforce\n        # the correlator exactly at this n.\n        n = n_per_setting\n        n_same = 1707 if expectation >= 0 else (n - 1707)\n        n_diff = n - n_same\n\n        same0 = n_same // 2\n        same1 = n_same - same0\n        diff0 = n_diff // 2\n        diff1 = n_diff - diff0\n        return {\n            (0, 0): Fraction(same0, n),\n            (1, 1): Fraction(same1, n),\n            (0, 1): Fraction(diff0, n),\n            (1, 0): Fraction(diff1, n),\n        }\n\n    if strategy == \"pr\":\n        # PR-like box for the repo's CHSH convention:\n        # anti-correlated at (0,0), correlated elsewhere.\n        if x == 0 and y == 0:\n            return {(0, 1): Fraction(1, 2), (1, 0): Fraction(1, 2), (0, 0): Fraction(0, 1), (1, 1): Fraction(0, 1)}\n        return {(0, 0): Fraction(1, 2), (1, 1): Fraction(1, 2), (0, 1): Fraction(0, 1), (1, 0): Fraction(0, 1)}\n\n    raise RuntimeError(\"unknown strategy\")\n\n\ncounts = {}\nfor x in (0, 1):\n    for y in (0, 1):\n        weights = _weights_for_setting(x, y)\n        allocated = _allocate_counts(weights, n_per_setting)\n        for (a, b), c in allocated.items():\n            if c:\n                key = f\"{x},{y},{a},{b}\"\n                counts[key] = int(counts.get(key, 0)) + int(c)\n\npayload = {\n    \"n_per_setting\": n_per_setting,\n    \"seed\": seed,\n    \"strategy\": strategy,\n    \"counts\": counts,\n}\n\nwith open('artifacts/bell/operational_runs/20251215_193215/tsirelson/dataset.json', \"w\", encoding=\"utf-8\") as f:\n    json.dump(payload, f, sort_keys=True)\n"
    },
    "pre_state": {
      "pc": 1,
      "status": 0,
      "mu_acc": 0,
      "cert_addr": ""
    },
    "post_state": {
      "pc": 2,
      "status": 0,
      "mu_acc": 0,
      "cert_addr": ""
    },
    "observation": {
      "event": {
        "tag": "PolicyCheck",
        "value": "\nimport json\nfrom fractions import Fraction\n\nstrategy = 'tsirelson'\nseed = int(1337)\nn_per_setting = int(2000)\n\n# Supra-quantum 16/5 distribution used in demos/demo_chsh_game.py\nSUPRA_PROBS = {\n    # (x, y, a, b): (numerator, denominator)\n    (0, 0, 0, 0): (1, 5),\n    (0, 0, 1, 1): (1, 5),\n    (0, 0, 0, 1): (3, 10),\n    (0, 0, 1, 0): (3, 10),\n\n    (0, 1, 0, 0): (1, 2),\n    (0, 1, 1, 1): (1, 2),\n    (0, 1, 0, 1): (0, 1),\n    (0, 1, 1, 0): (0, 1),\n\n    (1, 0, 0, 0): (1, 2),\n    (1, 0, 1, 1): (1, 2),\n    (1, 0, 0, 1): (0, 1),\n    (1, 0, 1, 0): (0, 1),\n\n    (1, 1, 0, 0): (1, 2),\n    (1, 1, 1, 1): (1, 2),\n    (1, 1, 0, 1): (0, 1),\n    (1, 1, 1, 0): (0, 1),\n}\n\n\ndef _allocate_counts(outcome_weights, n):\n    \"\"\"Allocate integer counts summing to n from Fraction weights.\"\"\"\n    floors = {}\n    remainders = []\n    allocated = 0\n    for outcome, w in outcome_weights.items():\n        target = w * n\n        base = int(target)  # floor\n        floors[outcome] = base\n        allocated += base\n        remainders.append((target - base, outcome))\n    left = n - allocated\n    remainders.sort(key=lambda t: (t[0], t[1]), reverse=True)\n    for i in range(left):\n        floors[remainders[i][1]] += 1\n    return floors\n\n\ndef _weights_for_setting(x, y):\n    if strategy == \"lhv\":\n        return {(0, 0): Fraction(1, 1), (0, 1): Fraction(0, 1), (1, 0): Fraction(0, 1), (1, 1): Fraction(0, 1)}\n\n    if strategy == \"supra_16_5\":\n        weights = {}\n        for a in (0, 1):\n            for b in (0, 1):\n                num, denom = SUPRA_PROBS.get((x, y, a, b), (0, 1))\n                weights[(a, b)] = Fraction(int(num), int(denom))\n        return weights\n\n    if strategy == \"tsirelson\":\n        # Repo CHSH convention witness:\n        #   S = E(1,1)+E(1,0)+E(0,1)-E(0,0)\n        # Use E(0,0)=-e and others +e.\n        e = Fraction(707, 1000)\n        expectation = -e if (x == 0 and y == 0) else e\n\n        # Choose integer counts of \"same\" vs \"different\" outcomes to enforce\n        # the correlator exactly at this n.\n        n = n_per_setting\n        n_same = 1707 if expectation >= 0 else (n - 1707)\n        n_diff = n - n_same\n\n        same0 = n_same // 2\n        same1 = n_same - same0\n        diff0 = n_diff // 2\n        diff1 = n_diff - diff0\n        return {\n            (0, 0): Fraction(same0, n),\n            (1, 1): Fraction(same1, n),\n            (0, 1): Fraction(diff0, n),\n            (1, 0): Fraction(diff1, n),\n        }\n\n    if strategy == \"pr\":\n        # PR-like box for the repo's CHSH convention:\n        # anti-correlated at (0,0), correlated elsewhere.\n        if x == 0 and y == 0:\n            return {(0, 1): Fraction(1, 2), (1, 0): Fraction(1, 2), (0, 0): Fraction(0, 1), (1, 1): Fraction(0, 1)}\n        return {(0, 0): Fraction(1, 2), (1, 1): Fraction(1, 2), (0, 1): Fraction(0, 1), (1, 0): Fraction(0, 1)}\n\n    raise RuntimeError(\"unknown strategy\")\n\n\ncounts = {}\nfor x in (0, 1):\n    for y in (0, 1):\n        weights = _weights_for_setting(x, y)\n        allocated = _allocate_counts(weights, n_per_setting)\n        for (a, b), c in allocated.items():\n            if c:\n                key = f\"{x},{y},{a},{b}\"\n                counts[key] = int(counts.get(key, 0)) + int(c)\n\npayload = {\n    \"n_per_setting\": n_per_setting,\n    \"seed\": seed,\n    \"strategy\": strategy,\n    \"counts\": counts,\n}\n\nwith open('artifacts/bell/operational_runs/20251215_193215/tsirelson/dataset.json', \"w\", encoding=\"utf-8\") as f:\n    json.dump(payload, f, sort_keys=True)\n"
      },
      "mu_delta": 0,
      "cert": {
        "smt_query": "",
        "solver_reply": "",
        "metadata": "",
        "timestamp": 0,
        "sequence": 0
      }
    },
    "pre_state_hash": "2e59cea3b3cf0e0427b5d1025581d2f165a69235777b0cabab6bdd7773234376",
    "post_state_hash": "15713ac6773c4903303bd6ba812422142bcbd5b39ba256b43969353ac4f47f59",
    "signature": "ca2190540899608a5192ddc79a6991ae233dbb4109346529fd653b004c58edc702df839876bf1f7aa8399a3fb4963b4e6749cb7d7907385db24b52093fd5b903"
  },
  {
    "step": 6,
    "instruction": {
      "op": "EMIT",
      "payload": "done"
    },
    "pre_state": {
      "pc": 2,
      "status": 0,
      "mu_acc": 0,
      "cert_addr": ""
    },
    "post_state": {
      "pc": 3,
      "status": 0,
      "mu_acc": 0,
      "cert_addr": ""
    },
    "observation": {
      "event": {
        "tag": "ErrorOccurred",
        "value": "done"
      },
      "mu_delta": 0,
      "cert": {
        "smt_query": "",
        "solver_reply": "",
        "metadata": "",
        "timestamp": 0,
        "sequence": 0
      }
    },
    "pre_state_hash": "15713ac6773c4903303bd6ba812422142bcbd5b39ba256b43969353ac4f47f59",
    "post_state_hash": "6295c09d07120cab3fa48d4f08d9b07a275c79d0d10d9ba5f2b858f670f25c59",
    "signature": "f540a925484af18f251458a3bff146173c68815515f981d3aa6f18ffc4fb7dbce68173b722bad01b5806246115739599d701cc767a3c976dab14240d77efa607"
  }
]