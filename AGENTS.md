# Repository Instructions

- Before running Coq-related commands in this repository, always ensure that the Coq toolchain is installed and loaded in the environment.
- Continue working on requested tasks with the assumption that Coq should be available; install or load it when necessary before attempting proofs or builds.

---
## Mission Protocol: Operation Bedrock

**Objective:** Eliminate all remaining `Axiom` declarations from `ThieleUniversal.v` by replacing them with fully mechanized proofs, resulting in a compiled, `admit`-free, `axiom`-free file.

**Overarching Strategy:** The two remaining axioms, `pc_29_implies_registers_from_rule_table` and `find_rule_from_memory_components`, are consequences of the interpreter's find-rule search loop. We will prove a loop invariant for this search. This invariant will serve as the foundational lemma from which the two final proofs can be derived mechanically.

### Phase 3: Prove the Find-Rule Loop Invariant

**Status:** COMPLETE

**Tactical Plan:**
1.  Define a lemma `find_rule_loop_preserves_inv` that formalizes one iteration of the find-rule loop (PC 4-11).
2.  The proof will proceed by symbolic execution of this single loop iteration.
3.  Use targeted `assert` and `pose proof` for each instruction step, avoiding expansive `simpl` tactics.
4.  A case analysis on the `Jz` instruction at PC 7 will split the proof into two branches: one where a rule is found, and one where the loop continues.
5.  This lemma will become the inductive step in a larger proof about the entire `run_n` execution of the find-rule phase.

### Phase 4: Slay the Final Axioms

**Status:** IN PROGRESS

**Tactical Plan:**
1.  **Prove `pc_29_implies_registers_from_rule_table`:** This will be proven by applying the `find_rule_loop_preserves_inv` lemma inductively to show that after `i` iterations, `REG_ADDR` points to the correct rule, and that the subsequent instructions (PC 22-28) correctly load the rule components into the registers.
2.  **Prove `find_rule_from_memory_components`:** This will be proven by induction on the rule list, showing that the `find_rule` function's logic matches the properties established by the loop invariant and the register state.

### Field Report (Current Status)

**Progress:**
- Matching branch: fully symbolically executes PCs 4–29 and discharges the `Some` path with the precise `run_n st 17` witness.
- Q-mismatch branch: closed the 6-step continuation by introducing the explicit `rule_table_q_monotone` hypothesis, deriving the non-zero guard via `nat_eqb_sub_zero_false_of_lt`, and re-establishing `find_rule_loop_inv` at index `S i`.
- Symbol-mismatch branch: completed the 13-step continuation through PCs 18–21, restored `find_rule_loop_inv` at `S i`, and unified the case analysis into a single proof of `find_rule_loop_preserves_inv`.

**Immediate Next Steps:**
1. Finish mechanizing `pc_29_implies_registers_from_rule_table` by replaying the loop-invariant witnesses, reconstructing the pre-apply state at PC 28, and extracting the matching rule index.
2. Prove concrete instantiations of `rule_table_q_monotone` and `rule_table_symbol_monotone` from the encoder so `find_rule_loop_preserves_inv` can be applied without additional hypotheses.
3. Once the register lemma is complete, carry the reasoning into `find_rule_from_memory_components` and fold the monotonicity lemmas into `UTM_CoreLemmas` as shared utilities.

**Outstanding Insight:**
- The monotonicity obligations are now explicit hypotheses (`rule_table_q_monotone` and `rule_table_symbol_monotone`); proving them from the rule-table encoding is the main outstanding structural task before Phase 4 can depend on the invariant without assumptions.
- With both mismatch branches closed, the loop invariant is ready for induction across the full rule search; the remaining work centers on instantiating the monotonicity lemmas and carrying the invariant into the Phase 4 proofs.
- `pc_29_implies_registers_from_rule_table` is now a lemma with the pre-apply state analysis in place; the proof currently stops after deriving the PC=28 predecessor and must continue with symbolic execution of PCs 22–28 to recover the rule index.
- Attempting to inline the memory-bridge lemma `read_mem_rule_component` into `ThieleUniversal.v` revealed that the existing `Hr` equality only exposes the rule table through a `firstn`/`skipn` pair. Re-deriving `read_mem` facts requires carefully rewriting with `nth_firstn_lt`; a helper equality `mem_tail := skipn RULES_START_ADDR st.(mem)` plus an explicit `eq_trans` is the least intrusive route. Avoid broad rewrites that disturb the many subsequent `decode_instr_program_at_pc` calls—those proofs assume the PC inequality facts remain in their original form.
- **2025-10-02 (current container – Regression Fix):** With `find_rule_loop_preserves_inv` fully proven, a regression was discovered where `make` fails in an earlier proof (`decode_instr_program_at_pc`). The cause was an overly aggressive rewrite in the `read_mem_rule_component` proof. The immediate next action is to refactor this proof to be more targeted, preserving the syntactic invariants required by downstream tactics before proceeding to Phase 4.
- **2025-10-02 (current container – Phase 4 Initiated):** Regression addressed; compilation now advances to the final axioms. Actively expanding `pc_29_implies_registers_from_rule_table` using the loop invariant and `run1_pc_before_apply_hits_29` to recover the witness rule index before tackling `find_rule_from_memory_components`.
- **2025-10-02 (current container – Phase 4.1 Execution):** The proof skeleton now follows the final apply-branch instructions explicitly. We have decoded the PC=28 instruction, established the apply-state successor, and recorded the resulting register/memory relations. Next step: work backwards through PCs 22–27 to express `REG_TEMP1` as `RULES_START_ADDR + 5 * i + offset`, recover the matching rule index via the loop invariant, and finish the existential witness.
- **2025-10-02 (current container – PC=27 Backtrace Setup):** Introduced the predecessor state `st27 := run_n st k''` within `pc_29_implies_registers_from_rule_table` and preserved its program memory equality, creating the staging ground for analyzing the PC 22–27 instruction sequence and reconstructing the `REG_TEMP1` offsets.
- **2025-10-02 (current container – PC 26→22 Trace Planning):** The next proof increment is to replay the straight-line micro-ops between PCs 22 and 28. Formalize the intermediate states `st22`…`st27`, capture their `decode_instr` facts, and thread the arithmetic showing how `REG_TEMP1` steps across `ADDR+{0,2,3,4}` so the final loads into `REG_Q'`, `REG_WRITE`, and `REG_MOVE` come from successive addresses.
- **2025-10-02 (current container – Apply Phase Lemma Toolkit):** Introduced dedicated lemmas `step_pc22_copy_addr` through `step_pc28_load_move` that symbolically execute each instruction in the apply micro-sequence. Use these to avoid re-deriving decoder facts when replaying the backwards trace inside `pc_29_implies_registers_from_rule_table`.
- **2025-10-02 (current container – Register rewrite blockers):** While instantiating the apply-phase lemmas, the remaining proof obligations hinge on precise `write_reg` behaviour. Next step is to factor helper lemmas for `read_reg` after `write_reg` (same/different indices) so the symbolic execution steps can discharge their register equalities without ad-hoc rewrites.
- **2025-10-02 (current container – Register helper strategy):** Initial attempts to drop in generic `read_reg`/`write_reg` lemmas hit combinatorial blowups because `write_reg` is implemented with `firstn/skipn`. Before retrying the apply-phase micro-lemmas, isolate small list lemmas that characterise `write_reg` for indices `< length (regs st)` and preserve register-file length. Once those facts are available, re-run the symbolic execution for PCs 22–28 using a single staging state (`st_pc := write_reg REG_PC …`) rather than repeated manual rewrites.
- **2025-10-02 (current container – Register helper lemmas WIP):** Began factoring `write_reg` preservation lemmas into `UTM_CoreLemmas.v`; the general statements are proving finicky, so the next step is to finish those helper proofs before reattempting the PC 22–28 micro-step reuse.
- **2025-10-02 (current container – Register helper lemmas scouting):** Attempted to generalize `write_reg`/`read_reg` interactions inside `UTM_CoreLemmas.v` to support the PC 22–28 replay. The direct proofs need a register-file length invariant (e.g., deriving length preservation from the `set_nth` helpers). Changes were rolled back to keep the tree compiling; the next iteration should either port the existing `set_nth` lemmas into the shared module or prove `write_reg` length preservation so the helper lemmas can be finished.
- **2025-10-02 (current container – Register helper lemmas scouting):** Attempted to generalize `write_reg`/`read_reg` interactions inside `UTM_CoreLemmas.v` to support the PC 22–28 replay. The direct proofs need a register-file length invariant (e.g., deriving length preservation from the `set_nth` helpers). Changes were rolled back to keep the tree compiling; the next iteration should either port the existing `set_nth` lemmas into the shared module or prove `write_reg` length preservation so the helper lemmas can be finished.
- **2025-10-02 (current container – Register helper lemmas landed):** Added `length_regs_write_reg`, `read_reg_write_reg_same`, and `read_reg_write_reg_other` to `UTM_CoreLemmas.v`. These capture the list-level behaviour of `write_reg` for in-bounds updates and will unblock the PC 22–28 symbolic execution lemmas by providing reusable rewrites instead of ad-hoc `firstn`/`skipn` reasoning.
- **2025-10-02 (current container – Coq toolchain installed):** Coq 8.18.0 is now available in the container (`coqc -v` succeeds). Subsequent proof work should assume the toolchain is present.
- **2025-10-02 (current container – Apply micro-step blockers):** Re-running `make -C coq thieleuniversal/coqproofs/ThieleUniversal.vo` stops at `step_pc22_copy_addr`. The proof needs a length bound on the register file so that the new `read_reg_write_reg_*` lemmas apply cleanly after avoiding full `write_reg` expansion. Next step: either supply a global lemma that `length (regs st) = 10` for invariant states or specialize helper lemmas for writes at `REG_PC`/`REG_TEMP1` that do not require length side conditions.
- **2025-10-02 (current container – Register length threading):** Added explicit `length (regs st) = 10` hypotheses to the PC 22–28 helper lemmas and discharged their register goals via the new `write_reg` list lemmas. The universal proof now fails later inside `find_rule_loop_preserves_inv`, where the next milestone is to thread the same register-length invariant through the PC 4–11 loop steps (e.g., reworking `Hst1_q` and friends to avoid `read_pc_write_pc`).
- **2025-10-02 (current container – Setup-state register length):** Proved `setup_state_regs_length` so the base invariant state’s register file size is explicit; next step is to propagate this fact along the guarded `run_n` prefix to supply the 10-register hypothesis when replaying the PC 22–28 micro-steps.
- **2025-10-02 (current container – Loop register bounds scaffolding):** Added generic register-bound lemmas (`read_reg_ge_length`, `read_reg_nonzero_implies_in_bounds`) and recorded that `find_rule_loop_inv` forces `REG_ADDR` to be in-bounds. These results will let the apply-phase replay derive the necessary register inequalities directly from loop invariants, reducing dependence on the global “regs length = 10” assumption.
- **2025-10-02 (current container – Apply micro-step register length propagated):** Strengthened the PC 22–28 helper lemmas so each step now returns the register-file length alongside the existing memory and register facts. These facts provide the missing hypotheses for chaining the straight-line execution in `pc_29_implies_registers_from_rule_table` without reopening the `write_reg` definition.
- **2025-10-02 (current container – Encode_rules slicing lemmas):** Introduced `skipn_encode_rules` and `firstn_encode_rules` in `UTM_CoreLemmas.v` to make reasoning about rule-table suffixes and prefixes algebraic. These will support Phase 4 by turning memory slice equalities into structural statements about the rule list during the remaining universal machine proofs.
- **2025-10-02 (current container – find_rule suffix indexing):** Added `find_rule_some_split` and `find_rule_skipn_index` to `UTM_CoreLemmas.v`, giving a concrete index-and-prefix decomposition whenever `find_rule` succeeds on a suffix. These lemmas expose the exact table entry hit by the search loop, paving the way to discharge the witness obligations in `pc_29_implies_registers_from_rule_table` and `find_rule_from_memory_components`.
- **2025-10-02 (current container – Apply-phase instruction map):** Captured the concrete instructions for PCs 7, 9, 11, 17, 20–28 in `UTM_Program.v`. These facts rule out spurious jump targets when replaying the backward trace and give direct `nth` equalities for the apply-phase micro-ops.
- **2025-10-02 (current container – Apply-phase temp1 trace):** Added `run_apply_phase_temp1`, chaining the PC 22–28 helper lemmas to show that seven interpreter steps from PC 22 reach PC 29 with unchanged memory and `REG_TEMP1 = read_reg REG_ADDR st + 4`. This establishes the straight-line arithmetic needed before threading the rule-component loads into `pc_29_implies_registers_from_rule_table`.
- **2025-10-02 (current container – Apply-phase register trace):** Strengthened `run_apply_phase_temp1` to track the `REG_Q'`, `REG_WRITE`, and `REG_MOVE` loads alongside the `REG_TEMP1` arithmetic by introducing generic `run1_preserves_reg_*` lemmas. These helper lemmas characterize how `AddConst` and `LoadIndirect` leave non-target registers untouched, allowing the apply-phase replay to expose the rule components directly for use in `pc_29_implies_registers_from_rule_table`.
- **2025-10-02 (current container – Rule table component lemma):** Added `read_mem_rule_component_from_table` to `UTM_CoreLemmas.v`, giving a direct bridge from the encoded rule slice at `RULES_START_ADDR` to individual components without relying on the full invariant. Use this when replaying the apply phase to rewrite memory loads into rule-table fields.
- **2025-10-02 (current container – Apply-phase register summary lemma):** Introduced `run_apply_phase_registers_from_addr`, a condensed version of the seven-step trace that packages the PC=22 → PC=29 execution into reusable register/memory equalities. The remaining blocker for `pc_29_implies_registers_from_rule_table` is to recover the predecessor state with `PC = 22`; once that state is named, instantiate the new lemma to rewrite the apply-state registers in terms of the rule-table slice at `RULES_START_ADDR + 5 * i`.
- **2025-10-02 (current container – `skipn_encode_rules` debugging):** Attempted to replay the historical proof of `skipn_encode_rules` inside `UTM_CoreLemmas.v`. On Coq 8.18 the direct `rewrite skipn_app` step now fails to match the generated goal because `coq_makefile` expands the list operands before the rewrite fires. A working route is to introduce an auxiliary lemma `skipn_app_exact` (stating `skipn (length l1 + n) (l1 ++ l2) = skipn n l2`), instantiate it with `enc := encode_rule r` and `rest := encode_rules rs`, and rewrite using that helper instead of `skipn_app` directly. This keeps the proof small while avoiding brittle pattern matching on `skipn`.
- **2025-10-02 (current container – `skipn_ge_length` fix):** Corrected the base case of `skipn_ge_length` in `UTM_CoreLemmas.v`; the previous proof attempted `exfalso` in the empty-list branch even though `skipn` of an empty list is trivially empty. The lemma now generalizes over `n` before the list induction to avoid the vacuous contradiction.
- **2025-10-02 (current container – `skipn_encode_rules` blocking note):** Attempted to refactor `skipn_encode_rules` around a bespoke `skipn_app_exact` helper so that Coq 8.18’s stricter rewriting can recognise the `skipn (length head + off)` pattern. The helper lemma is straightforward, but the original proof aggressively simplifies `skipn` before the rewrite, making the `encode_rule` suffix expand into a tower of matches. Future work should reorganise the proof to rewrite the `encode_rules (r :: rs)` term into `encode_rule r ++ encode_rules rs` before any `simpl`, then apply `skipn_app_exact` immediately; otherwise the canonical form loses the `++` structure and the rewrite fails. Documenting this subtlety avoids repeating the failed sequence in the next iteration.
- **2025-10-02 (current container – `skipn_app_exact` landed):** Added the dedicated `skipn_app_exact` helper lemma to `UTM_CoreLemmas.v` and rewrote `skipn_encode_rules` to depend on it, preventing the `skipn_app` rewrite pattern mismatch observed under Coq 8.18.
- **2025-10-02 (current container – encode_rules suffix debugging):** Introduced the standalone `encode_rules_cons` lemma as prep work for taming `skipn_encode_rules`. Direct rewrites with `skipn_app` still fail under Coq 8.18 even after `set`-ing the rule suffix; the next iteration should exploit `encode_rules_cons` together with a frozen tail (`set (tail := encode_rules rs)`) and possibly the `skipn_skipn` identity to expose the `encode_rule r ++ tail` pattern before applying the skipn lemmas.
- **2025-10-02 (current container – encode_rules skipping lemmas updated):** Reworked `skipn_encode_rules` to destruct the rule list and index explicitly, rewriting through `encode_rules_cons` and `skipn_app_exact` so the Coq 8.18 rewriting passes. Adjusted `firstn_encode_rules` to avoid unnamed implicit arguments by calling `@firstn_app_2`, and verified both lemmas reduce to the original statements. `coq_makefile` now progresses past these helpers before failing later in `UTM_CoreLemmas.v` on the existing `decode_instr` obligations.
- **2025-10-02 (current container – run1 helper relocation):** Shifted the `run1_preserves_reg_addconst`/`run1_preserves_reg_loadindirect` lemmas into `ThieleUniversal.v`, rewriting them to keep `read_reg` abstract while threading the new `write_reg` helper facts. `make -C coq thieleuniversal/coqproofs/UTM_CoreLemmas.vo` now completes, and the universal proof advances to later obligations (current stop: register-length reasoning around line 892 of `ThieleUniversal.v`).
- **2025-10-02 (current container – Apply-loop helper expansion):** Added `run1_addconst_result`, `run1_loadindirect_result`, and `run1_preserves_reg_jz_true` so the PC 13–22 segment can avoid `read_pc_write_pc` rewrites. Threaded fresh `REG_SYM`/`REG_TEMP2` preservation facts through states `st5`–`st8`, enabling the symbolic execution to reuse the loop invariant without reopening `write_reg`. The build now reaches the Jz-to-apply transition (around line 3572) where additional register-preservation lemmas for the remaining control-flow steps are needed to eliminate the last `write_reg` occurrence.
- **2025-10-02 (current container – Apply-phase length helper):** Added `length_regs_write_reg_10` to reuse the `write_reg` preservation reasoning without repeating `pose proof` scaffolding. Updated the PC 22–27 helper lemmas to invoke it directly, pushing the build frontier forward to the remaining PC 28/29 length obligations.
- **2025-10-02 (current container – Apply-phase register replay refinement):** Reworked `pc_29_implies_registers_from_rule_table` to rely on the shared `read_mem_mem_eq` helper and new base equalities for each staged state. The proof now chains the PC 22–28 micro-steps without expanding `write_reg`, packages the memory preservation facts through `HmemXX_base`, and rewrites the final apply state via `run_apply_phase_registers_from_addr`. Compilation still aborts later while replaying the loop phase (current stop: the rewritten register bounds around line 2509), so the next iteration should port the same “base equality” pattern into the earlier symbolic execution to eliminate the remaining brittle `rewrite read_pc_write_pc` calls.
- **2025-10-02 (current container – Loop phase rewrite refactor WIP):** Began replacing the early-loop uses of `read_pc_write_pc` with structured applications of the `write_reg` helper lemmas. The load step at PC 4 now derives register preservation via explicit bounds, moving the build failure forward to the subsequent CopyReg step (current stop: line 2631). The next increment should mirror this treatment for the PC 5–6 transitions, ensuring `REG_TEMP1` bounds are established before replaying the remaining loop iterations.
- **2025-10-02 (current container – PC5 CopyReg refactor):** Added a general `run1_preserves_reg_copyreg` lemma and threaded an explicit `length (regs st) = 10` hypothesis through `find_rule_loop_preserves_inv`. The PC 5 CopyReg step now preserves `REG_ADDR`, `REG_Q`, `REG_Q'`, and `REG_SYM` via the new helper, while `REG_TEMP1` is rewritten using targeted `write_reg` bounds. `make` progresses past PC 5 and now stops at the PC 6 SubReg decoding step (line 2751) because the `decode_instr_program_at_pc` rewrite still expects the original `Hdecode_prog` shape.
- **2025-10-02 (current container – PC6–13 refactor progress):** Added reusable lemmas `run1_preserves_reg_subreg`, `run1_subreg_result`, and `run1_copyreg_result` so SubReg/CopyReg steps can reuse the shared `write_reg` helpers. Threaded explicit 10-register length facts and per-register bounds through the states `st2`–`st5`, rewrote the PC 6 decoding to use the concrete `read_reg REG_PC = 6` equality, and updated the PC 7/12/13 decoder calls to rewrite via the numeric PC witnesses. The loop proof now advances through the SubReg step and into the first apply-branch micro-ops; `make` currently stops around line 3164 where the subsequent AddConst/LoadIndirect cases still rely on legacy `read_pc_write_pc` rewrites. Next iteration should continue replacing those remaining expansions with the new helpers and propagate the length/bound facts to `st6` and beyond.
