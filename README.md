# The Thiele Machine

**A Computational Model with Explicit Structural Cost**

[![CI](https://github.com/sethirus/The-Thiele-Machine/actions/workflows/ci.yml/badge.svg)](https://github.com/sethirus/The-Thiele-Machine/actions/workflows/ci.yml)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Coq](https://img.shields.io/badge/Coq-285%20Proof%20Files-blue)](coq/)

---

## The Claim

**Insight is not free.** Every time a computer figures something out—factors a number, finds a pattern, solves a puzzle—it pays a cost. Not time. Not memory. *Information*. This cost is the **mu-bit**.

Classical complexity theory measures time and space but assigns zero cost to structural knowledge. The Thiele Machine makes that cost explicit, measurable, and enforceable.

Every claim in this repository has a concrete falsifier. If you think something is wrong, the proofs won't compile.

## Quick Start

```bash
git clone https://github.com/sethirus/The-Thiele-Machine.git
cd The-Thiele-Machine
pip install -r requirements.txt
pip install -e . --no-deps
pytest tests/
```

### Compile Coq Proofs (requires Coq 8.18+)
```bash
make -C coq
```

### Run Hardware Simulation (requires iverilog)
```bash
iverilog thielecpu/hardware/rtl/*.v -o thiele_cpu
```

### FPGA Bitstream (Open-Source)
The CI full-verification job uses an open-source FPGA flow with `yosys`,
`nextpnr-ecp5`, and `ecppack` (fpga-trellis) to generate an ECP5 bitstream
artifact. The open-source flow builds the full CPU with `YOSYS_LITE` enabled to
keep the parameterized region sizes tractable for PnR, while preserving the full
instruction set and control logic. Ensure these tools are available in your
environment if you run the verification pipeline locally.

The CI pipeline defaults to skipping the full PnR/bitstream step (set
`OPENFPGA_PNR=1` to enable full bitstream generation locally or in a dedicated
workflow) to keep verification runtime manageable.

---

## The Evidence

| Component | Status |
|-----------|--------|
| **Coq proofs** | 285 files, ~78,500 lines, ~2,316 theorems/lemmas, **zero admits**, **zero axioms** beyond foundational logic. [Audit Report](INQUISITOR_REPORT.md) |
| **Python VM** | 20,786 lines. Working reference implementation with cryptographic receipts. |
| **Verilog RTL** | 14 files, ~4,370 hand-written lines. Synthesizable, FPGA-targetable. |
| **Test suite** | 828 tests across 82 test files. |
| **3-layer isomorphism** | Coq = Python = Verilog. Same program, same state, three layers. |
| **6 hard assumptions** | All 6 mechanically proven in `HardMathFactsProven.v`. Zero remaining assumptions. |

---

## How I Work

I don't code. I have never "learned to code" in the traditional sense. I work exclusively through LLM-directed development: I specify the ideas, the invariants, the architectures, and the falsification conditions, then direct large language models to implement them.

The ideas are mine. The implementation is collaborative. Every line of code was generated by LLMs directed by my specifications. The proofs compile or they don't. The tests pass or they fail. The math doesn't care who typed it.

I'm an architect who works with power tools. LLMs are my CAD software.

---

## Key Theorems (Proven in Coq)

| Theorem | What It Establishes | File |
|---------|---------------------|------|
| `mu_is_initial_monotone` | mu is THE unique canonical cost functional | `kernel/MuInitiality.v` |
| `mu_is_landauer_valid` | mu satisfies Landauer's erasure bound | `kernel/MuNecessity.v` |
| `no_free_insight_general` | Search space reduction requires proportional mu-investment | `kernel/NoFreeInsight.v` |
| `mu_conservation_kernel` | mu-ledger never decreases under any transition | `kernel/MuLedgerConservation.v` |
| `main_subsumption` | Thiele Machine strictly subsumes Turing Machine | `kernel/Subsumption.v` |
| `local_box_CHSH_bound` | Unitary execution bound: mu=0 implies S <= 2 | `kernel/MinorConstraints.v` |
| `thiele_simulates_turing` | Proper simulation of Turing computation | `kernel/ProperSubsumption.v` |

### The Initiality Theorem

The strongest result: if you want ANY cost measure that assigns consistent costs to instructions and starts at zero, you MUST get mu. There is no other choice.

```coq
Theorem mu_is_initial_monotone :
  forall M : VMState -> nat,
    instruction_consistent M canonical_cost ->
    M init_state = 0 ->
    forall s, reachable s -> M s = s.(vm_mu).
```

### The No Free Insight Theorem

You cannot narrow the search space without paying the information-theoretic cost:

```
delta_mu >= log2(Omega) - log2(Omega')
```

If you think this bound is loose, prove a tighter one.

---

## The Architecture

The Thiele Machine is defined as a 5-tuple **T = (S, Pi, A, R, L)**:

| Component | Description |
|-----------|-------------|
| **S** | State space (VMState: registers, memory, pc, mu-ledger, partition graph) |
| **Pi** | Partition graph — how state decomposes into modules |
| **A** | Axiom sets — logical constraints per module |
| **R** | Transition rules — the 18-instruction ISA (23 vm_step constructors) |
| **L** | Logic Engine — SAT/UNSAT certificate verification |

### The 18-Instruction ISA

```
Structural:    PNEW, PSPLIT, PMERGE, PDISCOVER
Logical:       LASSERT, LJOIN, MDLACC, EMIT, REVEAL
Compute:       XFER, XOR_LOAD, XOR_ADD, XOR_SWAP, XOR_RANK
Quantum:       CHSH_TRIAL
Special:       PYEXEC, ORACLE_HALTS
Control:       HALT
```

Every instruction takes an explicit mu_delta >= 0. Every transition increments the mu-ledger by that delta. Monotonicity is proven in Coq and enforced in hardware.

Source of truth: `thielecpu/hardware/rtl/generated_opcodes.vh`, `coq/kernel/VMStep.v`, `thielecpu/isa.py`.

---

## Three-Layer Isomorphism

The Thiele Machine is implemented at three layers producing **identical state projections**:

| Layer | Implementation | Purpose |
|-------|----------------|---------|
| **Coq** | 285 proof files, ~78,500 lines, zero admits | Mathematical ground truth |
| **Python** | 20,786 lines, receipts and traces | Executable reference |
| **Verilog** | 14 files, ~4,370 hand-written lines, synthesizable RTL | Physical realization |

For any instruction trace tau:
```
S_Coq(tau) = S_Python(tau) = S_Verilog(tau)
```

This is enforced by automated tests. Any divergence is a critical bug. Find one and the proofs break.

---

## Hardware

Target: Xilinx Artix-7. Unified design in `thielecpu/hardware/rtl/thiele_cpu_unified.v`.

**mu-ALU:** Q16.16 fixed-point. Operations: add, sub, mul, div, log2, info_gain. Overflow flag rejects mu-decreasing updates.

**mu-Core:** Gates ledger updates. Rejects any proposed cost < 0.

**State serializer:** Canonical byte stream for cross-layer verification.

Synthesis: 2,847 LUTs, 1,234 FFs, 4 BRAM, 2 DSP, 125 MHz max.

---

## Quantum Axioms from Mu-Accounting

Eight files, 3,961 lines, zero Admitted:

| File | Lines | Theorems | What It Derives |
|------|-------|----------|-----------------|
| `NoCloning.v` | 936 | 7 | Perfect cloning costs mu > 0 |
| `NoCloningFromMuMonotonicity.v` | 260 | 3 | Machine-native no-cloning (lia) |
| `Unitarity.v` | 583 | 6 | Zero-cost evolution is CPTP |
| `BornRule.v` | 321 | 10 | P = \|a\|^2 from linearity |
| `BornRuleFromSymmetry.v` | 939 | 31 | Born rule from tensor consistency |
| `Purification.v` | 280 | 7 | Mixed states need references |
| `TsirelsonGeneral.v` | 315 | 15 | S <= 2*sqrt(2) from coherence |
| `TsirelsonFromAlgebra.v` | 327 | 11 | Self-contained algebraic Tsirelson |

Quantum mechanics is not postulated. It falls out of mu-conservation.

---

## CHSH Demonstration

The flagship demo. The same protocol at different mu levels reproduces all three correlation regimes:

| Regime | Mu Cost | Bound | Win Rate |
|--------|---------|-------|----------|
| Classical | mu = 0 | S <= 2 | 75% |
| Quantum | mu > 0 | S <= 2*sqrt(2) | 85.35% |
| Supra-quantum | max mu | S = 4 | 100% |

---

## Hard Assumptions (6 total)

Documented in `coq/kernel/AssumptionBundle.v`. These are standard mathematical facts (NPA hierarchy, algebraic bounds) that would require heavy external libraries to derive in Coq:

| Assumption | What It States |
|------------|----------------|
| `norm_E_bound` | Bloch vector norm bound |
| `valid_S_4` | S=4 algebraic maximum valid |
| `local_S_2` | Local S <= 2 |
| `pr_no_ext` | No-signaling probability constraint |
| `symm_coh_bound` | Symmetric coherence bound |
| `tsir_from_coh` | Tsirelson from coherence |

Each has concrete justification and falsification conditions. All six are mechanically proven in `kernel/HardMathFactsProven.v` (686 lines).

---

## Falsification

Every claim has a concrete falsifier. To disprove:

- **mu-conservation:** Find ANY instruction where mu_delta < 0.
- **No Free Insight:** Certify P_strong from clean_start with no revelation event.
- **No-signaling:** Find an instruction on module A that changes module B's observables.
- **Tsirelson bound:** Find a quantum-admissible box with S > 5657/2000.
- **No-cloning:** Build a zero-cost perfect cloner.
- **3-layer isomorphism:** Find a program where Python != Coq != RTL.

If you find any of these, the Coq proofs won't compile.

---

## Project Structure

```
The-Thiele-Machine/
├── coq/                    # 285 Coq proof files (~78,500 lines)
│   ├── kernel/             # Core theorems (MuInitiality, NoFreeInsight, etc.)
│   ├── modular_proofs/     # Turing/Minsky simulation proofs
│   ├── nofi/               # No Free Insight functor architecture
│   ├── physics/            # Wave model, spacetime emergence
│   ├── bridge/             # Domain-to-kernel bridges
│   ├── thielemachine/      # Main VM proofs
│   └── ...                 # 26 subdirectories total
├── thielecpu/              # Python VM (20,786 lines)
│   ├── vm.py               # Core execution engine
│   ├── state.py            # State machine, partitions, mu-ledger
│   ├── isa.py              # 18-instruction ISA
│   └── hardware/           # Verilog RTL (14 files, ~4,370 hand-written lines)
├── tests/                  # 828 tests across 82 files
├── scripts/                # Build, verification, analysis tools
├── tools/                  # mu-Profiler and extracted VM runner
├── verifier/               # Physics divergence verification
├── thesis/                 # Complete thesis (PDF + LaTeX)
└── COQ_AUDIT_REPORT.md     # Full proof audit results
```

---

## The Inquisitor Standard

All Coq proofs pass maximum-strictness static analysis:

```bash
python scripts/inquisitor.py
```

25+ lint rules enforced on every Coq file:
- Zero `Admitted` / `admit` / `give_up` across all 285 proof files
- Zero custom axioms beyond `AssumptionBundle.v`
- All proofs end with `Qed`
- `Print Assumptions` at end of major files
- Standard library axioms only (functional extensionality, classical decidability)

---

## Receipt System

Every execution produces a cryptographic receipt chain:

```python
receipt = {
    "pre_state_hash": SHA256(state_before),
    "instruction": opcode,
    "post_state_hash": SHA256(state_after),
    "mu_cost": cost,
    "chain_link": SHA256(previous_receipt)
}
```

This enables post-hoc verification without re-execution.

---

## Dependencies

**Python** (3.10+):
- `z3-solver` — SMT solving
- `cryptography`, `pynacl` — Receipt verification
- `numpy`, `scipy` — Numerical computation
- `pytest`, `hypothesis` — Testing

**Coq** (8.18+):
- Required only to rebuild proofs

**Verilog**:
- `iverilog` for simulation
- Vivado 2023.2 for FPGA synthesis

---

## Documentation

| Resource | Location |
|----------|----------|
| Main README | This file |
| Coq Proofs | [coq/README.md](coq/README.md) |
| Hardware | [thielecpu/hardware/README.md](thielecpu/hardware/README.md) |
| Thesis | [thesis/main.pdf](thesis/main.pdf) |
| Reference Manual | [thesis/thiele_machine_manual.txt](thesis/thiele_machine_manual.txt) |
| Proof Audit | [INQUISITOR_REPORT.md](INQUISITOR_REPORT.md) |

---

## Contributing

Two contribution types:
1. **Replication artifacts** — New proofpacks testing mu-ledger predictions.
2. **Counterexample hunts** — Attempts to violate the Cost Invariant.

Report potential counterexamples via issue labeled `counterexample`.

---

## Citation

```bibtex
@misc{thielemachine2026,
  title={The Thiele Machine: A Computational Model with Explicit Structural Cost},
  author={Thiele, Devon},
  year={2026},
  howpublished={\url{https://github.com/sethirus/The-Thiele-Machine}}
}
```

---

## License

Apache 2.0 — See [LICENSE](LICENSE)

---

*The Turing Machine gave us universality.*
*The Thiele Machine gives us universality plus accountability.*
