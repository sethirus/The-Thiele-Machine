#!/usr/bin/env python3
"""Forge: generate Python + Verilog artifacts from extracted Coq OCaml.

This is a deliberately tiny "backend" that treats the OCaml produced by
Coq Extraction as the canonical intermediate representation (IR).

Current scope (MVP, but real):
- Parse the extracted `type vm_instruction = ...` constructors.
- Emit:
    - `thielecpu/generated/generated_core.py` containing the opcode tags.
  - `thielecpu/hardware/generated_control.v` containing matching opcode params.
- Run a structural isomorphism check (IR ↔ Python ↔ Verilog) and fail if any
  mismatch is found.

This intentionally avoids trying to fully synthesize graph/CSR semantics into
Verilog in one jump. The point of this Foundry stage is to make the *instruction
surface* impossible to drift.

Note: we generate under `thielecpu/generated/` (a package) rather than
`thielecpu/vm/...` because `thielecpu/vm.py` already exists as the VM module.

See `scripts/forge_artifact.sh` for the end-to-end pipeline.
"""

from __future__ import annotations

import argparse
import re
from pathlib import Path


TYPE_RE = re.compile(r"^\s*type\s+vm_instruction\s*=\s*$")
CTOR_RE = re.compile(r"^\s*\|\s*([A-Za-z0-9_']+)\b")

# The extracted Coq kernel IR currently contains internal instructions that are
# not part of the hardware/Python ISA surface. We intentionally *filter* these
# out so Foundry locks the cross-layer instruction surface without forcing RTL
# support for internal-only opcodes.
#
# IMPORTANT: This is an allowlist. If the IR grows a new tag unexpectedly,
# Foundry should still fail unless that mnemonic is explicitly allowed here.
IGNORED_COQ_MNEMONICS: set[str] = {
    "REVEAL",
}


def _coq_tag_to_mnemonic(tag: str) -> str:
    # Coq extraction constructor names in this repo currently look like:
    #   Coq_instr_pnew, Coq_instr_xor_load, Coq_instr_oracle_halts, ...
    if tag.startswith("Coq_instr_"):
        stem = tag[len("Coq_instr_") :]
    elif tag.startswith("coq_instr_"):
        stem = tag[len("coq_instr_") :]
    else:
        stem = tag
    # OCaml constructor identifiers can include primes; strip them.
    stem = stem.replace("'", "")
    return stem.upper()


def parse_vm_instruction_constructors(ml_text: str) -> list[str]:
    lines = ml_text.splitlines()
    in_type = False
    ctors: list[str] = []

    for line in lines:
        if not in_type:
            if TYPE_RE.match(line):
                in_type = True
            continue

        # End of type block when we hit a new `type` / `let` / blank line after ctors
        if line.strip() == "":
            if ctors:
                break
            continue
        if line.lstrip().startswith("type ") and ctors:
            break
        if line.lstrip().startswith("let ") and ctors:
            break

        m = CTOR_RE.match(line)
        if m:
            ctors.append(m.group(1))

    if not ctors:
        raise SystemExit("forge.py: could not find `type vm_instruction =` constructors in extracted OCaml")

    return ctors


def render_python(tags: list[str], mnemonic_to_opcode: dict[str, int]) -> str:
    tags_repr = ",\n    ".join(repr(t) for t in tags)

    # Deterministic dict literal ordering for diffs.
    tag_to_mnemonic_items = []
    tag_to_opcode_items = []
    for tag in tags:
        mnemonic = _coq_tag_to_mnemonic(tag)
        opcode = mnemonic_to_opcode[mnemonic]
        tag_to_mnemonic_items.append((tag, mnemonic))
        tag_to_opcode_items.append((tag, opcode))

    tag_to_mnemonic_src = ",\n    ".join(
        f"{tag!r}: {mnemonic!r}" for tag, mnemonic in tag_to_mnemonic_items
    )
    tag_to_opcode_src = ",\n    ".join(
        f"{tag!r}: {opcode}" for tag, opcode in tag_to_opcode_items
    )

    mnemonic_to_opcode_src = ",\n    ".join(
        f"{mnemonic!r}: {opcode}" for mnemonic, opcode in sorted(mnemonic_to_opcode.items())
    )

    return (
        "\n".join(
            [
                '"""DO NOT EDIT. GENERATED FROM COQ PROOFS.',
                'Generated by scripts/forge.py from Coq-extracted OCaml.',
                '',
                'This file intentionally matches the *existing* ISA encoding used by:',
                '- thielecpu/isa.py (Python reference encoding)',
                '- thielecpu/hardware/thiele_cpu.v (RTL implementation)',
                '',
                'If you change ISA encodings, regenerate via scripts/forge_artifact.sh.',
                '"""',
                '',
                'from __future__ import annotations',
                '',
                'COQ_INSTRUCTION_TAGS: tuple[str, ...] = (',
                f'    {tags_repr},',
                ')',
                '',
                'COQ_TAG_TO_MNEMONIC: dict[str, str] = {',
                f'    {tag_to_mnemonic_src},',
                '}',
                '',
                'MNEMONIC_TO_OPCODE_BYTE: dict[str, int] = {',
                f'    {mnemonic_to_opcode_src},',
                '}',
                '',
                'COQ_TAG_TO_OPCODE_BYTE: dict[str, int] = {',
                f'    {tag_to_opcode_src},',
                '}',
                '',
                'def sanity_check() -> None:',
                '    assert len(COQ_INSTRUCTION_TAGS) == len(set(COQ_INSTRUCTION_TAGS))',
                '    assert all(isinstance(tag, str) and tag for tag in COQ_INSTRUCTION_TAGS)',
                '    # Ensure all tags map to known ISA opcodes.',
                '    assert set(COQ_TAG_TO_MNEMONIC) == set(COQ_INSTRUCTION_TAGS)',
                '    assert set(COQ_TAG_TO_OPCODE_BYTE) == set(COQ_INSTRUCTION_TAGS)',
                '    assert all(0 <= v <= 0xFF for v in COQ_TAG_TO_OPCODE_BYTE.values())',
                '',
            ]
        )
        + "\n"
    )


def render_verilog_header(tags: list[str], mnemonic_to_opcode: dict[str, int]) -> str:
    # Emit a header that can be `include`d by the real RTL.
    lines: list[str] = [
        "// DO NOT EDIT. GENERATED FROM COQ PROOFS.",
        "// Generated by scripts/forge.py from Coq-extracted OCaml.",
        "//",
        "// This header defines OPCODE_* localparams that must match:",
        "// - thielecpu/isa.py (Python reference)",
        "// - thielecpu/hardware/thiele_cpu.v (RTL decode)",
        "",
        "// Instruction opcodes",
    ]

    # Keep ordering consistent with Coq instruction constructor order.
    seen: set[str] = set()
    for tag in tags:
        mnemonic = _coq_tag_to_mnemonic(tag)
        if mnemonic in seen:
            continue
        seen.add(mnemonic)
        opcode = mnemonic_to_opcode[mnemonic]
        lines.append(f"localparam [7:0] OPCODE_{mnemonic} = 8'h{opcode:02X};")

    lines.append("")  # newline at EOF
    return "\n".join(lines)


def _parse_verilog_opcodes_from_header(text: str) -> dict[str, int]:
    pattern = re.compile(
        r"localparam\s+\[7:0\]\s+OPCODE_([A-Z0-9_]+)\s*=\s*8'h([0-9a-fA-F]{2})\s*;"
    )
    out: dict[str, int] = {}
    for line in text.splitlines():
        m = pattern.search(line)
        if m:
            name, hexv = m.groups()
            out[name] = int(hexv, 16)
    return out


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--input", required=True, help="Path to extracted OCaml .ml")
    ap.add_argument("--out-python", required=True, help="Path to generated Python module")
    ap.add_argument("--out-verilog", required=True, help="Path to generated Verilog module")
    ap.add_argument("--check-only", action="store_true", help="Do not write outputs; only check")
    args = ap.parse_args()

    ml_path = Path(args.input)
    ml_text = ml_path.read_text(encoding="utf-8", errors="replace")
    tags_all = parse_vm_instruction_constructors(ml_text)
    tags = [t for t in tags_all if _coq_tag_to_mnemonic(t) not in IGNORED_COQ_MNEMONICS]

    # Resolve tags -> ISA opcode bytes using the repo's canonical Python ISA.
    try:
        from thielecpu.isa import Opcode  # local import so forge.py can be linted without env
    except Exception as exc:  # pragma: no cover
        raise SystemExit(f"forge.py: failed to import thielecpu.isa.Opcode: {exc}")

    mnemonic_to_opcode: dict[str, int] = {}
    missing: list[str] = []
    for tag in tags:
        mnemonic = _coq_tag_to_mnemonic(tag)
        try:
            opcode = Opcode[mnemonic].value
        except KeyError:
            missing.append(mnemonic)
            continue
        mnemonic_to_opcode[mnemonic] = int(opcode)

    if missing:
        missing_sorted = ", ".join(sorted(set(missing)))
        raise SystemExit(
            "forge.py: Coq-extracted instruction tags include mnemonics not present in thielecpu.isa.Opcode: "
            + missing_sorted
        )

    out_py = Path(args.out_python)
    out_v = Path(args.out_verilog)

    if not args.check_only:
        out_py.parent.mkdir(parents=True, exist_ok=True)
        out_v.parent.mkdir(parents=True, exist_ok=True)
        out_py.write_text(render_python(tags, mnemonic_to_opcode), encoding="utf-8")
        out_v.write_text(render_verilog_header(tags, mnemonic_to_opcode), encoding="utf-8")

    # Structural loop-closure check.
    py_text = out_py.read_text(encoding="utf-8", errors="replace")
    m = re.search(r"COQ_INSTRUCTION_TAGS: tuple\[str, \.\.\.\] = \((.*?)\)\s*\n", py_text, re.S)
    if not m:
        raise SystemExit("forge.py: could not parse COQ_INSTRUCTION_TAGS from generated python")

    # Evaluate a tuple literal safely-ish: it contains only quotes/commas/whitespace.
    tuple_src = "(" + m.group(1) + ")"
    parsed_tags = re.findall(r"'([^']*)'|\"([^\"]*)\"", tuple_src)
    py_tags = [a or b for a, b in parsed_tags]

    if tags != py_tags:
        raise SystemExit(f"forge.py: mismatch IR vs python tags\nIR: {tags}\nPY: {py_tags}")

    v_text = out_v.read_text(encoding="utf-8", errors="replace")
    v_opcodes = _parse_verilog_opcodes_from_header(v_text)
    if not v_opcodes:
        raise SystemExit("forge.py: could not parse any OPCODE_* params from generated verilog header")

    # Ensure every extracted constructor maps to an opcode definition.
    expected_mnemonics = [_coq_tag_to_mnemonic(t) for t in tags]
    for mnemonic in expected_mnemonics:
        if mnemonic not in v_opcodes:
            raise SystemExit(f"forge.py: missing OPCODE_{mnemonic} in generated verilog header")
        if v_opcodes[mnemonic] != mnemonic_to_opcode[mnemonic]:
            raise SystemExit(
                f"forge.py: opcode mismatch for {mnemonic}: verilog={v_opcodes[mnemonic]:#x} python-isa={mnemonic_to_opcode[mnemonic]:#x}"
            )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
