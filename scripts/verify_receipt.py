# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# Copyright 2025 Devon Thiele
# See the LICENSE file in the repository root for full terms.

#!/usr/bin/env python3
"""
Receipt Verifier for Thiele Machine Computations

This script verifies the integrity and consistency of computation receipts
generated by the Thiele Machine. It checks hash chains, μ accumulation,
and invariant compliance.
"""

import sys
import os
import json
import argparse
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from scripts.receipt_schema import load_receipt, verify_receipt, ComputationReceipt

def verify_receipt_file(filepath: str) -> dict:
    """Verify a receipt file and return detailed results."""
    try:
        receipt = load_receipt(filepath)
        verification = verify_receipt(receipt)

        result = {
            "file": filepath,
            "valid": verification["valid"],
            "issues": verification["issues"],
            "receipt_hash": verification["receipt_hash"],
            "instance_sha256": receipt.instance_sha256,
            "n": receipt.n,
            "m": receipt.m,
            "mu_total": receipt.mu_total,
            "computed_mu_total": verification["computed_mu_total"],
            "final_claim": receipt.final_claim,
            "step_count": len(receipt.steps),
            "version": receipt.version
        }

        return result

    except Exception as e:
        return {
            "file": filepath,
            "valid": False,
            "issues": [f"Failed to load/parse receipt: {str(e)}"],
            "error": str(e)
        }

def print_verification_report(results: list):
    """Print a human-readable verification report."""
    print("Thiele Machine Receipt Verification Report")
    print("=" * 50)

    total_valid = sum(1 for r in results if r["valid"])
    total_files = len(results)

    print(f"Files processed: {total_files}")
    print(f"Valid receipts: {total_valid}")
    print(f"Invalid receipts: {total_files - total_valid}")
    print()

    for result in results:
        status = "✓ VALID" if result["valid"] else "✗ INVALID"
        print(f"{status}: {result['file']}")

        if not result["valid"]:
            for issue in result["issues"]:
                print(f"  - {issue}")

        if "receipt_hash" in result:
            print(f"  Receipt hash: {result['receipt_hash'][:16]}...")
        if "instance_sha256" in result:
            print(f"  Instance hash: {result['instance_sha256'][:16]}...")
        if "mu_total" in result:
            print(f"  μ total: {result['mu_total']}")
        if "final_claim" in result:
            print(f"  Final claim: {result['final_claim']}")

        print()

def main():
    parser = argparse.ArgumentParser(description="Verify Thiele Machine computation receipts")
    parser.add_argument("files", nargs="+", help="Receipt files to verify")
    parser.add_argument("--json", action="store_true", help="Output results as JSON")
    parser.add_argument("--quiet", action="store_true", help="Suppress detailed output")

    args = parser.parse_args()

    results = []
    for filepath in args.files:
        if not os.path.exists(filepath):
            results.append({
                "file": filepath,
                "valid": False,
                "issues": ["File not found"]
            })
        else:
            results.append(verify_receipt_file(filepath))

    if args.json:
        print(json.dumps(results, indent=2))
    else:
        if not args.quiet:
            print_verification_report(results)

        # Exit with appropriate code
        all_valid = all(r["valid"] for r in results)
        sys.exit(0 if all_valid else 1)

if __name__ == "__main__":
    main()