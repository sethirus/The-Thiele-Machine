# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# Copyright 2025 Devon Thiele
# See the LICENSE file in the repository root for full terms.

#!/usr/bin/env python3
"""
Receipt Verifier for Thiele Machine Computations

This script verifies the integrity and consistency of computation receipts
generated by the Thiele Machine. It checks hash chains, μ accumulation,
and invariant compliance.
"""

import sys
import os
import json
import argparse
import hashlib
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from scripts.receipt_schema import load_receipt, verify_receipt, ComputationReceipt
from thielecpu.receipts import verify_signature

GENESIS_HASH = "genesis"


def _default_public_key() -> Path:
    return Path(os.environ.get("THIELE_KERNEL_VERIFY_KEY", "kernel_public.key")).expanduser()

def _hash_payload(payload):
    return hashlib.sha256(json.dumps(payload, sort_keys=True, separators=(",", ":")).encode("utf-8")).hexdigest()

def _verify_structured_receipt(path: Path, data: dict | list, public_key: Path) -> dict:
    issues: list[str] = []
    if isinstance(data, list):
        steps = data
        claimed_mu = None
        final_claim = None
        instance_hash = ""
    else:
        steps = data.get("steps", [])
        claimed_mu = data.get("mu_total")
        final_claim = data.get("final_claim")
        instance_hash = data.get("instance_hash", "")
    prev_hash = GENESIS_HASH
    computed_mu = 0.0
    key_missing = not public_key.exists()
    if key_missing:
        issues.append(f"Verifying key not found at {public_key}")

    for idx, step in enumerate(steps):
        step_label = step.get("step", idx)
        pre_state = step.get("pre_state", {})
        post_state = step.get("post_state", {})
        pre_state_hash = step.get("pre_state_hash") or _hash_payload(pre_state)
        post_state_hash = step.get("post_state_hash") or _hash_payload(post_state)
        if pre_state_hash != _hash_payload(pre_state):
            issues.append(f"Step {step_label}: pre_state_hash mismatch")
        if post_state_hash != _hash_payload(post_state):
            issues.append(f"Step {step_label}: post_state_hash mismatch")

        certificate = step.get("certificate", {})
        recorded_cert_hash = step.get("certificate_hash")
        if isinstance(certificate, str):
            actual_cert_hash = hashlib.sha256(certificate.encode("utf-8")).hexdigest()
        else:
            actual_cert_hash = hashlib.sha256(json.dumps(certificate, sort_keys=True).encode("utf-8")).hexdigest()
        if recorded_cert_hash and recorded_cert_hash != actual_cert_hash:
            issues.append(f"Step {step_label}: certificate hash mismatch")

        payload_for_signature = {
            "step": step.get("step", idx),
            "instruction": step.get("instruction"),
            "pre_state": pre_state,
            "post_state": post_state,
            "observation": step.get("observation", {}),
            "pre_state_hash": pre_state_hash,
            "post_state_hash": post_state_hash,
        }

        expected_payload = {
            "step": step.get("step", idx),
            "instruction": step.get("instruction"),
            "pre_state_hash": pre_state_hash,
            "post_state_hash": post_state_hash,
            "observation": step.get("observation", {}),
            "mu_delta": float(step.get("mu_delta", 0.0)),
            "prev_step_hash": prev_hash,
        }
        expected_step_hash = _hash_payload(expected_payload)
        recorded_prev = step.get("prev_step_hash")
        if recorded_prev is not None and recorded_prev != prev_hash:
            issues.append(f"Step {step_label}: prev_step_hash mismatch")
        recorded_step_hash = step.get("step_hash")
        if recorded_step_hash is not None and recorded_step_hash != expected_step_hash:
            issues.append(f"Step {step_label}: step_hash mismatch")

        signature = step.get("signature")
        if isinstance(signature, str) and not key_missing:
            if not verify_signature(
                payload_for_signature,
                signature,
                verifying_key_path=public_key,
            ):
                issues.append(f"Step {step_label}: signature verification failed")
        elif not isinstance(signature, str):
            issues.append(f"Step {step_label}: signature missing or malformed")

        prev_hash = recorded_step_hash or expected_step_hash
        computed_mu += float(step.get("mu_delta", 0.0))

    if claimed_mu is None:
        claimed_mu = computed_mu
    else:
        claimed_mu = float(claimed_mu)
    if abs(computed_mu - claimed_mu) > 1e-6:
        issues.append(f"μ total mismatch: computed {computed_mu}, claimed {claimed_mu}")

    receipt_digest = _hash_payload({
        "instance_hash": instance_hash,
        "steps": [step.get("step_hash") or "" for step in steps],
    })

    return {
        "file": str(path),
        "valid": not issues,
        "issues": issues,
        "receipt_hash": receipt_digest,
        "instance_sha256": instance_hash,
        "mu_total": claimed_mu,
        "computed_mu_total": computed_mu,
        "final_claim": final_claim,
        "step_count": len(steps),
        "version": (data.get("version", "1.0") if isinstance(data, dict) else "1.0"),
    }

def verify_receipt_file(filepath: str, public_key: Path) -> dict:
    """Verify a receipt file and return detailed results."""
    path = Path(filepath)
    try:
        with path.open("r", encoding="utf-8") as handle:
            raw = json.load(handle)
    except Exception as exc:
        return {
            "file": filepath,
            "valid": False,
            "issues": [f"Failed to load receipt: {exc}"],
            "error": str(exc),
        }

    if isinstance(raw, dict) and "steps" in raw:
        return _verify_structured_receipt(path, raw, public_key)
    if isinstance(raw, list):
        return _verify_structured_receipt(path, raw, public_key)

    try:
        receipt = load_receipt(filepath)
        verification = verify_receipt(receipt)
        return {
            "file": filepath,
            "valid": verification["valid"],
            "issues": verification["issues"],
            "receipt_hash": verification["receipt_hash"],
            "instance_sha256": receipt.instance_sha256,
            "n": receipt.n,
            "m": receipt.m,
            "mu_total": receipt.mu_total,
            "computed_mu_total": verification["computed_mu_total"],
            "final_claim": receipt.final_claim,
            "step_count": len(receipt.steps),
            "version": receipt.version,
        }
    except Exception as exc:
        return {
            "file": filepath,
            "valid": False,
            "issues": [f"Failed to parse canonical receipt: {exc}"],
            "error": str(exc),
        }

def print_verification_report(results: list):
    """Print a human-readable verification report."""
    print("Thiele Machine Receipt Verification Report")
    print("=" * 50)

    total_valid = sum(1 for r in results if r["valid"])
    total_files = len(results)

    print(f"Files processed: {total_files}")
    print(f"Valid receipts: {total_valid}")
    print(f"Invalid receipts: {total_files - total_valid}")
    print()

    for result in results:
        status = "✓ VALID" if result["valid"] else "✗ INVALID"
        print(f"{status}: {result['file']}")

        if not result["valid"]:
            for issue in result["issues"]:
                print(f"  - {issue}")

        if "receipt_hash" in result:
            print(f"  Receipt hash: {result['receipt_hash'][:16]}...")
        if "instance_sha256" in result:
            print(f"  Instance hash: {result['instance_sha256'][:16]}...")
        if "mu_total" in result:
            print(f"  μ total: {result['mu_total']}")
        if "final_claim" in result:
            print(f"  Final claim: {result['final_claim']}")

        print()

def main():
    parser = argparse.ArgumentParser(description="Verify Thiele Machine computation receipts")
    parser.add_argument("files", nargs="+", help="Receipt files to verify")
    parser.add_argument("--json", action="store_true", help="Output results as JSON")
    parser.add_argument("--quiet", action="store_true", help="Suppress detailed output")
    parser.add_argument(
        "--public-key",
        type=Path,
        default=_default_public_key(),
        help="Path to the kernel verifying key (default: %(default)s)",
    )

    args = parser.parse_args()
    public_key = args.public_key

    results = []
    for filepath in args.files:
        if not os.path.exists(filepath):
            results.append({
                "file": filepath,
                "valid": False,
                "issues": ["File not found"]
            })
        else:
            results.append(verify_receipt_file(filepath, public_key))

    if args.json:
        print(json.dumps(results, indent=2))
    else:
        if not args.quiet:
            print_verification_report(results)

        # Exit with appropriate code
        all_valid = all(r["valid"] for r in results)
        sys.exit(0 if all_valid else 1)

if __name__ == "__main__":
    main()