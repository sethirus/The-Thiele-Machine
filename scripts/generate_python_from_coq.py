#!/usr/bin/env python3
"""
generate_python_from_coq.py

Generates Python instruction types from Coq kernel VMStep.v
This ensures Python VM types match the Coq specification exactly.

The Coq kernel is the single source of truth.
"""

import re
import sys
from pathlib import Path
from datetime import datetime

COQ_KERNEL_PATH = Path("coq/kernel/VMStep.v")
OUTPUT_PATH = Path("thielecpu/generated/vm_instructions.py")

def parse_coq_instructions(coq_file):
    """Extract instruction definitions from Coq kernel."""
    with open(coq_file, 'r') as f:
        content = f.read()
    
    # Find the vm_instruction inductive type
    inductive_match = re.search(
        r'Inductive vm_instruction :=\s*(.*?)(?=\n\nDefinition|^\(|^Inductive\s+\w+\s+:=)',
        content,
        re.MULTILINE | re.DOTALL
    )
    
    if not inductive_match:
        print("ERROR: Could not find vm_instruction inductive type")
        return []
    
    inductive_body = inductive_match.group(1)
    
    # Parse each instruction
    instructions = []
    pattern = r'\|\s+instr_(\w+)\s+([^\n]*)'
    
    for match in re.finditer(pattern, inductive_body):
        instr_name = match.group(1)
        params_str = match.group(2).strip()
        
        # Parse parameters
        params = []
        if params_str:
            # Extract parameter names and types
            param_pattern = r'\((\w+)\s*:\s*([^)]+)\)'
            for param_match in re.finditer(param_pattern, params_str):
                param_name = param_match.group(1)
                param_type = param_match.group(2).strip()
                params.append((param_name, param_type))
        
        instructions.append((instr_name, params))
    
    return instructions

def coq_type_to_python(coq_type):
    """Convert Coq type to Python type annotation."""
    if coq_type == "nat":
        return "int"
    elif coq_type == "string":
        return "str"
    elif coq_type == "bool":
        return "bool"
    elif coq_type == "list nat" or coq_type.startswith("list"):
        return "List[int]"
    elif coq_type == "ModuleID":
        return "int"  # ModuleID is typically nat
    elif coq_type == "lassert_certificate":
        return "'LassertCertificate'"
    elif coq_type == "list VMAxiom":
        return "List['VMAxiom']"
    else:
        return "Any"

def generate_python_class(instr_name, params):
    """Generate Python dataclass for an instruction."""
    class_name = f"Instr{instr_name.capitalize()}"
    
    lines = []
    lines.append("@dataclass")
    lines.append(f"class {class_name}:")
    lines.append(f'    """Generated from Coq: instr_{instr_name}"""')
    
    if not params:
        lines.append("    pass")
    else:
        for param_name, param_type in params:
            py_type = coq_type_to_python(param_type)
            lines.append(f"    {param_name}: {py_type}")
    
    return "\n".join(lines)

def generate_python_file(instructions):
    """Generate complete Python file with all instruction types."""
    lines = []
    
    # Header
    lines.append('"""')
    lines.append("vm_instructions.py")
    lines.append("")
    lines.append("AUTO-GENERATED from Coq kernel/VMStep.v")
    lines.append(f"Generated: {datetime.now().isoformat()}")
    lines.append("")
    lines.append("DO NOT EDIT THIS FILE MANUALLY")
    lines.append("Regenerate with: make generate-python")
    lines.append("")
    lines.append("This file provides Python type definitions that exactly match")
    lines.append("the Coq kernel specification, ensuring three-layer consistency.")
    lines.append('"""')
    lines.append("")
    lines.append("from dataclasses import dataclass")
    lines.append("from typing import List, Any, Union")
    lines.append("")
    lines.append("# Type aliases")
    lines.append("ModuleID = int")
    lines.append("")
    lines.append("# Forward declarations")
    lines.append("class LassertCertificate:")
    lines.append("    pass")
    lines.append("")
    lines.append("class VMAxiom:")
    lines.append("    pass")
    lines.append("")
    lines.append("# Instruction types (generated from Coq)")
    lines.append("")
    
    # Generate classes
    for instr_name, params in instructions:
        lines.append(generate_python_class(instr_name, params))
        lines.append("")
    
    # Union type
    lines.append("# Union of all instruction types")
    lines.append("VMInstruction = Union[")
    for i, (instr_name, _) in enumerate(instructions):
        class_name = f"Instr{instr_name.capitalize()}"
        comma = "," if i < len(instructions) - 1 else ""
        lines.append(f"    {class_name}{comma}")
    lines.append("]")
    lines.append("")
    
    # Cost extraction
    lines.append("def extract_mu_cost(instr: VMInstruction) -> int:")
    lines.append('    """Extract μ-cost from any instruction."""')
    lines.append("    return instr.mu_delta")
    lines.append("")
    
    # Metadata
    lines.append(f"# Total instructions: {len(instructions)}")
    lines.append("INSTRUCTION_COUNT = {}".format(len(instructions)))
    lines.append("")
    
    return "\n".join(lines)

def main():
    """Main generation logic."""
    print("=== Generating Python from Coq Kernel ===")
    print(f"Reading: {COQ_KERNEL_PATH}")
    
    if not COQ_KERNEL_PATH.exists():
        print(f"ERROR: {COQ_KERNEL_PATH} not found")
        sys.exit(1)
    
    # Parse Coq file
    instructions = parse_coq_instructions(COQ_KERNEL_PATH)
    
    if not instructions:
        print("ERROR: No instructions found in Coq kernel")
        sys.exit(1)
    
    print(f"Found {len(instructions)} instructions:")
    for instr_name, params in instructions:
        print(f"  - instr_{instr_name} ({len(params)} parameters)")
    
    # Generate Python code
    python_code = generate_python_file(instructions)
    
    # Write output
    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_PATH, 'w') as f:
        f.write(python_code)
    
    print(f"Generated: {OUTPUT_PATH}")
    print(f"Total lines: {len(python_code.splitlines())}")
    print("✅ Python generation complete")

if __name__ == "__main__":
    main()
