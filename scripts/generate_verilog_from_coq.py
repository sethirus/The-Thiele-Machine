#!/usr/bin/env python3
"""
generate_verilog_from_coq.py

Generates Verilog opcode definitions from Coq kernel VMStep.v
This ensures Verilog opcodes match the Coq specification exactly.

The Coq kernel is the single source of truth.
"""

import re
import sys
from pathlib import Path
from datetime import datetime

COQ_KERNEL_PATH = Path("coq/kernel/VMStep.v")
OUTPUT_PATH = Path("thielecpu/generated/opcode_definitions.vh")

# Opcode mapping (instruction name -> hex value)
OPCODE_MAP = {
    "pnew": "00",
    "psplit": "01",
    "pmerge": "02",
    "lassert": "03",
    "ljoin": "04",
    "mdlacc": "05",
    "pdiscover": "06",
    "xfer": "07",
    "pyexec": "08",
    "xor_load": "0A",
    "xor_add": "0B",
    "xor_swap": "0C",
    "xor_rank": "0D",
    "emit": "0E",
    "oracle_halts": "0F",
    "halt": "FF"
}

def parse_coq_instructions(coq_file):
    """Extract instruction definitions from Coq kernel."""
    with open(coq_file, 'r') as f:
        content = f.read()
    
    # Find the vm_instruction inductive type
    inductive_match = re.search(
        r'Inductive vm_instruction :=\s*(.*?)(?=\n\nDefinition|^\(|^Inductive\s+\w+\s+:=)',
        content,
        re.MULTILINE | re.DOTALL
    )
    
    if not inductive_match:
        print("ERROR: Could not find vm_instruction inductive type")
        return []
    
    inductive_body = inductive_match.group(1)
    
    # Parse each instruction
    instructions = []
    pattern = r'\|\s+instr_(\w+)\s'
    
    for match in re.finditer(pattern, inductive_body):
        instr_name = match.group(1)
        instructions.append(instr_name)
    
    return instructions

def generate_verilog_file(instructions):
    """Generate complete Verilog header file with all opcode definitions."""
    lines = []
    
    # Header
    lines.append("//")
    lines.append("// opcode_definitions.vh")
    lines.append("//")
    lines.append("// AUTO-GENERATED from Coq kernel/VMStep.v")
    lines.append(f"// Generated: {datetime.now().isoformat()}")
    lines.append("//")
    lines.append("// DO NOT EDIT THIS FILE MANUALLY")
    lines.append("// Regenerate with: make generate-verilog")
    lines.append("//")
    lines.append("// This file provides Verilog opcode definitions that exactly match")
    lines.append("// the Coq kernel specification, ensuring three-layer consistency.")
    lines.append("//")
    lines.append("")
    lines.append("`ifndef OPCODE_DEFINITIONS_VH")
    lines.append("`define OPCODE_DEFINITIONS_VH")
    lines.append("")
    lines.append("// Opcode definitions (generated from Coq)")
    lines.append("// Total instructions: {}".format(len(instructions)))
    lines.append("")
    
    # Generate parameter definitions
    for instr in instructions:
        if instr in OPCODE_MAP:
            opcode_hex = OPCODE_MAP[instr]
            param_name = f"OPCODE_{instr.upper()}"
            lines.append(f"parameter [7:0] {param_name:25s} = 8'h{opcode_hex};  // instr_{instr}")
        else:
            lines.append(f"// WARNING: No opcode mapping for instr_{instr}")
    
    lines.append("")
    lines.append("// Opcode validation function")
    lines.append("function automatic logic is_valid_opcode(input [7:0] opc);")
    lines.append("  case (opc)")
    
    # Generate case statement
    opcode_list = []
    for instr in instructions:
        if instr in OPCODE_MAP:
            param_name = f"OPCODE_{instr.upper()}"
            opcode_list.append(param_name)
    
    lines.append(f"    {', '.join(opcode_list)}: ")
    lines.append("      is_valid_opcode = 1'b1;")
    lines.append("    default:")
    lines.append("      is_valid_opcode = 1'b0;")
    lines.append("  endcase")
    lines.append("endfunction")
    lines.append("")
    
    # Generate instruction name lookup (for debugging)
    lines.append("// Instruction name lookup (for debugging)")
    lines.append("function automatic string get_instr_name(input [7:0] opc);")
    lines.append("  case (opc)")
    for instr in instructions:
        if instr in OPCODE_MAP:
            param_name = f"OPCODE_{instr.upper()}"
            lines.append(f'    {param_name:25s}: get_instr_name = "instr_{instr}";')
    lines.append('    default: get_instr_name = "INVALID";')
    lines.append("  endcase")
    lines.append("endfunction")
    lines.append("")
    
    # Footer
    lines.append("`endif // OPCODE_DEFINITIONS_VH")
    lines.append("")
    
    return "\n".join(lines)

def main():
    """Main generation logic."""
    print("=== Generating Verilog from Coq Kernel ===")
    print(f"Reading: {COQ_KERNEL_PATH}")
    
    if not COQ_KERNEL_PATH.exists():
        print(f"ERROR: {COQ_KERNEL_PATH} not found")
        sys.exit(1)
    
    # Parse Coq file
    instructions = parse_coq_instructions(COQ_KERNEL_PATH)
    
    if not instructions:
        print("ERROR: No instructions found in Coq kernel")
        sys.exit(1)
    
    print(f"Found {len(instructions)} instructions:")
    for instr in instructions:
        opcode = OPCODE_MAP.get(instr, "??")
        print(f"  - instr_{instr:15s} -> 0x{opcode}")
    
    # Generate Verilog code
    verilog_code = generate_verilog_file(instructions)
    
    # Write output
    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_PATH, 'w') as f:
        f.write(verilog_code)
    
    print(f"Generated: {OUTPUT_PATH}")
    print(f"Total lines: {len(verilog_code.splitlines())}")
    print("âœ… Verilog generation complete")

if __name__ == "__main__":
    main()
