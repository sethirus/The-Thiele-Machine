#!/usr/bin/env python3
"""Translate graph-colouring receipts into a Coq witness.

The script ingests the Act III receipts emitted by ``graph_coloring_demo.py``
for a single graph and produces a self-contained Coq file under
``coq/sandboxes``.  The generated development replays the strategic claims and
propagation order recorded in the receipts and states the theorem
``python_receipt_sound`` asserting that the Python execution matches the
formally defined ``thiele_run`` in ``VerifiedGraphSolver``.
"""

from __future__ import annotations

import argparse
import json
import textwrap
from pathlib import Path
from typing import Iterable, List, Mapping, Sequence

COLOUR_CONSTRUCTORS = {
    "RED": "Red",
    "GREEN": "Green",
    "BLUE": "Blue",
}

HEADER = """(*** Autogenerated by scripts/translate_receipts_to_coq.py.
      Do not edit by hand.  Regenerate via scripts/prove_it_all.sh. ***)"""


def _coq_list(items: Iterable[str]) -> str:
    rendered = "; ".join(items)
    return f"[ {rendered} ]" if rendered else "[]"


def _load_json(path: Path) -> Mapping[str, object]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def _claim_list(claims: Sequence[Mapping[str, object]]) -> List[str]:
    rendered: List[str] = []
    for entry in claims:
        node = int(entry["node"])
        colour = COLOUR_CONSTRUCTORS[str(entry["colour"]).upper()]
        rendered.append(f"({node}, {colour})")
    return rendered


def _propagation_nodes(entries: Sequence[Mapping[str, object]]) -> List[str]:
    return [str(int(entry["node"])) for entry in entries]


def _render_generated_module(
    claims: Sequence[Mapping[str, object]],
    propagation: Sequence[Mapping[str, object]],
    final_state: Mapping[str, object],
    mu_cost: int,
    targeted_checks: int,
    solver_queries: int,
) -> str:
    coq_claims = _coq_list(
        [f"({int(entry['node'])}, {COLOUR_CONSTRUCTORS[str(entry['colour']).upper()]})" for entry in claims]
    )
    propagation_nodes = _coq_list(_propagation_nodes(propagation))
    assignments = _coq_list(
        [
            f"({int(node)}, {COLOUR_CONSTRUCTORS[str(colour).upper()]})"
            for node, colour in sorted(
                ((int(key), value) for key, value in final_state.items()), key=lambda item: item[0]
            )
        ]
    )
    final_partial = textwrap.dedent(
        f"""{{|
  state_partial := canonical_partial;
  state_mu := {mu_cost};
  state_arith := {targeted_checks}
|}}"""
    ).strip()

    return textwrap.dedent(
        f"""
        {HEADER}

        Require Import List.
        Require Import Nat.
        Require Import Sandbox.VerifiedGraphSolver.

        Import ListNotations.
        Import VerifiedGraphSolver.

        Definition receipt_claims : list (nat * colour) := {coq_claims}.
        Definition receipt_propagation : list nat := {propagation_nodes}.

        Definition replay_claims (σ : thiele_state) : thiele_state :=
          fold_left (fun st '(node, colour) => claim st node colour) receipt_claims σ.

        Definition replay_propagation (σ : thiele_state) : thiele_state :=
          fold_left propagate_node receipt_propagation σ.

        Definition receipt_run : thiele_state :=
          replay_propagation (replay_claims thiele_empty).

        Definition receipt_solution : list (nat * colour) := {assignments}.

        Definition receipt_expected : thiele_state :=
          {final_partial}.

        Lemma receipt_run_matches_expected : receipt_run = receipt_expected.
        Proof.
          unfold receipt_run, receipt_expected, replay_propagation, replay_claims.
          vm_compute.
          reflexivity.
        Qed.

        Lemma thiele_run_matches_expected : thiele_run = receipt_expected.
        Proof.
          unfold receipt_expected, thiele_run.
          vm_compute.
          reflexivity.
        Qed.

        Theorem python_receipt_sound : receipt_run = thiele_run.
        Proof.
          transitivity receipt_expected; [apply receipt_run_matches_expected |].
          symmetry; apply thiele_run_matches_expected.
        Qed.

        (* Recorded metrics from the receipts: *)
        Definition receipt_mu_cost : nat := {mu_cost}.
        Definition receipt_targeted_checks : nat := {targeted_checks}.
        Definition receipt_solver_queries : nat := {solver_queries}.

        """
    ).strip() + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "act_dir",
        type=Path,
        help="Path to the Act III directory containing summary and reasoning JSON artefacts.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("coq/sandboxes/GeneratedProof.v"),
        help="Location for the generated Coq development.",
    )
    args = parser.parse_args()

    act_dir = args.act_dir
    if act_dir.is_file():
        act_dir = act_dir.parent
    summary_path = act_dir / "summary.json"
    reasoning_path = act_dir / "reasoning_summary.json"

    if not summary_path.exists():
        raise SystemExit(f"Missing summary.json in {act_dir}")
    if not reasoning_path.exists():
        raise SystemExit(f"Missing reasoning_summary.json in {act_dir}")

    summary = _load_json(summary_path)
    reasoning = _load_json(reasoning_path)

    mu_cost = int(round(float(summary.get("mu_cost", 0.0))))
    targeted_checks = int(summary.get("candidate_checks", 0))
    solver_queries = int(reasoning.get("oracle_queries", summary.get("solver_queries", 0)))

    coq_source = _render_generated_module(
        claims=reasoning.get("claims", []),
        propagation=reasoning.get("propagation", []),
        final_state=summary.get("solution", {}),
        mu_cost=mu_cost,
        targeted_checks=targeted_checks,
        solver_queries=solver_queries,
    )

    output_path = args.output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(coq_source, encoding="utf-8")
    print(f"Generated Coq proof at {output_path}")


if __name__ == "__main__":
    main()
