\documentclass[11pt, a4paper]{report}

\usepackage{amsmath, amssymb, amsthm}
\usepackage{geometry}
\usepackage{enumerate}
\usepackage{hyperref}

\geometry{margin=1in}

\title{\textbf{The Thiele Machine}\\ \large A Mathematical Specification}
\author{Formal Specification}
\date{}

% Environments
\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{axiom}{Axiom}[chapter]
\newtheorem{example}{Example}[chapter]

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}

% Macros
\newcommand{\N}{\mathbb{N}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\Sspace}{\mathcal{S}}
\newcommand{\Ispace}{\mathcal{I}}
\newcommand{\Gspace}{\mathcal{G}}
\newcommand{\Mspace}{\mathcal{M}}
\newcommand{\Rspace}{\mathcal{R}}
\newcommand{\muled}{\mu_{\text{ledger}}}
\newcommand{\trace}{\tau}

\begin{document}

\maketitle

\begin{abstract}
This document provides a standalone mathematical specification of the Thiele Machine, a formal model of computation that explicitly accounts for the cost of structural information. The definitions, axioms, and theorems presented here are derived directly from the machine-checked Coq formalization. This model extends classical computation by introducing a conserved resource, $\mu$, which bounds the extraction of structural information from the state space.
\end{abstract}

\tableofcontents

\chapter{Introduction}
The Thiele Machine is a computational model designed to investigate the thermodynamic cost of structure. Unlike a Turing Machine, which treats all state transitions as cost-equivalent (or measures cost only in time/space), the Thiele Machine assigns a specific cost, $\mu$, to operations that extract or assert structural information.

This specification defines the machine formally using standard mathematical notation. It covers:
\begin{enumerate}
    \item The State Space $\Sspace$ and its components.
    \item The Instruction Set $\Ispace$ and Cost Model $\mu$.
    \item The Operational Semantics (Transition Function $\delta$).
    \item The Core Theorems, including the ``No Free Insight'' theorem.
\end{enumerate}

\chapter{The State Space}

\section{Primitives}
Let $\N$ be the set of natural numbers $\{0, 1, 2, \dots\}$.
Let $\B = \{0, 1\}$ be the set of booleans.
Let $\Sigma$ be a finite alphabet for axioms and formula strings.

\section{Regions and Modules}
A \textbf{Region} $R$ is a finite subset of $\N$.
To ensure canonical representation, we define a normalization function.
\begin{definition}[Normalized Region]
Let $L$ be a list of natural numbers. The function $\text{norm}(L)$ returns the sorted list of unique elements of $L$. A Region is operationally identified with its normalized form.
\end{definition}

A \textbf{Module} $M$ is a tuple $(R_M, A_M)$ where:
\begin{itemize}
    \item $R_M \subset \N$ is a normalized region.
    \item $A_M \subset \Sigma^*$ is a set of axioms (strings) attached to the module.
\end{itemize}

\section{The Partition Graph}
The machine organizes state into a \textbf{Partition Graph} $\Gspace$.
\begin{definition}[Partition Graph]
A partition graph $G \in \Gspace$ is a tuple $(N_{id}, \mathcal{T})$ where:
\begin{itemize}
    \item $N_{id} \in \N$ is the next available module ID.
    \item $\mathcal{T}$ is a mapping (finite partial function) from ModuleID $id \in \{0, \dots, N_{id}-1\}$ to Modules $M$.
\end{itemize}
\end{definition}

\begin{axiom}[Well-Formedness]
A graph $G = (N_{id}, \mathcal{T})$ is well-formed if $\text{dom}(\mathcal{T}) \subseteq \{0, \dots, N_{id}-1\}$.
\end{axiom}

\section{Control and Status Registers (CSRs)}
The CSR state $C$ is a tuple $(c_{cert}, c_{status}, c_{err}) \in \N^3$:
\begin{itemize}
    \item $c_{cert}$: Address of the current certificate checksum.
    \item $c_{status}$: General status register.
    \item $c_{err}$: Error code register.
\end{itemize}

\section{Machine State}
\begin{definition}[VM State]
The complete state of the Thiele Machine $\Sspace$ is a 7-tuple:
\[ S = (G, C, R, Mem, PC, \mu, err) \]
where:
\begin{enumerate}
    \item $G \in \Gspace$: The partition graph.
    \item $C \in \N^3$: CSR state.
    \item $R \in \N^{32}$: Register file (32 $\times$ 32-bit words).
    \item $Mem \in \N^{256}$: Main memory (256 $\times$ 32-bit words).
    \item $PC \in \N$: Program counter.
    \item $\mu \in \N$: The $\mu$-ledger (accumulated structural cost).
    \item $err \in \B$: Global error flag.
\end{enumerate}
\end{definition}

\chapter{Instruction Set and Cost Model}

The machine follows a Harvard architecture where the program is a sequence of instructions. The set of valid instructions $\Ispace$ is fixed.

\section{The $\mu$-Cost Function}
Every instruction $i \in \Ispace$ carries an explicit cost parameter $\Delta\mu \in \N$.
Let $\text{cost}(i)$ denote this parameter.

\begin{definition}[Operations and Costs]
The instruction set is partitioned into three categories.

\subsection{1. Structural Operations (Partition Graph)}
These operations modify $G$.
\begin{itemize}
    \item \texttt{PNEW($R$, $\Delta\mu$)}: Create a new module with region $R$.
    \item \texttt{PSPLIT($m$, $L$, $R$, $\Delta\mu$)}: Split module $m$ into disjoint regions $L, R$.
    \item \texttt{PMERGE($m_1$, $m_2$, $\Delta\mu$)}: Merge modules $m_1, m_2$.
    \item \texttt{PDISCOVER($m$, $E$, $\Delta\mu$)}: Attach evidence $E$ to module $m$.
\end{itemize}

\subsection{2. Logical Operations (Information)}
These operations interact with the information content.
\begin{itemize}
    \item \texttt{LASSERT($m$, $\phi$, $\pi$, $\Delta\mu$)}: Assert formula $\phi$ on module $m$ with proof/model $\pi$.
    \item \texttt{LJOIN($c_1$, $c_2$, $\Delta\mu$)}: Join two certificate checksums.
    \item \texttt{REVEAL($m$, $n$, $\pi$, $\Delta\mu$)}: Reveal $n$ bits of structure from $m$ with proof $\pi$. \textbf{Operationally, this is the primary source of $\mu$-cost.}
    \item \texttt{EMIT($m$, $p$, $\Delta\mu$)}: Emit payload $p$ from module $m$.
\end{itemize}

\subsection{3. Computational Operations (Reversible ALU)}
These operations are standard reversible updates to registers/memory.
\begin{itemize}
    \item \texttt{XFER}, \texttt{XOR\_LOAD}, \texttt{XOR\_ADD}, \texttt{XOR\_SWAP}, \texttt{XOR\_RANK}.
\end{itemize}
\end{definition}

\section{Operational Cost Definition}
The operational cost function $K: \Ispace \times \Sspace \to \N$ defines the ``intrinsic'' cost of an operation type.
\begin{itemize}
    \item $K(\texttt{REVEAL}, s) = 1$.
    \item $K(\texttt{LASSERT}, s) = 1$ (if structure added).
    \item $K(\text{other}, s) = 0$.
\end{itemize}
Note: The instruction parameter $\Delta\mu$ must match this intrinsic cost for a program to be valid/honest, but the kernel simply applies $\Delta\mu$.

\chapter{Operational Semantics}

The transition function $\delta: \Sspace \times \Ispace \to \Sspace$ defines the evolution of the system.

\section{Transition Rules}
Let $S = (G, C, R, Mem, PC, \mu, err)$.
Let $S' = \delta(S, i)$.

\subsection{State Evolution}
For any instruction $i$ with parameter $\Delta\mu_i$:
\begin{enumerate}
    \item \textbf{PC Update}: $PC' = PC + 1$.
    \item \textbf{$\mu$-Ledger Update}: $\mu' = \mu + \Delta\mu_i$.
    \item \textbf{Error Latching}: $err' = err \lor \text{fail}(S, i)$.
\end{enumerate}

\subsection{Monotonicity}
\begin{theorem}[$\mu$-Conservation]
The ledger $\mu$ is monotonically increasing.
\[ \forall S, i. \quad \delta(S, i).\mu \ge S.\mu \]
\end{theorem}
\begin{proof}
Immediate from the definition $\mu' = \mu + \Delta\mu_i$ and $\Delta\mu_i \in \N$ (so $\Delta\mu_i \ge 0$).
\end{proof}

\section{Execution Traces}

A \textbf{Trace} $\tau$ is a finite sequence of instructions: $\tau = [i_0, i_1, \dots, i_k] \in \Ispace^*$.

\begin{definition}[Trace Execution]
Let $S_0$ be an initial state. The execution of a trace $\tau$ is defined recursively:
\begin{align*}
    \text{Run}([], S) &= S \\
    \text{Run}(i :: \tau', S) &= \text{Run}(\tau', \delta(S, i))
\end{align*}
\end{definition}

\begin{definition}[Receipts]
The \textbf{Receipts} of an execution is the subsequence of instructions in $\tau$ that are structurally significant (typically the full trace, or a projection).
In the formal model, we define a Receipt as the instruction itself, as it carries the record of the operation.
\[ \text{Receipts}(\tau) = \tau \]
Operationally, verifiable receipts are cryptographically bounded to the transition, satisfying Axiom A1 (Non-Forgeability).
\end{definition}

\section{Selected Semantics}

\subsection{PNEW (Partition New)}
$\text{PNEW}(Region, \Delta\mu)$:
1. Normalize $Region \to R_{norm}$.
2. If $R_{norm}$ exists in $G$, return $G$ (idempotent).
3. Else, add $(R_{norm}, \emptyset)$ to $G$.
Cost: $\Delta\mu$ (typically 0).

\subsection{REVEAL}
$\text{REVEAL}(m, n, \pi, \Delta\mu)$:
1. Update CSRs with checksum of $\pi$.
Cost: $\Delta\mu$ (typically 1 per invocation).

\subsection{LASSERT (Logical Assertion)}
$\text{LASSERT}(m, \phi, \pi, \Delta\mu)$:
1. Verify the proof $\pi$ for formula $\phi$ against module $m$'s existing axioms.
   - If $\pi$ is an UNSAT proof (e.g., LRAT), verification is purely syntactic.
   - If $\pi$ is a SAT model, check satisfaction.
2. If valid, append $\phi$ to $A_m$.
3. If invalid, set $err \gets \text{true}$.
This mechanism replaces Oracle calls with verifiable proofs.


\chapter{No Free Insight}

The core theoretical result of the Thiele Machine is that narrowing the search space (gaining insight) requires paying $\mu$-cost.

\section{Definitions}

\begin{definition}[Receipt Predicate]
Let $\mathcal{O}$ be the set of observation receipts (logs of emitted values).
A \textbf{Receipt Predicate} $P: \mathcal{O} \to \B$ is a computable function that accepts or rejects a history.
\end{definition}

\begin{definition}[Strength]
Predicate $P_1$ is \textbf{stronger} than $P_2$ ($P_1 \le P_2$) if:
\[ \forall o \in \mathcal{O}. \quad P_1(o) = 1 \implies P_2(o) = 1 \]
$P_1$ is \textbf{strictly stronger} ($P_1 < P_2$) if $P_1 \le P_2$ and $\exists o. P_2(o)=1 \land P_1(o)=0$.
\end{definition}

\begin{definition}[Certification]
A trace $\tau$ \textbf{certifies} $P$ if:
\begin{enumerate}
    \item The execution succeeds ($err = \text{false}$).
    \item A specific certificate flag is set ($has\_supra\_cert$).
    \item The output satisfies $P$.
\end{enumerate}
\end{definition}

\begin{definition}[Structure Addition]
We define a predicate $\text{HasStructureAddition}(\tau)$ which is true iff the trace $\tau$ contains an instruction that increases structural complexity (operationally mapped to \texttt{REVEAL}, \texttt{LASSERT}, etc.).
\end{definition}

\section{The Theorem}

\begin{theorem}[No Free Insight]
Let $P_{weak}$ and $P_{strong}$ be receipt predicates such that $P_{strong} < P_{weak}$.
If a trace $\tau$ certifies $P_{strong}$, then $\tau$ must contain a structure addition event.
\[ \text{Certified}(\tau, P_{strong}) \implies \text{HasStructureAddition}(\tau) \]
\end{theorem}

\begin{proof}[Proof Sketch]
The proof relies on four axioms maintained by the kernel:
\begin{enumerate}
    \item \textbf{A1 Non-Forgeability}: Execution receipts faithfully reflect operations.
    \item \textbf{A2 Monotonicity}: $\mu$ cost is additive and permanent.
    \item \textbf{A3 Locality}: Operations on module $M$ do not affect disjoint module $N$.
    \item \textbf{A4 Underdetermination}: Partition structure alone (without REVEAL) is insufficient to distinguish $P_{strong}$ from $P_{weak}$ if they are compatible with the same graph topology.
\end{enumerate}
To certify $P_{strong}$, one must exclude the cases allowed by $P_{weak}$ but rejected by $P_{strong}$. By A4, this requires information not present in the base partition. By definition, adding this information is a \texttt{REVEAL} or equivalent operation. By the operational semantics, such operations enable the certificate flag ($has\_supra\_cert$). Thus, the certification implies the event.
\end{proof}

\begin{corollary}[Cost of Insight]
Since structure addition operations carry non-zero $\mu$-cost (by definition of honest accounting), gaining insight (strengthening the predicate) implies paying $\Delta\mu > 0$.
\end{corollary}

\chapter{Computational Universality}

A crucial property of the Thiele Machine is that it subsumes classical computation. We prove this via a chain of reductions: Turing Machines (TM) $\to$ Minsky Counter Machines $\to$ Thiele Machine.

\section{Minsky Machine Embedding}

We utilize the standard 2-counter Minsky machine model (or its 3-counter variant for easier proofs).
\begin{definition}[Minsky Configuration]
A state in the Minsky machine is a tuple $(q, r_1, r_2)$ where $q$ is the state and $r_1, r_2 \in \N$ are counters.
\end{definition}

\begin{theorem}[Abstract Simulation]
For every Turing Machine $T$, there exists a Minsky machine $M$ and a simulation relation $R$ such that $M$ simulates $T$ step-by-step.
The simulation encodes the tape $t$ into two integers (left and right of head) using a generating function:
\[ Left = \sum_{i=0}^{head-1} t[head-1-i] 2^i, \quad Right = \sum_{i=0}^{len-head-1} t[head+i] 2^i \]
This proves $TM \preceq Minsky$.
\end{theorem}

\section{Thiele Machine Completeness}
The Thiele Machine can trivially simulate a Minsky machine using its registers and reversible ALU operations (\texttt{XOR\_ADD}, \texttt{XOR\_SWAP}, etc.) to implement increments/decrements.
Consequently, the Thiele Machine is Turing-complete for $\mu$-unbounded executions.
\[ TM \preceq Minsky \preceq Thiele \]

\chapter{Limits of Computation}

While Turing-complete, the Thiele Machine makes explicit the cost of resolving undecidable propositions.

\section{Halting Undecidability}
\begin{theorem}[Diagonal Argument]
No total computable function can decide the halting problem for the Thiele Machine itself.
Proof: Standard diagonalization. Construct a program $Q$ that halts iff Decider $D(Q)$ says $Q$ diverges.
\end{theorem}

\section{Oracle Impossibility}
The instruction \texttt{ORACLE\_HALTS} allows querying an oracle. The formal model restricts its cost.
\begin{theorem}[Oracle Cost Lower Bound]
Any oracle that correctly resolves $n$ independent halting queries must charge $\Delta\mu \ge n$.
\[ \text{Cost}(n \text{ queries}) \in \Omega(n) \]
\end{theorem}
\begin{proof}
By the No Free Insight theorem, gaining 1 bit of information (halt vs diverge) about an undecidable proposition reduces the entropy of the possible world-states by 1 bit. To maintain information conservation, the ledger $\mu$ must increase by at least 1 unit per query.
A zero-cost oracle ($\Delta\mu=0$) is logically inconsistent with the Information Conservation axiom.
\end{proof}

\chapter{Isomorphism to Physics}

The Thiele Machine construction is isomorphic to a hidden-variable theory where ``hidden variables'' are costly structrual information.

\section{The Mapping}
\begin{enumerate}
    \item \textbf{Cost as Energy}: The $\mu$-ledger corresponds to the thermodynamic cost of erasing/writing information.
    \item \textbf{Observation as Measurement}: \texttt{REVEAL} corresponds to a quantum measurement that collapses the state (selects a specific history).
    \item \textbf{Partition as Space}: The partition graph defines the locality structure (spacetime).
\end{enumerate}

\chapter{Emergent Spacetime}

Spacetime is not adequate in the Thiele Machine; it is emergent from the cost structure of the partition graph.

\section{The $\mu$-Metric}
We define a metric based on the structural cost distance between states.

\begin{definition}[$\mu$-Distance]
For any two states $S_1, S_2 \in \Sspace$ connected by a trace $\tau$, the distance is the minimum cost required to traverse:
\[ d_\mu(S_1, S_2) = \min_{\tau: S_1 \xrightarrow{\tau} S_2} \sum_{i \in \tau} \text{cost}(i) \]
\end{definition}

\begin{theorem}[Metric Properties]
This function $d_\mu$ satisfies the axioms of a metric space (positivity, symmetry, triangle inequality) strictly for reversible paths. For irreversible paths (monotonic $\mu$), it defines a directed causal order.
\end{theorem}

\section{Causal Cones}
\begin{definition}[Future Light Cone]
The future light cone of state $S$, denoted $C^+(S)$, is the set of all states $S'$ reachable with $\Delta\mu \le \mu_{max}$.
\[ C^+(S) = \{ S' \mid \exists \tau. S \xrightarrow{\tau} S' \land \text{cost}(\tau) \le \text{Budget} \} \]
\end{definition}
This definition recovers the causal structure of Special Relativity, where $c$ (speed of light) corresponds to the maximum rate of information processing (1 bit per $\mu$).

\chapter{Information Causality}

The principle of Information Causality states that the information gain usable by Bob cannot exceed the classical communication from Alice. In the Thiele Machine, this is a tautology of the cost model.

\section{Mutual Information Bound}
Let $A$ comprise Alice's inputs and $B$ be Bob's guess of Alice's inputs.
\begin{theorem}[IC Bound]
\[ \sum_{i} I(x_i : y_i | b) \le \Delta\mu_{channel} \]
The sum of mutual information about Alice's dataset $x$ that Bob can recover is bounded by the capacity of the channel, which in the Thiele Machine is explicitly paid for in $\mu$.
\end{theorem}

\section{No-Signaling}
\begin{theorem}[Observational No-Signaling]
Local operations on Module $M_A$ cannot change the statistics of measurements on disjoint Module $M_B$ unless a message (carrying $\mu$-cost) is passed between them.
Proof derived from \texttt{SpacetimeEmergence.v}: The partition graph topology ensures independent tensor factors for disjoint regions.
\end{theorem}

\chapter{Derivation of Physical Laws}

The most significant result is the derivation of quantum mechanical laws from pure information accounting.

\section{The Born Rule}
Standard QM postulates the Born rule $P(x) = |\psi(x)|^2$. We derive it.

\begin{definition}[Measurement $\mu$-Cost]
For a state with purity vector $(x,y,z)$ on the Bloch sphere, the information cost of measurement is defined as the reduction in entropy:
\[ \text{Cost}(x,y,z) = \frac{1 - (x^2 + y^2 + z^2)}{2} \]
For pure states ($r^2=1$), cost is 0. For mixed states, cost is positive.
\end{definition}

\begin{theorem}[Uniqueness of Born Rule]
The Born rule is the unique probability assignment $P$ satisfying:
\begin{enumerate}
    \item Normalization ($\sum P = 1$) and Positivity ($P \ge 0$).
    \item Linearity in the state vector.
    \item $\mu$-Consistency: The expected information gain equals the $\mu$-cost.
\end{enumerate}
\end{theorem}

\section{The Tsirelson Bound (CHSH)}
The CHSH inequality bound depends on the allowed information cost.

\begin{theorem}[Generalized Bound]
Let $S_{CHSH}$ be the correlation value.
\begin{itemize}
    \item If $\mu_{allowed} = 0$: The system is confined to a local hidden variable model. $S \le 2$ (Bell Bound).
    \item If $\mu_{allowed} > 0$ (limited): The system can violate Bell inequalities.
    \item The specific value $2\sqrt{2}$ (Tsirelson bound) emerges as the maximum correlation effectively purchasable when $\mu$-cost matches the entropy of entanglement.
    \item If $\mu \to \infty$: The system approaches the No-Signaling bound $S \le 4$ (PR-Box).
\end{itemize}
This derivation removes the ``magic'' of $2\sqrt{2}$ -- it is simply the point where the informational cost of correlation balances the entropic budget.
\end{theorem}

\chapter{Falsifiable Predictions}

The model makes specific predictions that differ from standard QM in high-energy or high-complexity regimes.

\section{Linear Scaling of Structure}
Standard Quantum Mechanics assumes the Hilbert space dimension grows exponentially, but operations are linear algebra. The Thiele Machine predicts a computational cost for maintaining specific superpositions.
\begin{axiom}[Linear Scaling]
The $\mu$-cost of maintaining coherence of $N$ entangled qubits scales as $O(N)$ per time step.
\end{axiom}
\textbf{Prediction}: Large-scale quantum computers will face a "decoherence noise floor" that is not technical but fundamental, proportional to the structural complexity of the entanglement.

\section{Metric Deformation}
Since distance $d_\mu$ is a function of information content, regions of high information density (high structural complexity) effectively ``expand'' the metric distance.
\textbf{Prediction}: In high-complexity computations, effective signal latency will increase relative to vacuum speed of light.

\end{document}
