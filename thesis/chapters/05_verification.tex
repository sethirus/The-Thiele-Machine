\section{Why Formal Verification?}

\subsection{The Limits of Testing}

Testing can find bugs, but it cannot prove their absence. If you test a sorting algorithm on 1000 inputs, you have evidence it works on those 1000 inputs---but there are infinitely many possible inputs. Formal verification replaces empirical sampling with universal quantification.

\textbf{Formal verification} proves properties hold for \textit{all} inputs. When I prove "$\mu$ is monotonically non-decreasing," I don't test it on examples---I prove it mathematically.
In this project, “all inputs” means all possible states and instruction traces compatible with the formal semantics. The proofs quantify over arbitrary \texttt{VMState} values and instructions, not over a fixed test suite. This is why the proofs must be grounded in precise definitions: without the exact state and step definitions, a universal statement would be meaningless.

\subsection{The Coq Proof Assistant}

Coq is an interactive theorem prover based on dependent type theory. A Coq proof is:
\begin{itemize}
    \item \textbf{Machine-checked}: The computer verifies every step
    \item \textbf{Constructive}: Proofs can be extracted to executable code
    \item \textbf{Permanent}: Once proven, the result is certain (assuming Coq's kernel is correct)
\end{itemize}
The guarantees come from the small, trusted kernel of Coq. Every lemma in the thesis is checked against that kernel, and extraction produces executable code whose behavior is justified by the same proofs. This matters because the extracted runner is used as an oracle in isomorphism tests; the proof context and the executable context are tied to the same semantics.

\subsection{The Zero-Admit Standard}

The Thiele Machine uses an unusually strict standard:
\begin{itemize}
    \item \textbf{No \texttt{Admitted}}: Every theorem must be fully proven
    \item \textbf{No \texttt{admit.}}: No tactical shortcuts inside proofs
    \item \textbf{No \texttt{Axiom}}: No unproven assumptions (except foundational logic)
\end{itemize}

This standard is enforced automatically. Any commit introducing an admit fails CI. This matters because it guarantees every theorem in the active proof tree is fully discharged.
The enforcement mechanism is \path{scripts/inquisitor.py}, which scans the Coq tree and reports violations. The strictness is not ceremonial: it ensures that the theorem statements presented in this chapter are actually complete and therefore reusable as axioms in subsequent reasoning.

\subsection{What I Prove}

The key theorems proven in Coq are:
\begin{enumerate}
    \item \textbf{Observational No-Signaling}: Operations on one module cannot affect observables of other modules
    \item \textbf{$\mu$-Conservation}: The $\mu$-ledger never decreases
    \item \textbf{No Free Insight}: Strengthening certification requires explicit structure addition
    \item \textbf{Gauge Invariance}: Partition structure is invariant under $\mu$-shifts
\end{enumerate}
Each of these theorems has a concrete home in the Coq tree: observational no-signaling is developed in files such as \path{ObserverDerivation.v}, $\mu$-conservation is proven in \path{MuLedgerConservation.v}, and No Free Insight appears in \path{NoFreeInsight.v} and \path{MuNoFreeInsightQuantitative.v}. The names matter because they pin the prose to specific proof artifacts a reader can inspect.

\subsection{How to Read This Chapter}

This chapter explains the proof structure and key statements. If you are unfamiliar with Coq:
\begin{itemize}
    \item \texttt{Theorem}, \texttt{Lemma}: Statements to prove
    \item \texttt{Proof. ... Qed.}: The proof itself
    \item \texttt{forall}: For all values of this type
    \item \texttt{->}: Implies
    \item \texttt{/\textbackslash}: And (conjunction)
    \item \texttt{\textbackslash/}: Or (disjunction)
\end{itemize}

Focus on understanding the \textit{statements} (what I prove), not the proof details. Every statement is written so it can be re-derived from the definitions given in Chapters 3 and 4.

\section{The Formal Verification Campaign}

The credibility of the Thiele Machine rests on machine-checked proofs. This chapter documents the verification campaign that culminated in a full removal of \texttt{Admitted}, \texttt{admit.}, and \texttt{Axiom} declarations from the active Coq tree. The practical consequence is rebuildability: a reader can re-implement the definitions and re-prove the same claims without relying on hidden assumptions.

All proofs are verified by Coq 8.18.x. The Inquisitor enforces this invariant: any commit introducing an admit or axiom fails CI.

\section{Proof Architecture}

\subsection{Conceptual Hierarchy}

The proof corpus is organized by concept rather than by implementation detail:
\begin{itemize}
    \item \textbf{State and partitions}: definitions of the machine state, partition graph, and normalization.
    \item \textbf{Step semantics}: the instruction set and its inductive transition rules.
    \item \textbf{Certification and receipts}: the logic of certificates and trace decoding.
    \item \textbf{Conservation and locality}: theorems about $\mu$-monotonicity and no-signaling.
    \item \textbf{Impossibility theorems}: No Free Insight and its corollaries.
\end{itemize}

The goal is not to “encode” the implementation, but to define a minimal semantics from which every implementation can be reconstructed. Each later proof depends only on earlier definitions and lemmas, so the dependency structure is acyclic and reproducible.

\subsection{Dependency Sketch}

The proofs build outward from the state and step definitions: first the operational semantics, then conservation/locality lemmas, and finally the impossibility results that rely on those invariants. The ordering is important: no theorem about $\mu$ or locality is used before the step relation is fixed.

\section{State Definitions: Foundation Layer}

\subsection{The State Record}

\begin{lstlisting}
Record VMState := {
  vm_graph : PartitionGraph;
  vm_csrs : CSRState;
  vm_regs : list nat;
  vm_mem : list nat;
  vm_pc : nat;
  vm_mu : nat;
  vm_err : bool
}.
\end{lstlisting}
The record is not just a convenient bundle. It encodes the exact pieces of state that the theorems quantify over, and it matches the projection used in cross-layer tests. The constants \texttt{REG\_COUNT} and \texttt{MEM\_SIZE} in \path{coq/kernel/VMState.v} fix the widths, and helper functions such as \texttt{read\_reg} and \texttt{write\_reg} define the operational meaning of register access.

\subsection{Canonical Region Normalization}

Regions are stored in canonical form to make observational equality well-defined:
\begin{lstlisting}
Definition normalize_region (region : list nat) : list nat :=
  nodup Nat.eq_dec region.
\end{lstlisting}

\begin{theorem}[Idempotence]
\begin{lstlisting}
Lemma normalize_region_idempotent : forall region,
  normalize_region (normalize_region region) = normalize_region region.
\end{lstlisting}
\end{theorem}

\begin{proof}
By \texttt{nodup\_fixed\_point}: applying \texttt{nodup} twice yields the same result, so normalization is idempotent and comparisons are stable.
\end{proof}
This lemma is more than a tidying step. Observational equality depends on normalized regions; idempotence guarantees that repeated normalization does not change what an observer sees, which is vital when a proof chains multiple graph operations together.

\subsection{Graph Well-Formedness}

\begin{lstlisting}
Definition well_formed_graph (g : PartitionGraph) : Prop :=
  all_ids_below g.(pg_modules) g.(pg_next_id).
\end{lstlisting}

\begin{theorem}[Preservation Under Add]
\begin{lstlisting}
Lemma graph_add_module_preserves_wf : forall g region axioms g' mid,
  well_formed_graph g ->
  graph_add_module g region axioms = (g', mid) ->
  well_formed_graph g'.
\end{lstlisting}
\end{theorem}
Well-formedness only enforces the ID discipline (no module has an ID greater than or equal to \texttt{pg\_next\_id}). The key point is that this property is strong enough to prevent stale references while weak enough to be preserved by every graph operation. Disjointness and coverage are handled by operation-specific lemmas so that the global invariant does not overfit any single instruction.

\begin{theorem}[Preservation Under Remove]
\begin{lstlisting}
Lemma graph_remove_preserves_wf : forall g mid g' m,
  well_formed_graph g ->
  graph_remove g mid = Some (g', m) ->
  well_formed_graph g'.
\end{lstlisting}
\end{theorem}

\section{Operational Semantics}

\subsection{The Instruction Type}

\begin{lstlisting}
Inductive vm_instruction :=
| instr_pnew (region : list nat) (mu_delta : nat)
| instr_psplit (module : ModuleID) (left right : list nat) (mu_delta : nat)
| instr_pmerge (m1 m2 : ModuleID) (mu_delta : nat)
| instr_lassert (module : ModuleID) (formula : string)
    (cert : lassert_certificate) (mu_delta : nat)
| instr_ljoin (cert1 cert2 : string) (mu_delta : nat)
| instr_mdlacc (module : ModuleID) (mu_delta : nat)
| instr_pdiscover (module : ModuleID) (evidence : list VMAxiom) (mu_delta : nat)
| instr_xfer (dst src : nat) (mu_delta : nat)
| instr_pyexec (payload : string) (mu_delta : nat)
| instr_chsh_trial (x y a b : nat) (mu_delta : nat)
| instr_xor_load (dst addr : nat) (mu_delta : nat)
| instr_xor_add (dst src : nat) (mu_delta : nat)
| instr_xor_swap (a b : nat) (mu_delta : nat)
| instr_xor_rank (dst src : nat) (mu_delta : nat)
| instr_emit (module : ModuleID) (payload : string) (mu_delta : nat)
| instr_reveal (module : ModuleID) (bits : nat) (cert : string) (mu_delta : nat)
| instr_oracle_halts (payload : string) (mu_delta : nat)
| instr_halt (mu_delta : nat).
\end{lstlisting}

\subsection{The Step Relation}

\begin{lstlisting}
Inductive vm_step : VMState -> vm_instruction -> VMState -> Prop := ...
\end{lstlisting}

Each instruction has one or more step rules. Key properties:
\begin{itemize}
    \item \textbf{Deterministic}: Each (state, instruction) pair has at most one successor when its preconditions hold.
    \item \textbf{Partial on invalid inputs}: Instructions with invalid certificates or failed structural checks can be undefined.
    \item \textbf{Cost-charging}: Every rule updates \texttt{vm\_mu} by the declared instruction cost.
\end{itemize}
The error latch is explicit in the step rules. For example, \texttt{PSPLIT} and \texttt{PMERGE} each have “failure” rules in \path{coq/kernel/VMStep.v} that leave the graph unchanged but set the error CSR and latch \texttt{vm\_err}. This design makes error propagation explicit and therefore available to proofs, rather than being implicit behavior of an implementation language.

This gives a complete operational semantics: given a well-formed state and a valid instruction, the next state is uniquely determined.

\section{Conservation and Locality}

This file establishes the physical laws of the Thiele Machine kernel—properties that hold for all executions without exception.

\subsection{Observables}

\begin{lstlisting}
Definition Observable (s : VMState) (mid : nat) : option (list nat * nat) :=
  match graph_lookup s.(vm_graph) mid with
  | Some modstate => Some (normalize_region modstate.(module_region), s.(vm_mu))
  | None => None
  end.

Definition ObservableRegion (s : VMState) (mid : nat) : option (list nat) :=
  match graph_lookup s.(vm_graph) mid with
  | Some modstate => Some (normalize_region modstate.(module_region))
  | None => None
  end.
\end{lstlisting}

Note: Axioms are \textbf{not} observable—they are internal implementation details. Observables contain only partition regions and the $\mu$-ledger, which is the cost-visible interface of the model.
The distinction between \texttt{Observable} and \texttt{ObservableRegion} is deliberate. \texttt{Observable} includes the $\mu$-ledger to capture the paid structural cost, while \texttt{ObservableRegion} strips the $\mu$ field so that no-signaling can be stated purely in terms of partition structure. This avoids a loophole where a proof of locality could fail merely because the $\mu$-ledger changed, even though no region membership changed.

\subsection{Instruction Target Sets}

\begin{lstlisting}
Definition instr_targets (instr : vm_instruction) : list nat :=
  match instr with
  | instr_pnew _ _ => []
  | instr_psplit mid _ _ _ => [mid]
  | instr_pmerge m1 m2 _ => [m1; m2]
  | instr_lassert mid _ _ _ => [mid]
  ...
  end.
\end{lstlisting}

\subsection{The No-Signaling Theorem}

\begin{theorem}[Observational No-Signaling]
\begin{lstlisting}
Theorem observational_no_signaling : forall s s' instr mid,
  well_formed_graph s.(vm_graph) ->
  mid < pg_next_id s.(vm_graph) ->
  vm_step s instr s' ->
  ~ In mid (instr_targets instr) ->
  ObservableRegion s mid = ObservableRegion s' mid.
\end{lstlisting}
\end{theorem}

\begin{proof}
By case analysis on the instruction. For each instruction type:
\begin{enumerate}
    \item If \texttt{mid} is not in \texttt{instr\_targets}, the instruction does not modify module \texttt{mid}
    \item Graph operations (pnew, psplit, pmerge) only affect targeted modules
    \item Logical operations (lassert, ljoin) only affect targeted module axioms (which are not observable)
    \item Memory operations (xfer, xor\_*) do not modify the partition graph
    \item Therefore, \texttt{ObservableRegion} is unchanged
\end{enumerate}
\end{proof}

\textbf{Physical Interpretation}: You cannot send signals to a remote module by operating on local state. This is the computational analog of Bell locality.

\subsection{Gauge Symmetry}

\begin{lstlisting}
Definition mu_gauge_shift (k : nat) (s : VMState) : VMState :=
  {| vm_regs := s.(vm_regs);
     vm_mem := s.(vm_mem);
     vm_csrs := s.(vm_csrs);
     vm_pc := s.(vm_pc);
     vm_graph := s.(vm_graph);
     vm_mu := s.(vm_mu) + k;
     vm_err := s.(vm_err) |}.
\end{lstlisting}

\begin{theorem}[Gauge Invariance]
\begin{lstlisting}
Theorem kernel_noether_mu_gauge : forall s k,
  conserved_partition_structure s = 
  conserved_partition_structure (nat_action k s).
\end{lstlisting}
\end{theorem}

\textbf{Physical Interpretation}: Noether's theorem—gauge symmetry (freedom to shift $\mu$ by a constant) corresponds to conservation of partition structure.

\subsection{$\mu$-Conservation}

\begin{theorem}[$\mu$-Conservation]
\begin{lstlisting}
Theorem mu_conservation_kernel : forall s s' instr,
  vm_step s instr s' ->
  s'.(vm_mu) >= s.(vm_mu).
\end{lstlisting}
\end{theorem}

\begin{proof}
By definition of \texttt{vm\_step}: every step rule updates \texttt{vm\_mu} to \texttt{apply\_cost s instr}, which adds a non-negative cost.
\end{proof}

\section{Multi-Step Conservation}

\subsection{Run Function}

\begin{lstlisting}
Fixpoint run_vm (fuel : nat) (trace : Trace) (s : VMState) : VMState :=
  match fuel with
  | O => s
  | S fuel' =>
      match nth_error trace s.(vm_pc) with
      | None => s
      | Some instr => run_vm fuel' trace (step_vm s instr)
      end
  end.
\end{lstlisting}

\subsection{Ledger Entries}

\begin{lstlisting}
Fixpoint ledger_entries (fuel : nat) (trace : Trace) (s : VMState) : list nat :=
  match fuel with
  | O => []
  | S fuel' =>
      match nth_error trace s.(vm_pc) with
      | None => []
      | Some instr =>
          instruction_cost instr :: ledger_entries fuel' trace (step_vm s instr)
      end
  end.

Definition ledger_sum (entries : list nat) : nat := fold_left Nat.add entries 0.
\end{lstlisting}

\subsection{Conservation Theorem}

\begin{theorem}[Run Conservation]
\begin{lstlisting}
Corollary run_vm_mu_conservation :
  forall fuel trace s,
    (run_vm fuel trace s).(vm_mu) =
    s.(vm_mu) + ledger_sum (ledger_entries fuel trace s).
\end{lstlisting}
\end{theorem}

\begin{proof}
By induction on fuel. Base case: empty ledger, $\mu$ unchanged. Inductive case: by \texttt{mu\_conservation\_kernel}, $\mu$ increases by exactly the instruction cost, which is the head of \texttt{ledger\_entries}.
\end{proof}

\subsection{Irreversibility Bound}

\begin{theorem}[Irreversibility]
\begin{lstlisting}
Theorem vm_irreversible_bits_lower_bound :
  forall fuel trace s,
    irreversible_count fuel trace s <=
      (run_vm fuel trace s).(vm_mu) - s.(vm_mu).
\end{lstlisting}
\end{theorem}

\textbf{Physical Interpretation}: The $\mu$-ledger growth lower-bounds irreversible bit events—connecting to Landauer's principle.

\section{No Free Insight: The Impossibility Theorem}

\subsection{Receipt Predicates}

\begin{lstlisting}
Definition ReceiptPredicate (A : Type) := list A -> bool.
\end{lstlisting}

\subsection{Strength Ordering}

\begin{lstlisting}
Definition stronger {A : Type} (P1 P2 : ReceiptPredicate A) : Prop :=
  forall obs, P1 obs = true -> P2 obs = true.

Definition strictly_stronger {A : Type} (P1 P2 : ReceiptPredicate A) : Prop :=
  (P1 <= P2) /\ (exists obs, P1 obs = false /\ P2 obs = true).
\end{lstlisting}

\subsection{Certification}

\begin{lstlisting}
Definition Certified {A : Type} 
                     (s_final : VMState)
                     (decoder : receipt_decoder A)
                     (P : ReceiptPredicate A)
                     (receipts : Receipts) : Prop :=
  s_final.(vm_err) = false /\ 
  has_supra_cert s_final /\ 
  P (decoder receipts) = true.
\end{lstlisting}

\subsection{The Main Theorem}

\begin{theorem}[No Free Insight — General Form]
\begin{lstlisting}
Theorem no_free_insight_general :
  forall (trace : Trace) (s_init s_final : VMState) (fuel : nat),
    trace_run fuel trace s_init = Some s_final ->
    s_init.(vm_csrs).(csr_cert_addr) = 0 ->
    has_supra_cert s_final ->
    uses_revelation trace \/
    (exists n m p mu, nth_error trace n = Some (instr_emit m p mu)) \/
    (exists n c1 c2 mu, nth_error trace n = Some (instr_ljoin c1 c2 mu)) \/
    (exists n m f c mu, nth_error trace n = Some (instr_lassert m f c mu)).
\end{lstlisting}
\end{theorem}

\begin{proof}
By the revelation requirement. The structure-addition analysis shows that if \texttt{csr\_cert\_addr} starts at 0 and ends non-zero (\texttt{has\_supra\_cert}), some instruction in the trace must have set it.
\end{proof}

\subsection{Strengthening Theorem}

\begin{theorem}[Strengthening Requires Structure]
\begin{lstlisting}
Theorem strengthening_requires_structure_addition :
  forall (A : Type)
         (decoder : receipt_decoder A)
         (P_weak P_strong : ReceiptPredicate A)
         (trace : Receipts)
         (s_init : VMState)
         (fuel : nat),
    strictly_stronger P_strong P_weak ->
    s_init.(vm_csrs).(csr_cert_addr) = 0 ->
    Certified (run_vm fuel trace s_init) decoder P_strong trace ->
    has_structure_addition fuel trace s_init.
\end{lstlisting}
\end{theorem}

\begin{proof}
\begin{enumerate}
    \item Unfold \texttt{Certified} to get \texttt{has\_supra\_cert}
    \texttt{(run\_vm fuel trace s\_init)}
    \item Apply \texttt{supra\_cert\_implies\_structure\_addition\_in\_run}
    \item The key lemma: reaching \texttt{has\_supra\_cert} from \texttt{csr\_cert\_addr = 0} requires an explicit cert-setter instruction
\end{enumerate}
\end{proof}

\section{Revelation Requirement: Supra-Quantum Certification}

\begin{theorem}[Nonlocal Correlation Requires Revelation]
\begin{lstlisting}
Theorem nonlocal_correlation_requires_revelation :
  forall (trace : Trace) (s_init s_final : VMState) (fuel : nat),
    trace_run fuel trace s_init = Some s_final ->
    s_init.(vm_csrs).(csr_cert_addr) = 0 ->
    has_supra_cert s_final ->
    uses_revelation trace \/
    (exists n m p mu, nth_error trace n = Some (instr_emit m p mu)) \/
    (exists n c1 c2 mu, nth_error trace n = Some (instr_ljoin c1 c2 mu)) \/
    (exists n m f c mu, nth_error trace n = Some (instr_lassert m f c mu)).
\end{lstlisting}
\end{theorem}

\textbf{Interpretation}: To achieve supra-quantum certification, you must explicitly pay for it through a revelation-type instruction. There is no backdoor.

\section{Proof Summary}

At the end of the verification campaign, the active proof tree contains no admits and no axioms beyond foundational logic. The result is a closed, machine-checked account of the model’s physics, accounting rules, and impossibility results. Every theorem in this chapter can be reconstructed from the definitions and lemmas above.

\section{Falsifiability}

Every theorem includes a falsifier specification:

\begin{lstlisting}
(** FALSIFIER: Exhibit a system satisfying A1-A4 where:
    - Two predicates P_weak, P_strong with P_strong < P_weak
    - A trace tr certifies P_strong
    - tr contains NO revelation event
    *)
\end{lstlisting}

If anyone can produce such a counterexample, the theorem is false. The proofs establish that no such counterexample exists within the Thiele Machine model.

\section{Summary}

The formal verification campaign establishes:
\begin{enumerate}
    \item \textbf{Locality}: Operations on one module cannot affect observables of unrelated modules
    \item \textbf{Conservation}: The $\mu$-ledger is monotonic and bounds irreversible operations
    \item \textbf{Impossibility}: Strengthening certification requires explicit, charged structure addition
    \item \textbf{Completeness}: Zero admits, zero axioms—all proofs are machine-checked
\end{enumerate}

These are not aspirational properties but proven invariants of the system.
