\section{Why Formal Verification?}

\subsection{The Limits of Testing}

Testing can find bugs, but it cannot prove their absence. If you test a sorting algorithm on 1000 inputs, you have evidence it works on those 1000 inputs---but there are infinitely many possible inputs. Formal verification replaces empirical sampling with universal quantification.

\textbf{Formal verification} proves properties hold for \textit{all} inputs. When I prove "$\mu$ is monotonically non-decreasing," I don't test it on examples---I prove it mathematically.

\subsection{The Coq Proof Assistant}

Coq is an interactive theorem prover based on dependent type theory. A Coq proof is:
\begin{itemize}
    \item \textbf{Machine-checked}: The computer verifies every step
    \item \textbf{Constructive}: Proofs can be extracted to executable code
    \item \textbf{Permanent}: Once proven, the result is certain (assuming Coq's kernel is correct)
\end{itemize}

\subsection{The Zero-Admit Standard}

The Thiele Machine uses an unusually strict standard:
\begin{itemize}
    \item \textbf{No \texttt{Admitted}}: Every theorem must be fully proven
    \item \textbf{No \texttt{admit.}}: No tactical shortcuts inside proofs
    \item \textbf{No \texttt{Axiom}}: No unproven assumptions (except foundational logic)
\end{itemize}

This standard is enforced automatically. Any commit introducing an admit fails CI. This matters because it guarantees every theorem in the active proof tree is fully discharged.

\subsection{What I Prove}

The key theorems proven in Coq are:
\begin{enumerate}
    \item \textbf{Observational No-Signaling}: Operations on one module cannot affect observables of other modules
    \item \textbf{$\mu$-Conservation}: The $\mu$-ledger never decreases
    \item \textbf{No Free Insight}: Strengthening certification requires explicit structure addition
    \item \textbf{Gauge Invariance}: Partition structure is invariant under $\mu$-shifts
\end{enumerate}

\subsection{How to Read This Chapter}

This chapter explains the proof structure and key statements. If you are unfamiliar with Coq:
\begin{itemize}
    \item \texttt{Theorem}, \texttt{Lemma}: Statements to prove
    \item \texttt{Proof. ... Qed.}: The proof itself
    \item \texttt{forall}: For all values of this type
    \item \texttt{->}: Implies
    \item \texttt{/\textbackslash}: And (conjunction)
    \item \texttt{\textbackslash/}: Or (disjunction)
\end{itemize}

Focus on understanding the \textit{statements} (what I prove), not the proof details. Every statement is written so it can be re-derived from the definitions given in Chapters 3 and 4.

\section{The Formal Verification Campaign}

The credibility of the Thiele Machine rests on machine-checked proofs. This chapter documents the verification campaign that culminated in a full removal of \texttt{Admitted}, \texttt{admit.}, and \texttt{Axiom} declarations from the active Coq tree. The practical consequence is rebuildability: a reader can re-implement the definitions and re-prove the same claims without relying on hidden assumptions.

All proofs are verified by Coq 8.18.x. The Inquisitor enforces this invariant: any commit introducing an admit or axiom fails CI.

\section{Proof Architecture}

\subsection{Conceptual Hierarchy}

The proof corpus is organized by concept rather than by implementation detail:
\begin{itemize}
    \item \textbf{State and partitions}: definitions of the machine state, partition graph, and normalization.
    \item \textbf{Step semantics}: the instruction set and its inductive transition rules.
    \item \textbf{Certification and receipts}: the logic of certificates and trace decoding.
    \item \textbf{Conservation and locality}: theorems about $\mu$-monotonicity and no-signaling.
    \item \textbf{Impossibility theorems}: No Free Insight and its corollaries.
\end{itemize}

The goal is not to “encode” the implementation, but to define a minimal semantics from which every implementation can be reconstructed. Each later proof depends only on earlier definitions and lemmas, so the dependency structure is acyclic and reproducible.

\subsection{Dependency Sketch}

The proofs build outward from the state and step definitions: first the operational semantics, then conservation/locality lemmas, and finally the impossibility results that rely on those invariants. The ordering is important: no theorem about $\mu$ or locality is used before the step relation is fixed.

\section{State Definitions: Foundation Layer}

\subsection{The State Record}

\begin{verbatim}
Record VMState := {
  vm_graph : PartitionGraph;
  vm_csrs : CSRState;
  vm_regs : list nat;
  vm_mem : list nat;
  vm_pc : nat;
  vm_mu : nat;
  vm_err : bool
}.
\end{verbatim}

\subsection{Canonical Region Normalization}

Regions are stored in canonical form to make observational equality well-defined:
\begin{verbatim}
Definition normalize_region (region : list nat) : list nat :=
  nodup Nat.eq_dec region.
\end{verbatim}

\begin{theorem}[Idempotence]
\begin{verbatim}
Lemma normalize_region_idempotent : forall region,
  normalize_region (normalize_region region) = normalize_region region.
\end{verbatim}
\end{theorem}

\begin{proof}
By \texttt{nodup\_fixed\_point}: applying \texttt{nodup} twice yields the same result, so normalization is idempotent and comparisons are stable.
\end{proof}

\subsection{Graph Well-Formedness}

\begin{verbatim}
Definition well_formed_graph (g : PartitionGraph) : Prop :=
  all_ids_below g.(pg_modules) g.(pg_next_id).
\end{verbatim}

\begin{theorem}[Preservation Under Add]
\begin{verbatim}
Lemma graph_add_module_preserves_wf : forall g region axioms g' mid,
  well_formed_graph g ->
  graph_add_module g region axioms = (g', mid) ->
  well_formed_graph g'.
\end{verbatim}
\end{theorem}

\begin{theorem}[Preservation Under Remove]
\begin{verbatim}
Lemma graph_remove_preserves_wf : forall g mid g' m,
  well_formed_graph g ->
  graph_remove g mid = Some (g', m) ->
  well_formed_graph g'.
\end{verbatim}
\end{theorem}

\section{Operational Semantics}

\subsection{The Instruction Type}

\begin{verbatim}
Inductive vm_instruction :=
| instr_pnew (region : list nat) (mu_delta : nat)
| instr_psplit (module : ModuleID) (left right : list nat) (mu_delta : nat)
| instr_pmerge (m1 m2 : ModuleID) (mu_delta : nat)
| instr_lassert (module : ModuleID) (formula : string)
    (cert : lassert_certificate) (mu_delta : nat)
| instr_ljoin (cert1 cert2 : string) (mu_delta : nat)
| instr_mdlacc (module : ModuleID) (mu_delta : nat)
| instr_pdiscover (module : ModuleID) (evidence : list VMAxiom) (mu_delta : nat)
| instr_xfer (dst src : nat) (mu_delta : nat)
| instr_pyexec (payload : string) (mu_delta : nat)
| instr_chsh_trial (x y a b : nat) (mu_delta : nat)
| instr_xor_load (dst addr : nat) (mu_delta : nat)
| instr_xor_add (dst src : nat) (mu_delta : nat)
| instr_xor_swap (a b : nat) (mu_delta : nat)
| instr_xor_rank (dst src : nat) (mu_delta : nat)
| instr_emit (module : ModuleID) (payload : string) (mu_delta : nat)
| instr_reveal (module : ModuleID) (bits : nat) (cert : string) (mu_delta : nat)
| instr_oracle_halts (payload : string) (mu_delta : nat)
| instr_halt (mu_delta : nat).
\end{verbatim}

\subsection{The Step Relation}

\begin{verbatim}
Inductive vm_step : VMState -> vm_instruction -> VMState -> Prop := ...
\end{verbatim}

Each instruction has one or more step rules. Key properties:
\begin{itemize}
    \item \textbf{Deterministic}: Each (state, instruction) pair has at most one successor when its preconditions hold.
    \item \textbf{Partial on invalid inputs}: Instructions with invalid certificates or failed structural checks can be undefined.
    \item \textbf{Cost-charging}: Every rule updates \texttt{vm\_mu} by the declared instruction cost.
\end{itemize}

This gives a complete operational semantics: given a well-formed state and a valid instruction, the next state is uniquely determined.

\section{Conservation and Locality}

This file establishes the physical laws of the Thiele Machine kernel—properties that hold for all executions without exception.

\subsection{Observables}

\begin{verbatim}
Definition Observable (s : VMState) (mid : nat) : option (list nat * nat) :=
  match graph_lookup s.(vm_graph) mid with
  | Some modstate => Some (normalize_region modstate.(module_region), s.(vm_mu))
  | None => None
  end.

Definition ObservableRegion (s : VMState) (mid : nat) : option (list nat) :=
  match graph_lookup s.(vm_graph) mid with
  | Some modstate => Some (normalize_region modstate.(module_region))
  | None => None
  end.
\end{verbatim}

Note: Axioms are \textbf{not} observable—they are internal implementation details. Observables contain only partition regions and the $\mu$-ledger, which is the cost-visible interface of the model.

\subsection{Instruction Target Sets}

\begin{verbatim}
Definition instr_targets (instr : vm_instruction) : list nat :=
  match instr with
  | instr_pnew _ _ => []
  | instr_psplit mid _ _ _ => [mid]
  | instr_pmerge m1 m2 _ => [m1; m2]
  | instr_lassert mid _ _ _ => [mid]
  ...
  end.
\end{verbatim}

\subsection{The No-Signaling Theorem}

\begin{theorem}[Observational No-Signaling]
\begin{verbatim}
Theorem observational_no_signaling : forall s s' instr mid,
  well_formed_graph s.(vm_graph) ->
  mid < pg_next_id s.(vm_graph) ->
  vm_step s instr s' ->
  ~ In mid (instr_targets instr) ->
  ObservableRegion s mid = ObservableRegion s' mid.
\end{verbatim}
\end{theorem}

\begin{proof}
By case analysis on the instruction. For each instruction type:
\begin{enumerate}
    \item If \texttt{mid} is not in \texttt{instr\_targets}, the instruction does not modify module \texttt{mid}
    \item Graph operations (pnew, psplit, pmerge) only affect targeted modules
    \item Logical operations (lassert, ljoin) only affect targeted module axioms (which are not observable)
    \item Memory operations (xfer, xor\_*) do not modify the partition graph
    \item Therefore, \texttt{ObservableRegion} is unchanged
\end{enumerate}
\end{proof}

\textbf{Physical Interpretation}: You cannot send signals to a remote module by operating on local state. This is the computational analog of Bell locality.

\subsection{Gauge Symmetry}

\begin{verbatim}
Definition mu_gauge_shift (k : nat) (s : VMState) : VMState :=
  {| vm_regs := s.(vm_regs);
     vm_mem := s.(vm_mem);
     vm_csrs := s.(vm_csrs);
     vm_pc := s.(vm_pc);
     vm_graph := s.(vm_graph);
     vm_mu := s.(vm_mu) + k;
     vm_err := s.(vm_err) |}.
\end{verbatim}

\begin{theorem}[Gauge Invariance]
\begin{verbatim}
Theorem kernel_noether_mu_gauge : forall s k,
  conserved_partition_structure s = 
  conserved_partition_structure (nat_action k s).
\end{verbatim}
\end{theorem}

\textbf{Physical Interpretation}: Noether's theorem—gauge symmetry (freedom to shift $\mu$ by a constant) corresponds to conservation of partition structure.

\subsection{$\mu$-Conservation}

\begin{theorem}[$\mu$-Conservation]
\begin{verbatim}
Theorem mu_conservation_kernel : forall s s' instr,
  vm_step s instr s' ->
  s'.(vm_mu) >= s.(vm_mu).
\end{verbatim}
\end{theorem}

\begin{proof}
By definition of \texttt{vm\_step}: every step rule updates \texttt{vm\_mu} to \texttt{apply\_cost s instr}, which adds a non-negative cost.
\end{proof}

\section{Multi-Step Conservation}

\subsection{Run Function}

\begin{verbatim}
Fixpoint run_vm (fuel : nat) (trace : Trace) (s : VMState) : VMState :=
  match fuel with
  | O => s
  | S fuel' =>
      match nth_error trace s.(vm_pc) with
      | None => s
      | Some instr => run_vm fuel' trace (step_vm s instr)
      end
  end.
\end{verbatim}

\subsection{Ledger Entries}

\begin{verbatim}
Fixpoint ledger_entries (fuel : nat) (trace : Trace) (s : VMState) : list nat :=
  match fuel with
  | O => []
  | S fuel' =>
      match nth_error trace s.(vm_pc) with
      | None => []
      | Some instr =>
          instruction_cost instr :: ledger_entries fuel' trace (step_vm s instr)
      end
  end.

Definition ledger_sum (entries : list nat) : nat := fold_left Nat.add entries 0.
\end{verbatim}

\subsection{Conservation Theorem}

\begin{theorem}[Run Conservation]
\begin{verbatim}
Corollary run_vm_mu_conservation :
  forall fuel trace s,
    (run_vm fuel trace s).(vm_mu) =
    s.(vm_mu) + ledger_sum (ledger_entries fuel trace s).
\end{verbatim}
\end{theorem}

\begin{proof}
By induction on fuel. Base case: empty ledger, $\mu$ unchanged. Inductive case: by \texttt{mu\_conservation\_kernel}, $\mu$ increases by exactly the instruction cost, which is the head of \texttt{ledger\_entries}.
\end{proof}

\subsection{Irreversibility Bound}

\begin{theorem}[Irreversibility]
\begin{verbatim}
Theorem vm_irreversible_bits_lower_bound :
  forall fuel trace s,
    irreversible_count fuel trace s <=
      (run_vm fuel trace s).(vm_mu) - s.(vm_mu).
\end{verbatim}
\end{theorem}

\textbf{Physical Interpretation}: The $\mu$-ledger growth lower-bounds irreversible bit events—connecting to Landauer's principle.

\section{No Free Insight: The Impossibility Theorem}

\subsection{Receipt Predicates}

\begin{verbatim}
Definition ReceiptPredicate (A : Type) := list A -> bool.
\end{verbatim}

\subsection{Strength Ordering}

\begin{verbatim}
Definition stronger {A : Type} (P1 P2 : ReceiptPredicate A) : Prop :=
  forall obs, P1 obs = true -> P2 obs = true.

Definition strictly_stronger {A : Type} (P1 P2 : ReceiptPredicate A) : Prop :=
  (P1 <= P2) /\ (exists obs, P1 obs = false /\ P2 obs = true).
\end{verbatim}

\subsection{Certification}

\begin{verbatim}
Definition Certified {A : Type} 
                     (s_final : VMState)
                     (decoder : receipt_decoder A)
                     (P : ReceiptPredicate A)
                     (receipts : Receipts) : Prop :=
  s_final.(vm_err) = false /\ 
  has_supra_cert s_final /\ 
  P (decoder receipts) = true.
\end{verbatim}

\subsection{The Main Theorem}

\begin{theorem}[No Free Insight — General Form]
\begin{verbatim}
Theorem no_free_insight_general :
  forall (trace : Trace) (s_init s_final : VMState) (fuel : nat),
    trace_run fuel trace s_init = Some s_final ->
    s_init.(vm_csrs).(csr_cert_addr) = 0 ->
    has_supra_cert s_final ->
    uses_revelation trace \/
    (exists n m p mu, nth_error trace n = Some (instr_emit m p mu)) \/
    (exists n c1 c2 mu, nth_error trace n = Some (instr_ljoin c1 c2 mu)) \/
    (exists n m f c mu, nth_error trace n = Some (instr_lassert m f c mu)).
\end{verbatim}
\end{theorem}

\begin{proof}
By the revelation requirement. The structure-addition analysis shows that if \texttt{csr\_cert\_addr} starts at 0 and ends non-zero (\texttt{has\_supra\_cert}), some instruction in the trace must have set it.
\end{proof}

\subsection{Strengthening Theorem}

\begin{theorem}[Strengthening Requires Structure]
\begin{verbatim}
Theorem strengthening_requires_structure_addition :
  forall (A : Type)
         (decoder : receipt_decoder A)
         (P_weak P_strong : ReceiptPredicate A)
         (trace : Receipts)
         (s_init : VMState)
         (fuel : nat),
    strictly_stronger P_strong P_weak ->
    s_init.(vm_csrs).(csr_cert_addr) = 0 ->
    Certified (run_vm fuel trace s_init) decoder P_strong trace ->
    has_structure_addition fuel trace s_init.
\end{verbatim}
\end{theorem}

\begin{proof}
\begin{enumerate}
    \item Unfold \texttt{Certified} to get \texttt{has\_supra\_cert (run\_vm fuel trace s\_init)}
    \item Apply \texttt{supra\_cert\_implies\_structure\_addition\_in\_run}
    \item The key lemma: reaching \texttt{has\_supra\_cert} from \texttt{csr\_cert\_addr = 0} requires an explicit cert-setter instruction
\end{enumerate}
\end{proof}

\section{Revelation Requirement: Supra-Quantum Certification}

\begin{theorem}[Nonlocal Correlation Requires Revelation]
\begin{verbatim}
Theorem nonlocal_correlation_requires_revelation :
  forall (trace : Trace) (s_init s_final : VMState) (fuel : nat),
    trace_run fuel trace s_init = Some s_final ->
    s_init.(vm_csrs).(csr_cert_addr) = 0 ->
    has_supra_cert s_final ->
    uses_revelation trace \/
    (exists n m p mu, nth_error trace n = Some (instr_emit m p mu)) \/
    (exists n c1 c2 mu, nth_error trace n = Some (instr_ljoin c1 c2 mu)) \/
    (exists n m f c mu, nth_error trace n = Some (instr_lassert m f c mu)).
\end{verbatim}
\end{theorem}

\textbf{Interpretation}: To achieve supra-quantum certification, you must explicitly pay for it through a revelation-type instruction. There is no backdoor.

\section{Proof Summary}

At the end of the verification campaign, the active proof tree contains no admits and no axioms beyond foundational logic. The result is a closed, machine-checked account of the model’s physics, accounting rules, and impossibility results. Every theorem in this chapter can be reconstructed from the definitions and lemmas above.

\section{Falsifiability}

Every theorem includes a falsifier specification:

\begin{verbatim}
(** FALSIFIER: Exhibit a system satisfying A1-A4 where:
    - Two predicates P_weak, P_strong with P_strong < P_weak
    - A trace tr certifies P_strong
    - tr contains NO revelation event
    *)
\end{verbatim}

If anyone can produce such a counterexample, the theorem is false. The proofs establish that no such counterexample exists within the Thiele Machine model.

\section{Summary}

The formal verification campaign establishes:
\begin{enumerate}
    \item \textbf{Locality}: Operations on one module cannot affect observables of unrelated modules
    \item \textbf{Conservation}: The $\mu$-ledger is monotonic and bounds irreversible operations
    \item \textbf{Impossibility}: Strengthening certification requires explicit, charged structure addition
    \item \textbf{Completeness}: Zero admits, zero axioms—all proofs are machine-checked
\end{enumerate}

These are not aspirational properties but proven invariants of the system.
