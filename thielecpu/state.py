# Licensed under the Apache License, Version 2.0 (the "License");
# Copyright 2025 Devon Thiele — See LICENSE for full terms.

"""
thielecpu/state.py — EXPERIMENTAL RESEARCH VM STATE
=====================================================
This module defines the state representation for the experimental research VM
(``thielecpu/vm.py``).  It is NOT the canonical VM state — for the ground-truth
state as used in Coq proofs and Verilog RTL, see ``build/thiele_core.ml``
(``vMState`` record, generated by Coq extraction).

The canonical ``vMState`` has these fields (from ``coq/kernel/VMState.v``):
  vm_graph, vm_csrs, vm_regs, vm_mem, vm_pc, vm_mu, vm_mu_tensor, vm_err

This research ``State`` class diverges intentionally — it adds:
  - MuLedger (splits vm_mu into discovery / execution / landauer_entropy)
  - Bianchi tensor invariant enforcement
  - Bitmask partition_masks alongside RegionGraph (dual representation)

The total mu is equivalent (proven in PythonMuLedgerBisimulation.v).
Field-level structural alignment to vMState is future work.
"""

from __future__ import annotations

import os
from dataclasses import dataclass, field
from typing import Callable, Set, Tuple, Dict, List, Any


class BianchiViolationError(Exception):
    """Raised when the mu_tensor violates the discrete Bianchi conservation law.

    The Bianchi identity ∇_μ G^μν = 0 is enforced at runtime by checking that
    no tensor component accumulates faster than the scalar mu total.  Specifically:
      (1) sum of all 16 tensor entries <= total mu  (global conservation)
      (2) each row sum <= total mu                  (local row divergence)
    A violation means information was created or destroyed without cost — a
    logical paradox that the VM refuses to execute.
    """

try:
    from .isa import CSR
    from .memory import RegionGraph
    from ._types import ModuleId
except ImportError:
    # Handle running as script
    import sys
    import os
    sys.path.insert(0, os.path.dirname(__file__))
    from isa import CSR
    from memory import RegionGraph
    from _types import ModuleId


# =============================================================================
# Canonical Constants (must match spec/thiele_machine_spec.md)
# =============================================================================

MASK_WIDTH = 64  # Fixed width for hardware compatibility

# Maximum number of active modules (configurable for testing)
# Default: 64 (matches Verilog full configuration)
# Override via environment: THIELE_MAX_MODULES=8 for constrained testing
_DEFAULT_MAX_MODULES = 64
MAX_MODULES = int(os.environ.get("THIELE_MAX_MODULES", str(_DEFAULT_MAX_MODULES)))

# Validation: Must be power of 2 in reasonable range
if MAX_MODULES not in [4, 8, 16, 32, 64, 128, 256]:
    raise ValueError(
        f"MAX_MODULES must be power of 2 in [4, 256], got {MAX_MODULES}. "
        f"Set THIELE_MAX_MODULES environment variable to override."
    )

# Architecture constants (matches Coq kernel/VMState.v and RTL)
NUM_MODULES = MAX_MODULES  # Alias matching Coq/RTL naming
REGION_SIZE = 16  # Maximum region size (matches RTL YOSYS_LITE synthesis config)

# Type alias for partition masks
PartitionMask = int  # 0..(1<<MASK_WIDTH)-1

def instruction() -> Any:
    """Type stub for cross-layer isomorphism (matches Coq kernel/Kernel.v inductive instruction and RTL instruction port).
    
    This is a placeholder to create a detectable symbol for the Atlas isomorphism validator.
    In Coq, this is 'Inductive instruction := T_Halt | T_Write | ...'.
    In RTL, this is the 'instruction' port signal.
    In Python, we use dynamic typing so no concrete type is needed.
    """
    pass


# =============================================================================
# Bitmask Helper Functions
# =============================================================================

def mask_of_indices(indices: Set[int]) -> PartitionMask:
    """Convert a set of indices to a bitmask representation."""
    mask = 0
    for idx in indices:
        if 0 <= idx < MASK_WIDTH:
            mask |= (1 << idx)
    return mask


def normalize_region(indices: Set[int]) -> Set[int]:
    """Return canonical in-range indices represented by MASK_WIDTH bits.

    This keeps the set-based RegionGraph representation aligned with the
    bitmask/RTL representation where only indices in [0, MASK_WIDTH) exist.
    """
    return {idx for idx in indices if 0 <= idx < MASK_WIDTH}


def indices_of_mask(mask: PartitionMask) -> Set[int]:
    """Convert a bitmask to a set of indices."""
    indices = set()
    for i in range(MASK_WIDTH):
        if mask & (1 << i):
            indices.add(i)
    return indices


def mask_union(a: PartitionMask, b: PartitionMask) -> PartitionMask:
    """Compute the union of two partition masks."""
    return a | b


def mask_intersection(a: PartitionMask, b: PartitionMask) -> PartitionMask:
    """Compute the intersection of two partition masks."""
    return a & b


def mask_disjoint(a: PartitionMask, b: PartitionMask) -> bool:
    """Check if two partition masks are disjoint (no overlap)."""
    return (a & b) == 0


def mask_popcount(mask: PartitionMask) -> int:
    """Count the number of set bits in a mask (population count)."""
    return bin(mask & ((1 << MASK_WIDTH) - 1)).count('1')


def region_size(indices: Set[int]) -> int:
    """Return the size of a region (matches Coq Prediction.v region_size)."""
    return len(normalize_region(indices))


def is_structured(graph: 'RegionGraph', module_id: ModuleId) -> bool:
    """Check if a partition module is structured (matches Coq PartitionDiscoveryIsomorphism.v)."""
    try:
        module = graph.lookup(module_id)
        if module is None:
            return False
        # A module is structured if its region has non-trivial structure
        return len(module.region) > 1
    except Exception:
        return False


def mu_bits(value: int) -> int:
    """Convert μ-cost to information bits (matches Coq theory/CostIsComplexity.v)."""
    # μ-cost is already in logical irreversibilty units (information bits)
    return value


def mu_total(state: 'State') -> int:
    """Get total accumulated μ-cost (matches Coq kernel/MuInformation.v)."""
    return state.mu


# =============================================================================
# μ-Ledger (Canonical Definition)
# =============================================================================

@dataclass
class MuLedger:
    """Tracks μ-bit costs for discovery and execution (extended with μ-tensor).

    This implements the canonical μ-ledger as defined in spec/thiele_machine_spec.md.
    All μ-values are monotonically non-decreasing.

    ISOMORPHISM GUARANTEE: This structure bisimulates Coq's vm_mu via the theorem
    python_mu_ledger_bisimulates_coq_vm_mu in coq/bridge/PythonMuLedgerBisimulation.v.

    Specifically: self.total ≡ vm_mu (modulo 2^32 hardware overflow semantics)

    The decomposition (mu_discovery, mu_execution, landauer_entropy) is a refinement
    that provides additional observability while preserving total μ-cost equivalence.
    """

    mu_discovery: int = 0   # Cost of partition discovery operations
    mu_execution: int = 0   # Cost of instruction execution
    landauer_entropy: int = 0  # Physical erasure accounting (side-channel)
    mu_tensor: List[List[int]] = field(default_factory=lambda: [[0]*4 for _ in range(4)])

    # HARDWARE CONSTANT: 32-bit width matching thiele_cpu.v
    MASK: int = 0xFFFFFFFF
    MAX_ENTROPY: int = 2**63 - 1

    @property
    def total(self) -> int:
        """Total μ-cost (discovery + execution)."""
        return (self.mu_discovery + self.mu_execution) & self.MASK

    def charge_execution(self, cost: int) -> None:
        """Atomic charge with hardware overflow semantics."""
        self.mu_execution = (self.mu_execution + cost) & self.MASK

    def charge_discovery(self, cost: int) -> None:
        """Atomic charge with hardware overflow semantics."""
        self.mu_discovery = (self.mu_discovery + cost) & self.MASK

    def track_entropy(self, bits: int) -> None:
        """Accumulate Landauer entropy without rollover."""
        if bits <= 0:
            return
        new_total = self.landauer_entropy + bits
        if new_total > self.MAX_ENTROPY:
            raise RuntimeError("Landauer entropy overflow")
        self.landauer_entropy = new_total

    def snapshot(self) -> Dict[str, int]:
        """Return a dictionary snapshot for tracing."""
        return {
            "mu_discovery": self.mu_discovery,
            "mu_execution": self.mu_execution,
            "mu_total": self.total,
            "landauer_entropy": self.landauer_entropy,
            "mu_tensor": [row.copy() for row in self.mu_tensor],
        }

    def copy(self) -> "MuLedger":
        """Create a copy of this ledger."""
        return MuLedger(
            mu_discovery=self.mu_discovery,
            mu_execution=self.mu_execution,
            landauer_entropy=self.landauer_entropy,
            mu_tensor=[row.copy() for row in self.mu_tensor],
        )

    def check_bianchi_consistency(self) -> None:
        """Enforce the discrete Bianchi conservation law.

        Rules (mirrors Coq mu_conservation_kernel logic):
          1. Tensor total <= scalar mu_total: the tensor is a *sub-ledger* of mu.
          2. Each row sum <= mu_total: no single interaction direction can
             accumulate more cost than the total — local over-charging is a paradox.

        Raises BianchiViolationError if either invariant is violated.
        """
        mu_total = self.total
        tensor_total = sum(
            self.mu_tensor[i][j] for i in range(4) for j in range(4)
        )
        if tensor_total > mu_total:
            raise BianchiViolationError(
                f"Bianchi violation: tensor total {tensor_total} > scalar μ={mu_total}. "
                "Information created from nothing — logical paradox."
            )
        for i in range(4):
            row_sum = sum(self.mu_tensor[i])
            if row_sum > mu_total:
                raise BianchiViolationError(
                    f"Bianchi violation: row {i} sum {row_sum} > scalar μ={mu_total}. "
                    f"Local divergence detected at tensor row {i}."
                )


Predicate = Callable[[int], bool]


@dataclass
class State:
    """Holds machine state ``S`` and partition table ``Π``.

    This implements the canonical state representation as defined in
    spec/thiele_machine_spec.md for isomorphism verification.

    IMPORTANT: This structure must align with CoreSemantics.State in Coq for
    cross-layer isomorphism verification.
    """

    mu_operational: float = 0.0  # Cost of operations (current mu) - legacy
    _mu_information: float = 0.0  # Cost of information revealed - legacy (internal)
    _next_id: int = 1
    regions: RegionGraph = field(default_factory=RegionGraph)
    axioms: Dict[ModuleId, List[str]] = field(default_factory=dict)  # Axioms per module
    csr: dict[CSR, int | str] = field(
        default_factory=lambda: {CSR.CERT_ADDR: "", CSR.STATUS: 0, CSR.ERR: 0}
    )
    step_count: int = 0

    # Canonical μ-ledger (spec/thiele_machine_spec.md)
    mu_ledger: MuLedger = field(default_factory=MuLedger)

    # Bitmask-based partition storage for hardware isomorphism
    partition_masks: Dict[ModuleId, PartitionMask] = field(default_factory=dict)

    # Program being executed (matches CoreSemantics.State.program field in Coq)
    program: List[Any] = field(default_factory=list)

    # Optional bookkeeping used by higher-level VM helpers.
    last_pdiscover_result: Dict[str, Any] | None = None

    @property
    def mu_information(self) -> float:
        """Get information revelation cost (read-only, monotonic)."""
        return self._mu_information
    
    @mu_information.setter
    def mu_information(self, value: float) -> None:
        """Set information cost with monotonicity enforcement.
        
        Raises:
            ValueError: If attempting to decrease μ_information
        """
        if value < self._mu_information:
            raise ValueError(
                f"μ-monotonicity violation: Cannot decrease mu_information from "
                f"{self._mu_information} to {value}. μ-ledger is monotonically non-decreasing."
            )
        if value < 0:
            raise ValueError(
                f"Invalid mu_information: {value}. μ-cost cannot be negative."
            )
        self._mu_information = value
    
    @property
    def mu(self) -> float:
        """Total mu cost (operational + information)."""
        return self.mu_operational + self._mu_information
    
    @property
    def num_modules(self) -> int:
        """Return the number of active modules."""
        return len(self.partition_masks)
    
    def module_exists(self, mid: ModuleId) -> bool:
        """Check if a module exists in the partition table (matches Coq kernel/Locality.v)."""
        return mid in self.partition_masks

    def _alloc(self, region: Set[int], charge_discovery: bool = False) -> ModuleId:
        """Allocate a new module for region.
        
        Args:
            region: Set of indices for this module
            charge_discovery: If True, charge discovery cost (only for PNEW)
        """
        mid = self._next_id
        self._next_id += 1
        canonical_region = normalize_region(region)
        self.regions.add(mid, canonical_region)
        # Also update bitmask representation
        region_mask = mask_of_indices(canonical_region)
        self.partition_masks[ModuleId(mid)] = region_mask
        
        if charge_discovery:
            self.mu_ledger.charge_discovery(mask_popcount(region_mask))
        
        return ModuleId(mid)

    def pnew(self, region: Set[int], *, charge_discovery: bool = True) -> ModuleId:
        """Create a module for ``region`` if not already present.

        μ-update: mu_discovery += popcount(region) when ``charge_discovery`` is True.

        NOTE: Cost is charged even if module already exists, matching Coq semantics.
        The PNEW instruction always costs μ, regardless of whether it creates a new module.
        """
        canonical_region = normalize_region(region)

        # Charge discovery cost if requested, even for duplicate PNEW
        if charge_discovery:
            region_mask = mask_of_indices(canonical_region)
            self.mu_ledger.charge_discovery(mask_popcount(region_mask))

        existing = self.regions.find(canonical_region)
        if existing is not None:
            return ModuleId(existing)

        if self.num_modules >= MAX_MODULES:
            raise ValueError(f"Cannot create module: max modules ({MAX_MODULES}) reached")
        mid = self._alloc(canonical_region, charge_discovery=False)  # Already charged above
        self.axioms[mid] = []  # Initialize empty axioms for new module

        self._enforce_invariant()
        return mid

    def psplit(
        self,
        module: ModuleId,
        pred: Predicate,
        *,
        charge_execution: bool = True,
        cost: int = 64,  # Default matches typical MASK_WIDTH, but should be overridden
    ) -> Tuple[ModuleId, ModuleId]:
        """Split ``module``'s region using ``pred`` into two modules.

        μ-update: mu_execution += cost (from instruction encoding).

        Args:
            module: Module ID to split
            pred: Predicate function to partition elements
            charge_execution: If True, charge μ-cost
            cost: μ-bits to charge (MUST match instruction mu_delta for isomorphism)

        ISOMORPHISM REQUIREMENT: The cost parameter MUST match the mu_delta in
        the instruction encoding to maintain perfect three-layer isomorphism
        with Coq and Verilog implementations.

        NOTE: Cost is charged REGARDLESS of success/failure, matching Coq semantics.
        """
        # Charge cost first (matches Coq: advance_state always applies cost)
        if charge_execution:
            self.mu_ledger.charge_execution(cost)

        region = self.regions[module]
        part1 = {x for x in region if pred(x)}
        part2 = region - part1
        if not part1 or not part2:
            empty = self._alloc(set())
            self.axioms[empty] = []  # Empty module has no axioms
            self._enforce_invariant()
            return module, empty
        self.regions.remove(module)
        # Remove from bitmask representation
        self.partition_masks.pop(module, None)

        axioms = self.axioms.pop(module, [])  # Get axioms before removing
        m1 = self._alloc(part1)
        m2 = self._alloc(part2)
        # Copy axioms to both new modules
        self.axioms[m1] = axioms.copy()
        self.axioms[m2] = axioms.copy()

        self._enforce_invariant()
        return m1, m2

    def psplit_explicit(
        self,
        module: ModuleId,
        left: Set[int],
        right: Set[int],
        *,
        charge_execution: bool = True,
        cost: int = 64,  # Default matches typical MASK_WIDTH, but should be overridden
    ) -> Tuple[ModuleId, ModuleId]:
        """Split ``module`` into explicit ``left`` and ``right`` regions.

        This matches the extracted trace form: PSPLIT mid {left} {right} cost.

        ISOMORPHISM REQUIREMENT: The cost parameter MUST match the mu_delta in
        the instruction encoding to maintain perfect three-layer isomorphism.
        """
        region = self.regions[module]
        if left & right:
            raise ValueError("psplit_explicit regions overlap")
        if (left | right) != region:
            raise ValueError("psplit_explicit regions must partition module region")

        self.regions.remove(module)
        self.partition_masks.pop(module, None)
        axioms = self.axioms.pop(module, [])

        m1 = self._alloc(left)
        m2 = self._alloc(right)
        self.axioms[m1] = axioms.copy()
        self.axioms[m2] = axioms.copy()

        if charge_execution:
            self.mu_ledger.charge_execution(cost)

        self._enforce_invariant()
        return m1, m2

    def pmerge(
        self,
        m1: ModuleId,
        m2: ModuleId,
        *,
        charge_execution: bool = True,
        cost: int = 4,  # Default, but should be overridden with instruction mu_delta
    ) -> ModuleId:
        """Merge two modules into one if their regions are disjoint.

        μ-update: mu_execution += cost (from instruction encoding).

        Args:
            m1, m2: Module IDs to merge
            charge_execution: If True, charge μ-cost
            cost: μ-bits to charge (MUST match instruction mu_delta for isomorphism)

        ISOMORPHISM REQUIREMENT: The cost parameter MUST match the mu_delta in
        the instruction encoding to maintain perfect three-layer isomorphism.

        NOTE: Cost is charged REGARDLESS of success/failure, matching Coq semantics.
        """
        # Charge cost first (matches Coq: advance_state always applies cost)
        if charge_execution:
            self.mu_ledger.charge_execution(cost)

        if m1 == m2:
            raise ValueError("cannot merge module with itself")
        r1 = self.regions[m1]
        r2 = self.regions[m2]
        if r1 & r2:
            raise ValueError("modules overlap; cannot merge")
        union = r1 | r2
        self.regions.remove(m1)
        self.regions.remove(m2)
        # Remove from bitmask representation
        self.partition_masks.pop(m1, None)
        self.partition_masks.pop(m2, None)

        axioms1 = self.axioms.pop(m1, [])
        axioms2 = self.axioms.pop(m2, [])
        existing = self.regions.find(union)
        if existing is not None:
            # Merge axioms if module already exists
            existing_id = ModuleId(existing)
            self.axioms[existing_id].extend(axioms1)
            self.axioms[existing_id].extend(axioms2)
            return existing_id
        mid = self._alloc(union)
        self.axioms[mid] = axioms1 + axioms2  # Combine axioms

        self._enforce_invariant()
        return mid

    def _enforce_invariant(self):
        """Enforce global invariant: |π_j| ≤ poly(n) for all partition modules."""
        n = sum(len(region) for region in self.regions.modules.values())
        poly_bound = n**2  # Example polynomial bound
        for module, region in self.regions.modules.items():
            if len(region) > poly_bound:
                raise ValueError(f"Invariant violated: module {module} has size {len(region)} > poly({n}) = {poly_bound}")

    def add_axiom(self, module: ModuleId, axiom: str) -> None:
        """Add an axiom to a module."""
        if module not in self.axioms:
            self.axioms[module] = []
        self.axioms[module].append(axiom)

    def get_module_axioms(self, module: ModuleId) -> List[str]:
        """Get all axioms for a module."""
        return self.axioms.get(module, [])
    
    def get_state_snapshot(self) -> Dict[str, Any]:
        """Return a snapshot of the current state for tracing.

        This format is designed for isomorphism verification with
        Verilog RTL and Coq proofs.
        """
        return {
            "num_modules": self.num_modules,
            "partition_masks": [
                int(self.partition_masks.get(ModuleId(i + 1), 0))
                for i in range(MAX_MODULES)
            ],
            "mu": self.mu_ledger.snapshot(),
            "step_count": self.step_count,
            "program_length": len(self.program),
        }
