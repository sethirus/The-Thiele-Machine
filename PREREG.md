# PREREG: μ predicts SAT difficulty (Z3)

Date (UTC): 2025-12-18  
Repo: sethirus/The-Thiele-Machine  
Goal: Test whether μ-cost (computed without solving) predicts SAT solver runtime.

Note on timestamps:
- The binding run timestamp is `created_at` in `MANIFEST.json` (UTC). Use that for audit.

## Data split (locked)

- `split_seed`: 7
- `test_ratio`: 0.25
- Split rule: `split = "test"` iff `hash(split_seed, instance_id) < test_ratio`, else `"train"`.
- `instances/meta.jsonl` must contain `split` for every instance.

## Locked definitions

### μ routine (NO_SOLVE)

- μ extraction tool: `tools/cnf_analyzer.py` (`CNFAnalyzer`)
- Partition discovery: `thielecpu/discovery.py` (spectral clustering)
- μ outputs used:
  - `mu_total` (μ-spec v2.0)
  - Components recorded: `mu_discovery`, `mu_operational`, `interaction_density`, `num_modules`

NO_SOLVE enforcement:

NO_SOLVE enforcement (must all hold during μ extraction):
- Ban importing `z3` / `z3.*`.
- Ban `subprocess.*`, `os.system`, `os.exec*`.
- Emit `no_solve_receipt.json` with start/end timestamps, blocked-call counters, and environment snapshot.
- Any violation => run invalid.

### Solver routine

- Baseline solver: Z3 via `z3-solver` Python package
- Timeout: 5 seconds per instance by default (configurable, but must be recorded)
- Runtime metric: wall-clock seconds for `solver.check()`

## Instance families (4)

Generated via existing repo generator `tools/generate_cnf_instances.py`:

1. `modular` (structured, modules param)
2. `chain` (structured)
3. `tree` (structured)
4. `random` (negative control)

Default prereg suite:
- Variable counts: 20, 30, 40
- Instances per (family,size): 15
- Seed base: 1000 (IDs include seed)

## Instance generation (locked)

Generation must match the repository generator `tools/generate_cnf_instances.py` as used by `tools/mu_sat_difficulty_scale.py`.

For each (family, n_vars) generate exactly `per_size` instances with seeds `seed_base + k` for `k ∈ [0, per_size)`.

Locked knobs (as implemented in `tools/generate_cnf_instances.py` + `tools/mu_sat_difficulty_scale.py`):

random:
- 3-SAT (`clause_size=3`)
- clause construction: uniform random variable selection + random polarities
- clause count policy: `clauses_per_var=4` ⇒ `m = 4 * n_vars`

modular:
- `num_modules = max(2, floor(n_vars / 10))`
- clause construction: intra-module XOR-like constraints (no inter-module dependencies)

chain:
- chain constraints as implemented by `generate_chain_cnf` (default parameters)

tree:
- branching factor as implemented by `generate_tree_cnf` (default parameters)

Control instances (sanity-only, not part of PASS metrics):
- A small batch of 2-SAT and Horn-SAT instances is generated by the prereg harness for sanity falsification checks.

## Outputs (must be produced in this order)

1. `benchmarks/mu_sat_difficulty/instances/meta.jsonl`
2. `benchmarks/mu_sat_difficulty/predictions.jsonl`
3. `benchmarks/mu_sat_difficulty/no_solve_receipt.json` (required if `--no-solve`)
4. `benchmarks/mu_sat_difficulty/z3_results.csv`
5. `benchmarks/mu_sat_difficulty/analysis.json`
6. `benchmarks/mu_sat_difficulty/fig_mu_vs_runtime.png` (best-effort)

Binding manifest:
- A run must create `benchmarks/mu_sat_difficulty/MANIFEST.json` before generation.
- `analysis` must read only from the manifest + saved artifacts and must verify hashes.

The `predictions.jsonl` file must exist before solver runs begin.

## Metrics (primary)

Let X = `mu_total`, Y = `log10(runtime_s)`.

- **PASS-1 (correlation):** Spearman ρ(X,Y) ≥ 0.6 on **holdout solved-only**.
- **PASS-2 (value-add):** ΔR² ≥ 0.10 on **holdout solved-only** log-runtime when adding μ to baseline features.
  - Baseline A features: [`n_vars`, `n_clauses`]
  - Baseline A+μ features: [`n_vars`, `n_clauses`, `mu_total`]
- **PASS-3 (robustness):** Spearman ρ ≥ 0.4 in ≥ 3 of 4 families (holdout solved-only).

Baseline B (anti-size delusion):
- Must also report Baseline B vs Baseline B+μ holdout R².
- Baseline B features are cheap structural stats recorded in `instances/meta.jsonl` (`avg_clause_len`, `mean_degree`, `horn_fraction`, `is_2sat`, etc).

Hard/easy classifier:
- Hard = runtime ≥ 1.0s OR timeout
- Report **holdout** AUC using μ as score.

Timeout handling:
- Correlation/regression computed on solved-only subset (timeouts are censored).
- Classification metric includes timeouts.

Runtime measurement (locked):
- Single-thread policy: configure Z3 to use 1 thread (best-effort; record actual config).
- Measure `check_s` = wall-clock seconds around `solver.check()`.
- Record `encode_s` separately (DIMACS parse + Z3 constraint construction), but do NOT use it in Y.
- Each instance is run exactly once.

Minimum solved count (locked):
- If holdout solved-only count < 20 overall OR < 5 within any primary family,
  declare PASS-1/PASS-2 “not evaluable” and treat as FAIL for prereg purposes.

## Fail conditions

- μ extraction imports or calls Z3 (`NO_SOLVE` violation)
- μ adds no predictive value vs size features (ΔR² < 0.10)
- Correlation is confined to a single family and collapses elsewhere

## Execution

One-shot:
- `python tools/mu_sat_difficulty_scale.py run --no-solve`

Recommended (minutes, statistically defensible):
- `python tools/mu_sat_difficulty_scale.py run --no-solve --sizes 20 30 40 --per-size 15 --timeout 5 --hard-threshold 1.0`

Staged (manifest-first):
- `python tools/mu_sat_difficulty_scale.py init --no-solve`
- `python tools/mu_sat_difficulty_scale.py generate`
- `python tools/mu_sat_difficulty_scale.py predict --no-solve`
- `python tools/mu_sat_difficulty_scale.py solve --timeout 5`
- `python tools/mu_sat_difficulty_scale.py analyze`

Or staged:
- `python tools/mu_sat_difficulty_scale.py generate`
- `python tools/mu_sat_difficulty_scale.py predict --no-solve`
- `python tools/mu_sat_difficulty_scale.py solve --timeout 5`
- `python tools/mu_sat_difficulty_scale.py analyze`

## Sanity falsifiers (locked)

1) Permutation invariance:
- For 10 primary instances, generate a clause/variable-renamed twin.
- Require relative μ stability: `|μ - μ_twin| / max(μ, μ_twin) < 0.01`.
- Any violation invalidates the run.

2) 2-SAT / Horn control:
- Include a small batch of guaranteed-2SAT and high-Horn-fraction instances.
- Require they are not classified “hard” by Z3 at the configured hard threshold.
